{"ast":null,"code":"import _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @author Mugen87 / https://github.com/Mugen87\n */\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Geometry } from '../core/Geometry.js';\nimport { _Math } from '../math/Math.js';\n\nfunction EdgesGeometry(geometry, thresholdAngle) {\n  BufferGeometry.call(this);\n  this.type = 'EdgesGeometry';\n  this.parameters = {\n    thresholdAngle: thresholdAngle\n  };\n  thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1; // buffer\n\n  var vertices = []; // helper variables\n\n  var thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);\n  var edge = [0, 0],\n      edges = {},\n      edge1,\n      edge2;\n  var key,\n      keys = ['a', 'b', 'c']; // prepare source geometry\n\n  var geometry2;\n\n  if (geometry.isBufferGeometry) {\n    geometry2 = new Geometry();\n    geometry2.fromBufferGeometry(geometry);\n  } else {\n    geometry2 = geometry.clone();\n  }\n\n  geometry2.mergeVertices();\n  geometry2.computeFaceNormals();\n  var sourceVertices = geometry2.vertices;\n  var faces = geometry2.faces; // now create a data structure where each entry represents an edge with its adjoining faces\n\n  for (var i = 0, l = faces.length; i < l; i++) {\n    var face = faces[i];\n\n    for (var j = 0; j < 3; j++) {\n      edge1 = face[keys[j]];\n      edge2 = face[keys[(j + 1) % 3]];\n      edge[0] = Math.min(edge1, edge2);\n      edge[1] = Math.max(edge1, edge2);\n      key = edge[0] + ',' + edge[1];\n\n      if (edges[key] === undefined) {\n        edges[key] = {\n          index1: edge[0],\n          index2: edge[1],\n          face1: i,\n          face2: undefined\n        };\n      } else {\n        edges[key].face2 = i;\n      }\n    }\n  } // generate vertices\n\n\n  for (key in edges) {\n    var e = edges[key]; // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\n\n    if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {\n      var vertex = sourceVertices[e.index1];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n      vertex = sourceVertices[e.index2];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n  } // build geometry\n\n\n  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n}\n\nEdgesGeometry.prototype = _Object$create(BufferGeometry.prototype);\nEdgesGeometry.prototype.constructor = EdgesGeometry;\nexport { EdgesGeometry };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/geometries/EdgesGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Geometry","_Math","EdgesGeometry","geometry","thresholdAngle","call","type","parameters","undefined","vertices","thresholdDot","Math","cos","DEG2RAD","edge","edges","edge1","edge2","key","keys","geometry2","isBufferGeometry","fromBufferGeometry","clone","mergeVertices","computeFaceNormals","sourceVertices","faces","i","l","length","face","j","min","max","index1","index2","face1","face2","e","normal","dot","vertex","push","x","y","z","setAttribute","prototype","constructor"],"mappings":"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","sourcesContent":["/**\n * @author WestLangley / http://github.com/WestLangley\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Geometry } from '../core/Geometry.js';\nimport { _Math } from '../math/Math.js';\n\nfunction EdgesGeometry( geometry, thresholdAngle ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'EdgesGeometry';\n\n\tthis.parameters = {\n\t\tthresholdAngle: thresholdAngle\n\t};\n\n\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n\t// buffer\n\n\tvar vertices = [];\n\n\t// helper variables\n\n\tvar thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\n\tvar edge = [ 0, 0 ], edges = {}, edge1, edge2;\n\tvar key, keys = [ 'a', 'b', 'c' ];\n\n\t// prepare source geometry\n\n\tvar geometry2;\n\n\tif ( geometry.isBufferGeometry ) {\n\n\t\tgeometry2 = new Geometry();\n\t\tgeometry2.fromBufferGeometry( geometry );\n\n\t} else {\n\n\t\tgeometry2 = geometry.clone();\n\n\t}\n\n\tgeometry2.mergeVertices();\n\tgeometry2.computeFaceNormals();\n\n\tvar sourceVertices = geometry2.vertices;\n\tvar faces = geometry2.faces;\n\n\t// now create a data structure where each entry represents an edge with its adjoining faces\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tvar face = faces[ i ];\n\n\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\tedge1 = face[ keys[ j ] ];\n\t\t\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\tedge[ 0 ] = Math.min( edge1, edge2 );\n\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\n\t\t\tkey = edge[ 0 ] + ',' + edge[ 1 ];\n\n\t\t\tif ( edges[ key ] === undefined ) {\n\n\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };\n\n\t\t\t} else {\n\n\t\t\t\tedges[ key ].face2 = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// generate vertices\n\n\tfor ( key in edges ) {\n\n\t\tvar e = edges[ key ];\n\n\t\t// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\n\n\t\tif ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {\n\n\t\t\tvar vertex = sourceVertices[ e.index1 ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\tvertex = sourceVertices[ e.index2 ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n}\n\nEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\nEdgesGeometry.prototype.constructor = EdgesGeometry;\n\n\nexport { EdgesGeometry };\n"]},"metadata":{},"sourceType":"module"}