{"ast":null,"code":"import _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport { Ray } from '../math/Ray.js';\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author bhouston / http://clara.io/\n * @author stephomi / http://stephaneginier.com/\n */\n\nfunction Raycaster(origin, direction, near, far) {\n  this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)\n\n  this.near = near || 0;\n  this.far = far || Infinity;\n  this.camera = null;\n  this.params = {\n    Mesh: {},\n    Line: {},\n    LOD: {},\n    Points: {\n      threshold: 1\n    },\n    Sprite: {}\n  };\n\n  _Object$defineProperties(this.params, {\n    PointCloud: {\n      get: function get() {\n        console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');\n        return this.Points;\n      }\n    }\n  });\n}\n\nfunction ascSort(a, b) {\n  return a.distance - b.distance;\n}\n\nfunction _intersectObject(object, raycaster, intersects, recursive) {\n  if (object.visible === false) return;\n  object.raycast(raycaster, intersects);\n\n  if (recursive === true) {\n    var children = object.children;\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      _intersectObject(children[i], raycaster, intersects, true);\n    }\n  }\n}\n\n_Object$assign(Raycaster.prototype, {\n  linePrecision: 1,\n  set: function set(origin, direction) {\n    // direction is assumed to be normalized (for accurate distance calculations)\n    this.ray.set(origin, direction);\n  },\n  setFromCamera: function setFromCamera(coords, camera) {\n    if (camera && camera.isPerspectiveCamera) {\n      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);\n      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();\n      this.camera = camera;\n    } else if (camera && camera.isOrthographicCamera) {\n      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera\n\n      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);\n      this.camera = camera;\n    } else {\n      console.error('THREE.Raycaster: Unsupported camera type.');\n    }\n  },\n  intersectObject: function intersectObject(object, recursive, optionalTarget) {\n    var intersects = optionalTarget || [];\n\n    _intersectObject(object, this, intersects, recursive);\n\n    intersects.sort(ascSort);\n    return intersects;\n  },\n  intersectObjects: function intersectObjects(objects, recursive, optionalTarget) {\n    var intersects = optionalTarget || [];\n\n    if (_Array$isArray(objects) === false) {\n      console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');\n      return intersects;\n    }\n\n    for (var i = 0, l = objects.length; i < l; i++) {\n      _intersectObject(objects[i], this, intersects, recursive);\n    }\n\n    intersects.sort(ascSort);\n    return intersects;\n  }\n});\n\nexport { Raycaster };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/core/Raycaster.js"],"names":["Ray","Raycaster","origin","direction","near","far","ray","Infinity","camera","params","Mesh","Line","LOD","Points","threshold","Sprite","PointCloud","get","console","warn","ascSort","a","b","distance","intersectObject","object","raycaster","intersects","recursive","visible","raycast","children","i","l","length","prototype","linePrecision","set","setFromCamera","coords","isPerspectiveCamera","setFromMatrixPosition","matrixWorld","x","y","unproject","sub","normalize","isOrthographicCamera","transformDirection","error","optionalTarget","sort","intersectObjects","objects"],"mappings":"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","sourcesContent":["import { Ray } from '../math/Ray.js';\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author bhouston / http://clara.io/\n * @author stephomi / http://stephaneginier.com/\n */\n\nfunction Raycaster( origin, direction, near, far ) {\n\n\tthis.ray = new Ray( origin, direction );\n\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\tthis.near = near || 0;\n\tthis.far = far || Infinity;\n\tthis.camera = null;\n\n\tthis.params = {\n\t\tMesh: {},\n\t\tLine: {},\n\t\tLOD: {},\n\t\tPoints: { threshold: 1 },\n\t\tSprite: {}\n\t};\n\n\tObject.defineProperties( this.params, {\n\t\tPointCloud: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\treturn this.Points;\n\n\t\t\t}\n\t\t}\n\t} );\n\n}\n\nfunction ascSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\tif ( object.visible === false ) return;\n\n\tobject.raycast( raycaster, intersects );\n\n\tif ( recursive === true ) {\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t}\n\n\t}\n\n}\n\nObject.assign( Raycaster.prototype, {\n\n\tlinePrecision: 1,\n\n\tset: function ( origin, direction ) {\n\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.ray.set( origin, direction );\n\n\t},\n\n\tsetFromCamera: function ( coords, camera ) {\n\n\t\tif ( ( camera && camera.isPerspectiveCamera ) ) {\n\n\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\t\tthis.camera = camera;\n\n\t\t} else if ( ( camera && camera.isOrthographicCamera ) ) {\n\n\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\tthis.camera = camera;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\n\t\t}\n\n\t},\n\n\tintersectObject: function ( object, recursive, optionalTarget ) {\n\n\t\tvar intersects = optionalTarget || [];\n\n\t\tintersectObject( object, this, intersects, recursive );\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t},\n\n\tintersectObjects: function ( objects, recursive, optionalTarget ) {\n\n\t\tvar intersects = optionalTarget || [];\n\n\t\tif ( Array.isArray( objects ) === false ) {\n\n\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\treturn intersects;\n\n\t\t}\n\n\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t}\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n} );\n\n\nexport { Raycaster };\n"]},"metadata":{},"sourceType":"module"}