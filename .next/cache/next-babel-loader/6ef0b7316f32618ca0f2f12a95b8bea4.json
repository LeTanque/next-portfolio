{"ast":null,"code":"import _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport { AnimationUtils } from './AnimationUtils.js';\nimport { KeyframeTrack } from './KeyframeTrack.js';\nimport { BooleanKeyframeTrack } from './tracks/BooleanKeyframeTrack.js';\nimport { ColorKeyframeTrack } from './tracks/ColorKeyframeTrack.js';\nimport { NumberKeyframeTrack } from './tracks/NumberKeyframeTrack.js';\nimport { QuaternionKeyframeTrack } from './tracks/QuaternionKeyframeTrack.js';\nimport { StringKeyframeTrack } from './tracks/StringKeyframeTrack.js';\nimport { VectorKeyframeTrack } from './tracks/VectorKeyframeTrack.js';\nimport { _Math } from '../math/Math.js';\n/**\n *\n * Reusable set of Tracks that represent an animation.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n */\n\nfunction AnimationClip(name, duration, tracks) {\n  this.name = name;\n  this.tracks = tracks;\n  this.duration = duration !== undefined ? duration : -1;\n  this.uuid = _Math.generateUUID(); // this means it should figure out its duration by scanning the tracks\n\n  if (this.duration < 0) {\n    this.resetDuration();\n  }\n}\n\nfunction getTrackTypeForValueTypeName(typeName) {\n  switch (typeName.toLowerCase()) {\n    case 'scalar':\n    case 'double':\n    case 'float':\n    case 'number':\n    case 'integer':\n      return NumberKeyframeTrack;\n\n    case 'vector':\n    case 'vector2':\n    case 'vector3':\n    case 'vector4':\n      return VectorKeyframeTrack;\n\n    case 'color':\n      return ColorKeyframeTrack;\n\n    case 'quaternion':\n      return QuaternionKeyframeTrack;\n\n    case 'bool':\n    case 'boolean':\n      return BooleanKeyframeTrack;\n\n    case 'string':\n      return StringKeyframeTrack;\n  }\n\n  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);\n}\n\nfunction parseKeyframeTrack(json) {\n  if (json.type === undefined) {\n    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');\n  }\n\n  var trackType = getTrackTypeForValueTypeName(json.type);\n\n  if (json.times === undefined) {\n    var times = [],\n        values = [];\n    AnimationUtils.flattenJSON(json.keys, times, values, 'value');\n    json.times = times;\n    json.values = values;\n  } // derived classes can define a static parse method\n\n\n  if (trackType.parse !== undefined) {\n    return trackType.parse(json);\n  } else {\n    // by default, we assume a constructor compatible with the base\n    return new trackType(json.name, json.times, json.values, json.interpolation);\n  }\n}\n\n_Object$assign(AnimationClip, {\n  parse: function (json) {\n    var tracks = [],\n        jsonTracks = json.tracks,\n        frameTime = 1.0 / (json.fps || 1.0);\n\n    for (var i = 0, n = jsonTracks.length; i !== n; ++i) {\n      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));\n    }\n\n    return new AnimationClip(json.name, json.duration, tracks);\n  },\n  toJSON: function (clip) {\n    var tracks = [],\n        clipTracks = clip.tracks;\n    var json = {\n      'name': clip.name,\n      'duration': clip.duration,\n      'tracks': tracks,\n      'uuid': clip.uuid\n    };\n\n    for (var i = 0, n = clipTracks.length; i !== n; ++i) {\n      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));\n    }\n\n    return json;\n  },\n  CreateFromMorphTargetSequence: function (name, morphTargetSequence, fps, noLoop) {\n    var numMorphTargets = morphTargetSequence.length;\n    var tracks = [];\n\n    for (var i = 0; i < numMorphTargets; i++) {\n      var times = [];\n      var values = [];\n      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);\n      values.push(0, 1, 0);\n      var order = AnimationUtils.getKeyframeOrder(times);\n      times = AnimationUtils.sortedArray(times, 1, order);\n      values = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the\n      // last frame as well for perfect loop.\n\n      if (!noLoop && times[0] === 0) {\n        times.push(numMorphTargets);\n        values.push(values[0]);\n      }\n\n      tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));\n    }\n\n    return new AnimationClip(name, -1, tracks);\n  },\n  findByName: function (objectOrClipArray, name) {\n    var clipArray = objectOrClipArray;\n\n    if (!_Array$isArray(objectOrClipArray)) {\n      var o = objectOrClipArray;\n      clipArray = o.geometry && o.geometry.animations || o.animations;\n    }\n\n    for (var i = 0; i < clipArray.length; i++) {\n      if (clipArray[i].name === name) {\n        return clipArray[i];\n      }\n    }\n\n    return null;\n  },\n  CreateClipsFromMorphTargetSequences: function (morphTargets, fps, noLoop) {\n    var animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences\n    // such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\n    var pattern = /^([\\w-]*?)([\\d]+)$/; // sort morph target names into animation groups based\n    // patterns like Walk_001, Walk_002, Run_001, Run_002\n\n    for (var i = 0, il = morphTargets.length; i < il; i++) {\n      var morphTarget = morphTargets[i];\n      var parts = morphTarget.name.match(pattern);\n\n      if (parts && parts.length > 1) {\n        var name = parts[1];\n        var animationMorphTargets = animationToMorphTargets[name];\n\n        if (!animationMorphTargets) {\n          animationToMorphTargets[name] = animationMorphTargets = [];\n        }\n\n        animationMorphTargets.push(morphTarget);\n      }\n    }\n\n    var clips = [];\n\n    for (var name in animationToMorphTargets) {\n      clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));\n    }\n\n    return clips;\n  },\n  // parse the animation.hierarchy format\n  parseAnimation: function (animation, bones) {\n    if (!animation) {\n      console.error('THREE.AnimationClip: No animation in JSONLoader data.');\n      return null;\n    }\n\n    var addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {\n      // only return track if there are actually keys.\n      if (animationKeys.length !== 0) {\n        var times = [];\n        var values = [];\n        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again\n\n        if (times.length !== 0) {\n          destTracks.push(new trackType(trackName, times, values));\n        }\n      }\n    };\n\n    var tracks = [];\n    var clipName = animation.name || 'default'; // automatic length determination in AnimationClip.\n\n    var duration = animation.length || -1;\n    var fps = animation.fps || 30;\n    var hierarchyTracks = animation.hierarchy || [];\n\n    for (var h = 0; h < hierarchyTracks.length; h++) {\n      var animationKeys = hierarchyTracks[h].keys; // skip empty tracks\n\n      if (!animationKeys || animationKeys.length === 0) continue; // process morph targets\n\n      if (animationKeys[0].morphTargets) {\n        // figure out all morph targets used in this track\n        var morphTargetNames = {};\n\n        for (var k = 0; k < animationKeys.length; k++) {\n          if (animationKeys[k].morphTargets) {\n            for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {\n              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;\n            }\n          }\n        } // create a track for each morph target with all zero\n        // morphTargetInfluences except for the keys in which\n        // the morphTarget is named.\n\n\n        for (var morphTargetName in morphTargetNames) {\n          var times = [];\n          var values = [];\n\n          for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {\n            var animationKey = animationKeys[k];\n            times.push(animationKey.time);\n            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);\n          }\n\n          tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));\n        }\n\n        duration = morphTargetNames.length * (fps || 1.0);\n      } else {\n        // ...assume skeletal animation\n        var boneName = '.bones[' + bones[h].name + ']';\n        addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);\n        addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);\n        addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);\n      }\n    }\n\n    if (tracks.length === 0) {\n      return null;\n    }\n\n    var clip = new AnimationClip(clipName, duration, tracks);\n    return clip;\n  }\n});\n\n_Object$assign(AnimationClip.prototype, {\n  resetDuration: function () {\n    var tracks = this.tracks,\n        duration = 0;\n\n    for (var i = 0, n = tracks.length; i !== n; ++i) {\n      var track = this.tracks[i];\n      duration = Math.max(duration, track.times[track.times.length - 1]);\n    }\n\n    this.duration = duration;\n    return this;\n  },\n  trim: function () {\n    for (var i = 0; i < this.tracks.length; i++) {\n      this.tracks[i].trim(0, this.duration);\n    }\n\n    return this;\n  },\n  validate: function () {\n    var valid = true;\n\n    for (var i = 0; i < this.tracks.length; i++) {\n      valid = valid && this.tracks[i].validate();\n    }\n\n    return valid;\n  },\n  optimize: function () {\n    for (var i = 0; i < this.tracks.length; i++) {\n      this.tracks[i].optimize();\n    }\n\n    return this;\n  },\n  clone: function () {\n    var tracks = [];\n\n    for (var i = 0; i < this.tracks.length; i++) {\n      tracks.push(this.tracks[i].clone());\n    }\n\n    return new AnimationClip(this.name, this.duration, tracks);\n  }\n});\n\nexport { AnimationClip };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/animation/AnimationClip.js"],"names":["AnimationUtils","KeyframeTrack","BooleanKeyframeTrack","ColorKeyframeTrack","NumberKeyframeTrack","QuaternionKeyframeTrack","StringKeyframeTrack","VectorKeyframeTrack","_Math","AnimationClip","name","duration","tracks","undefined","uuid","generateUUID","resetDuration","getTrackTypeForValueTypeName","typeName","toLowerCase","Error","parseKeyframeTrack","json","type","trackType","times","values","flattenJSON","keys","parse","interpolation","jsonTracks","frameTime","fps","i","n","length","push","scale","toJSON","clip","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","order","getKeyframeOrder","sortedArray","findByName","objectOrClipArray","clipArray","o","geometry","animations","CreateClipsFromMorphTargetSequences","morphTargets","animationToMorphTargets","pattern","il","morphTarget","parts","match","animationMorphTargets","clips","parseAnimation","animation","bones","console","error","addNonemptyTrack","trackName","animationKeys","propertyName","destTracks","clipName","hierarchyTracks","hierarchy","h","morphTargetNames","k","m","morphTargetName","animationKey","time","boneName","prototype","track","Math","max","trim","validate","valid","optimize","clone"],"mappings":"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","sourcesContent":["import { AnimationUtils } from './AnimationUtils.js';\nimport { KeyframeTrack } from './KeyframeTrack.js';\nimport { BooleanKeyframeTrack } from './tracks/BooleanKeyframeTrack.js';\nimport { ColorKeyframeTrack } from './tracks/ColorKeyframeTrack.js';\nimport { NumberKeyframeTrack } from './tracks/NumberKeyframeTrack.js';\nimport { QuaternionKeyframeTrack } from './tracks/QuaternionKeyframeTrack.js';\nimport { StringKeyframeTrack } from './tracks/StringKeyframeTrack.js';\nimport { VectorKeyframeTrack } from './tracks/VectorKeyframeTrack.js';\nimport { _Math } from '../math/Math.js';\n\n/**\n *\n * Reusable set of Tracks that represent an animation.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n */\n\nfunction AnimationClip( name, duration, tracks ) {\n\n\tthis.name = name;\n\tthis.tracks = tracks;\n\tthis.duration = ( duration !== undefined ) ? duration : - 1;\n\n\tthis.uuid = _Math.generateUUID();\n\n\t// this means it should figure out its duration by scanning the tracks\n\tif ( this.duration < 0 ) {\n\n\t\tthis.resetDuration();\n\n\t}\n\n}\n\nfunction getTrackTypeForValueTypeName( typeName ) {\n\n\tswitch ( typeName.toLowerCase() ) {\n\n\t\tcase 'scalar':\n\t\tcase 'double':\n\t\tcase 'float':\n\t\tcase 'number':\n\t\tcase 'integer':\n\n\t\t\treturn NumberKeyframeTrack;\n\n\t\tcase 'vector':\n\t\tcase 'vector2':\n\t\tcase 'vector3':\n\t\tcase 'vector4':\n\n\t\t\treturn VectorKeyframeTrack;\n\n\t\tcase 'color':\n\n\t\t\treturn ColorKeyframeTrack;\n\n\t\tcase 'quaternion':\n\n\t\t\treturn QuaternionKeyframeTrack;\n\n\t\tcase 'bool':\n\t\tcase 'boolean':\n\n\t\t\treturn BooleanKeyframeTrack;\n\n\t\tcase 'string':\n\n\t\t\treturn StringKeyframeTrack;\n\n\t}\n\n\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\n\n}\n\nfunction parseKeyframeTrack( json ) {\n\n\tif ( json.type === undefined ) {\n\n\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\n\n\t}\n\n\tvar trackType = getTrackTypeForValueTypeName( json.type );\n\n\tif ( json.times === undefined ) {\n\n\t\tvar times = [], values = [];\n\n\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\tjson.times = times;\n\t\tjson.values = values;\n\n\t}\n\n\t// derived classes can define a static parse method\n\tif ( trackType.parse !== undefined ) {\n\n\t\treturn trackType.parse( json );\n\n\t} else {\n\n\t\t// by default, we assume a constructor compatible with the base\n\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\n\n\t}\n\n}\n\nObject.assign( AnimationClip, {\n\n\tparse: function ( json ) {\n\n\t\tvar tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\treturn new AnimationClip( json.name, json.duration, tracks );\n\n\t},\n\n\ttoJSON: function ( clip ) {\n\n\t\tvar tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tvar json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks,\n\t\t\t'uuid': clip.uuid\n\n\t\t};\n\n\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t},\n\n\tCreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\tvar tracks = [];\n\n\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tvar times = [];\n\t\t\tvar values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\ti,\n\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tvar order = AnimationUtils.getKeyframeOrder( times );\n\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\ttimes, values\n\t\t\t\t).scale( 1.0 / fps ) );\n\n\t\t}\n\n\t\treturn new AnimationClip( name, - 1, tracks );\n\n\t},\n\n\tfindByName: function ( objectOrClipArray, name ) {\n\n\t\tvar clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tvar o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\tCreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {\n\n\t\tvar animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\tvar parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tvar name = parts[ 1 ];\n\n\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar clips = [];\n\n\t\tfor ( var name in animationToMorphTargets ) {\n\n\t\t\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t},\n\n\t// parse the animation.hierarchy format\n\tparseAnimation: function ( animation, bones ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar values = [];\n\n\t\t\t\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tvar tracks = [];\n\n\t\tvar clipName = animation.name || 'default';\n\t\t// automatic length determination in AnimationClip.\n\t\tvar duration = animation.length || - 1;\n\t\tvar fps = animation.fps || 30;\n\n\t\tvar hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets\n\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tvar morphTargetNames = {};\n\n\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\n\n\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\n\t\t\t\t\tfor ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tvar animationKey = animationKeys[ k ];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar clip = new AnimationClip( clipName, duration, tracks );\n\n\t\treturn clip;\n\n\t}\n\n} );\n\nObject.assign( AnimationClip.prototype, {\n\n\tresetDuration: function () {\n\n\t\tvar tracks = this.tracks, duration = 0;\n\n\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tvar track = this.tracks[ i ];\n\n\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t\treturn this;\n\n\t},\n\n\ttrim: function () {\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tvalidate: function () {\n\n\t\tvar valid = true;\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tvalid = valid && this.tracks[ i ].validate();\n\n\t\t}\n\n\t\treturn valid;\n\n\t},\n\n\toptimize: function () {\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\tvar tracks = [];\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\ttracks.push( this.tracks[ i ].clone() );\n\n\t\t}\n\n\t\treturn new AnimationClip( this.name, this.duration, tracks );\n\n\t}\n\n} );\n\n\nexport { AnimationClip };\n"]},"metadata":{},"sourceType":"module"}