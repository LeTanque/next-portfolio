{"ast":null,"code":"import _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport { Vector3 } from '../math/Vector3.js';\nimport { Box3 } from '../math/Box3.js';\nimport { EventDispatcher } from './EventDispatcher.js';\nimport { BufferAttribute, Float32BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from './BufferAttribute.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { DirectGeometry } from './DirectGeometry.js';\nimport { Object3D } from './Object3D.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { _Math } from '../math/Math.js';\nimport { arrayMax } from '../utils.js';\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\n\nvar _m1 = new Matrix4();\n\nvar _obj = new Object3D();\n\nvar _offset = new Vector3();\n\nvar _box = new Box3();\n\nvar _boxMorphTargets = new Box3();\n\nvar _vector = new Vector3();\n\nfunction BufferGeometry() {\n  _Object$defineProperty(this, 'id', {\n    value: _bufferGeometryId += 2\n  });\n\n  this.uuid = _Math.generateUUID();\n  this.name = '';\n  this.type = 'BufferGeometry';\n  this.index = null;\n  this.attributes = {};\n  this.morphAttributes = {};\n  this.morphTargetsRelative = false;\n  this.groups = [];\n  this.boundingBox = null;\n  this.boundingSphere = null;\n  this.drawRange = {\n    start: 0,\n    count: Infinity\n  };\n  this.userData = {};\n}\n\nBufferGeometry.prototype = _Object$assign(_Object$create(EventDispatcher.prototype), {\n  constructor: BufferGeometry,\n  isBufferGeometry: true,\n  getIndex: function getIndex() {\n    return this.index;\n  },\n  setIndex: function setIndex(index) {\n    if (_Array$isArray(index)) {\n      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n    } else {\n      this.index = index;\n    }\n  },\n  getAttribute: function getAttribute(name) {\n    return this.attributes[name];\n  },\n  setAttribute: function setAttribute(name, attribute) {\n    this.attributes[name] = attribute;\n    return this;\n  },\n  deleteAttribute: function deleteAttribute(name) {\n    delete this.attributes[name];\n    return this;\n  },\n  addGroup: function addGroup(start, count, materialIndex) {\n    this.groups.push({\n      start: start,\n      count: count,\n      materialIndex: materialIndex !== undefined ? materialIndex : 0\n    });\n  },\n  clearGroups: function clearGroups() {\n    this.groups = [];\n  },\n  setDrawRange: function setDrawRange(start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  },\n  applyMatrix: function applyMatrix(matrix) {\n    var position = this.attributes.position;\n\n    if (position !== undefined) {\n      position.applyMatrix4(matrix);\n      position.needsUpdate = true;\n    }\n\n    var normal = this.attributes.normal;\n\n    if (normal !== undefined) {\n      var normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      normal.applyNormalMatrix(normalMatrix);\n      normal.needsUpdate = true;\n    }\n\n    var tangent = this.attributes.tangent;\n\n    if (tangent !== undefined) {\n      tangent.transformDirection(matrix);\n      tangent.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  },\n  rotateX: function rotateX(angle) {\n    // rotate geometry around world x-axis\n    _m1.makeRotationX(angle);\n\n    this.applyMatrix(_m1);\n    return this;\n  },\n  rotateY: function rotateY(angle) {\n    // rotate geometry around world y-axis\n    _m1.makeRotationY(angle);\n\n    this.applyMatrix(_m1);\n    return this;\n  },\n  rotateZ: function rotateZ(angle) {\n    // rotate geometry around world z-axis\n    _m1.makeRotationZ(angle);\n\n    this.applyMatrix(_m1);\n    return this;\n  },\n  translate: function translate(x, y, z) {\n    // translate geometry\n    _m1.makeTranslation(x, y, z);\n\n    this.applyMatrix(_m1);\n    return this;\n  },\n  scale: function scale(x, y, z) {\n    // scale geometry\n    _m1.makeScale(x, y, z);\n\n    this.applyMatrix(_m1);\n    return this;\n  },\n  lookAt: function lookAt(vector) {\n    _obj.lookAt(vector);\n\n    _obj.updateMatrix();\n\n    this.applyMatrix(_obj.matrix);\n    return this;\n  },\n  center: function center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  },\n  setFromObject: function setFromObject(object) {\n    // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n    var geometry = object.geometry;\n\n    if (object.isPoints || object.isLine) {\n      var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n      var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n      this.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\n      this.setAttribute('color', colors.copyColorsArray(geometry.colors));\n\n      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n        var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n        this.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\n      }\n\n      if (geometry.boundingSphere !== null) {\n        this.boundingSphere = geometry.boundingSphere.clone();\n      }\n\n      if (geometry.boundingBox !== null) {\n        this.boundingBox = geometry.boundingBox.clone();\n      }\n    } else if (object.isMesh) {\n      if (geometry && geometry.isGeometry) {\n        this.fromGeometry(geometry);\n      }\n    }\n\n    return this;\n  },\n  setFromPoints: function setFromPoints(points) {\n    var position = [];\n\n    for (var i = 0, l = points.length; i < l; i++) {\n      var point = points[i];\n      position.push(point.x, point.y, point.z || 0);\n    }\n\n    this.setAttribute('position', new Float32BufferAttribute(position, 3));\n    return this;\n  },\n  updateFromObject: function updateFromObject(object) {\n    var geometry = object.geometry;\n\n    if (object.isMesh) {\n      var direct = geometry.__directGeometry;\n\n      if (geometry.elementsNeedUpdate === true) {\n        direct = undefined;\n        geometry.elementsNeedUpdate = false;\n      }\n\n      if (direct === undefined) {\n        return this.fromGeometry(geometry);\n      }\n\n      direct.verticesNeedUpdate = geometry.verticesNeedUpdate;\n      direct.normalsNeedUpdate = geometry.normalsNeedUpdate;\n      direct.colorsNeedUpdate = geometry.colorsNeedUpdate;\n      direct.uvsNeedUpdate = geometry.uvsNeedUpdate;\n      direct.groupsNeedUpdate = geometry.groupsNeedUpdate;\n      geometry.verticesNeedUpdate = false;\n      geometry.normalsNeedUpdate = false;\n      geometry.colorsNeedUpdate = false;\n      geometry.uvsNeedUpdate = false;\n      geometry.groupsNeedUpdate = false;\n      geometry = direct;\n    }\n\n    var attribute;\n\n    if (geometry.verticesNeedUpdate === true) {\n      attribute = this.attributes.position;\n\n      if (attribute !== undefined) {\n        attribute.copyVector3sArray(geometry.vertices);\n        attribute.needsUpdate = true;\n      }\n\n      geometry.verticesNeedUpdate = false;\n    }\n\n    if (geometry.normalsNeedUpdate === true) {\n      attribute = this.attributes.normal;\n\n      if (attribute !== undefined) {\n        attribute.copyVector3sArray(geometry.normals);\n        attribute.needsUpdate = true;\n      }\n\n      geometry.normalsNeedUpdate = false;\n    }\n\n    if (geometry.colorsNeedUpdate === true) {\n      attribute = this.attributes.color;\n\n      if (attribute !== undefined) {\n        attribute.copyColorsArray(geometry.colors);\n        attribute.needsUpdate = true;\n      }\n\n      geometry.colorsNeedUpdate = false;\n    }\n\n    if (geometry.uvsNeedUpdate) {\n      attribute = this.attributes.uv;\n\n      if (attribute !== undefined) {\n        attribute.copyVector2sArray(geometry.uvs);\n        attribute.needsUpdate = true;\n      }\n\n      geometry.uvsNeedUpdate = false;\n    }\n\n    if (geometry.lineDistancesNeedUpdate) {\n      attribute = this.attributes.lineDistance;\n\n      if (attribute !== undefined) {\n        attribute.copyArray(geometry.lineDistances);\n        attribute.needsUpdate = true;\n      }\n\n      geometry.lineDistancesNeedUpdate = false;\n    }\n\n    if (geometry.groupsNeedUpdate) {\n      geometry.computeGroups(object.geometry);\n      this.groups = geometry.groups;\n      geometry.groupsNeedUpdate = false;\n    }\n\n    return this;\n  },\n  fromGeometry: function fromGeometry(geometry) {\n    geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);\n    return this.fromDirectGeometry(geometry.__directGeometry);\n  },\n  fromDirectGeometry: function fromDirectGeometry(geometry) {\n    var positions = new Float32Array(geometry.vertices.length * 3);\n    this.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n\n    if (geometry.normals.length > 0) {\n      var normals = new Float32Array(geometry.normals.length * 3);\n      this.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n    }\n\n    if (geometry.colors.length > 0) {\n      var colors = new Float32Array(geometry.colors.length * 3);\n      this.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n    }\n\n    if (geometry.uvs.length > 0) {\n      var uvs = new Float32Array(geometry.uvs.length * 2);\n      this.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n    }\n\n    if (geometry.uvs2.length > 0) {\n      var uvs2 = new Float32Array(geometry.uvs2.length * 2);\n      this.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n    } // groups\n\n\n    this.groups = geometry.groups; // morphs\n\n    for (var name in geometry.morphTargets) {\n      var array = [];\n      var morphTargets = geometry.morphTargets[name];\n\n      for (var i = 0, l = morphTargets.length; i < l; i++) {\n        var morphTarget = morphTargets[i];\n        var attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n        attribute.name = morphTarget.name;\n        array.push(attribute.copyVector3sArray(morphTarget.data));\n      }\n\n      this.morphAttributes[name] = array;\n    } // skinning\n\n\n    if (geometry.skinIndices.length > 0) {\n      var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n      this.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\n    }\n\n    if (geometry.skinWeights.length > 0) {\n      var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n      this.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\n    } //\n\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return this;\n  },\n  computeBoundingBox: function computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    var position = this.attributes.position;\n    var morphAttributesPosition = this.morphAttributes.position;\n\n    if (position !== undefined) {\n      this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          var morphAttribute = morphAttributesPosition[i];\n\n          _box.setFromBufferAttribute(morphAttribute);\n\n          if (this.morphTargetsRelative) {\n            _vector.addVectors(this.boundingBox.min, _box.min);\n\n            this.boundingBox.expandByPoint(_vector);\n\n            _vector.addVectors(this.boundingBox.max, _box.max);\n\n            this.boundingBox.expandByPoint(_vector);\n          } else {\n            this.boundingBox.expandByPoint(_box.min);\n            this.boundingBox.expandByPoint(_box.max);\n          }\n        }\n      }\n    } else {\n      this.boundingBox.makeEmpty();\n    }\n\n    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n      console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n    }\n  },\n  computeBoundingSphere: function computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    var position = this.attributes.position;\n    var morphAttributesPosition = this.morphAttributes.position;\n\n    if (position) {\n      // first, find the center of the bounding sphere\n      var center = this.boundingSphere.center;\n\n      _box.setFromBufferAttribute(position); // process morph attributes if present\n\n\n      if (morphAttributesPosition) {\n        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          var morphAttribute = morphAttributesPosition[i];\n\n          _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n\n          if (this.morphTargetsRelative) {\n            _vector.addVectors(_box.min, _boxMorphTargets.min);\n\n            _box.expandByPoint(_vector);\n\n            _vector.addVectors(_box.max, _boxMorphTargets.max);\n\n            _box.expandByPoint(_vector);\n          } else {\n            _box.expandByPoint(_boxMorphTargets.min);\n\n            _box.expandByPoint(_boxMorphTargets.max);\n          }\n        }\n      }\n\n      _box.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the\n      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\n      var maxRadiusSq = 0;\n\n      for (var i = 0, il = position.count; i < il; i++) {\n        _vector.fromBufferAttribute(position, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      } // process morph attributes if present\n\n\n      if (morphAttributesPosition) {\n        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          var morphAttribute = morphAttributesPosition[i];\n          var morphTargetsRelative = this.morphTargetsRelative;\n\n          for (var j = 0, jl = morphAttribute.count; j < jl; j++) {\n            _vector.fromBufferAttribute(morphAttribute, j);\n\n            if (morphTargetsRelative) {\n              _offset.fromBufferAttribute(position, j);\n\n              _vector.add(_offset);\n            }\n\n            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n          }\n        }\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n      }\n    }\n  },\n  computeFaceNormals: function computeFaceNormals() {// backwards compatibility\n  },\n  computeVertexNormals: function computeVertexNormals() {\n    var index = this.index;\n    var attributes = this.attributes;\n\n    if (attributes.position) {\n      var positions = attributes.position.array;\n\n      if (attributes.normal === undefined) {\n        this.setAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));\n      } else {\n        // reset existing normals to zero\n        var array = attributes.normal.array;\n\n        for (var i = 0, il = array.length; i < il; i++) {\n          array[i] = 0;\n        }\n      }\n\n      var normals = attributes.normal.array;\n      var vA, vB, vC;\n      var pA = new Vector3(),\n          pB = new Vector3(),\n          pC = new Vector3();\n      var cb = new Vector3(),\n          ab = new Vector3(); // indexed elements\n\n      if (index) {\n        var indices = index.array;\n\n        for (var i = 0, il = index.count; i < il; i += 3) {\n          vA = indices[i + 0] * 3;\n          vB = indices[i + 1] * 3;\n          vC = indices[i + 2] * 3;\n          pA.fromArray(positions, vA);\n          pB.fromArray(positions, vB);\n          pC.fromArray(positions, vC);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          normals[vA] += cb.x;\n          normals[vA + 1] += cb.y;\n          normals[vA + 2] += cb.z;\n          normals[vB] += cb.x;\n          normals[vB + 1] += cb.y;\n          normals[vB + 2] += cb.z;\n          normals[vC] += cb.x;\n          normals[vC + 1] += cb.y;\n          normals[vC + 2] += cb.z;\n        }\n      } else {\n        // non-indexed elements (unconnected triangle soup)\n        for (var i = 0, il = positions.length; i < il; i += 9) {\n          pA.fromArray(positions, i);\n          pB.fromArray(positions, i + 3);\n          pC.fromArray(positions, i + 6);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          normals[i] = cb.x;\n          normals[i + 1] = cb.y;\n          normals[i + 2] = cb.z;\n          normals[i + 3] = cb.x;\n          normals[i + 4] = cb.y;\n          normals[i + 5] = cb.z;\n          normals[i + 6] = cb.x;\n          normals[i + 7] = cb.y;\n          normals[i + 8] = cb.z;\n        }\n      }\n\n      this.normalizeNormals();\n      attributes.normal.needsUpdate = true;\n    }\n  },\n  merge: function merge(geometry, offset) {\n    if (!(geometry && geometry.isBufferGeometry)) {\n      console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);\n      return;\n    }\n\n    if (offset === undefined) {\n      offset = 0;\n      console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');\n    }\n\n    var attributes = this.attributes;\n\n    for (var key in attributes) {\n      if (geometry.attributes[key] === undefined) continue;\n      var attribute1 = attributes[key];\n      var attributeArray1 = attribute1.array;\n      var attribute2 = geometry.attributes[key];\n      var attributeArray2 = attribute2.array;\n      var attributeOffset = attribute2.itemSize * offset;\n      var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);\n\n      for (var i = 0, j = attributeOffset; i < length; i++, j++) {\n        attributeArray1[j] = attributeArray2[i];\n      }\n    }\n\n    return this;\n  },\n  normalizeNormals: function normalizeNormals() {\n    var normals = this.attributes.normal;\n\n    for (var i = 0, il = normals.count; i < il; i++) {\n      _vector.x = normals.getX(i);\n      _vector.y = normals.getY(i);\n      _vector.z = normals.getZ(i);\n\n      _vector.normalize();\n\n      normals.setXYZ(i, _vector.x, _vector.y, _vector.z);\n    }\n  },\n  toNonIndexed: function toNonIndexed() {\n    function convertBufferAttribute(attribute, indices) {\n      var array = attribute.array;\n      var itemSize = attribute.itemSize;\n      var array2 = new array.constructor(indices.length * itemSize);\n      var index = 0,\n          index2 = 0;\n\n      for (var i = 0, l = indices.length; i < l; i++) {\n        index = indices[i] * itemSize;\n\n        for (var j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n\n      return new BufferAttribute(array2, itemSize);\n    } //\n\n\n    if (this.index === null) {\n      console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');\n      return this;\n    }\n\n    var geometry2 = new BufferGeometry();\n    var indices = this.index.array;\n    var attributes = this.attributes; // attributes\n\n    for (var name in attributes) {\n      var attribute = attributes[name];\n      var newAttribute = convertBufferAttribute(attribute, indices);\n      geometry2.setAttribute(name, newAttribute);\n    } // morph attributes\n\n\n    var morphAttributes = this.morphAttributes;\n\n    for (name in morphAttributes) {\n      var morphArray = [];\n      var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (var i = 0, il = morphAttribute.length; i < il; i++) {\n        var attribute = morphAttribute[i];\n        var newAttribute = convertBufferAttribute(attribute, indices);\n        morphArray.push(newAttribute);\n      }\n\n      geometry2.morphAttributes[name] = morphArray;\n    }\n\n    geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups\n\n    var groups = this.groups;\n\n    for (var i = 0, l = groups.length; i < l; i++) {\n      var group = groups[i];\n      geometry2.addGroup(group.start, group.count, group.materialIndex);\n    }\n\n    return geometry2;\n  },\n  toJSON: function toJSON() {\n    var data = {\n      metadata: {\n        version: 4.5,\n        type: 'BufferGeometry',\n        generator: 'BufferGeometry.toJSON'\n      }\n    }; // standard BufferGeometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n    if (_Object$keys(this.userData).length > 0) data.userData = this.userData;\n\n    if (this.parameters !== undefined) {\n      var parameters = this.parameters;\n\n      for (var key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n\n      return data;\n    }\n\n    data.data = {\n      attributes: {}\n    };\n    var index = this.index;\n\n    if (index !== null) {\n      data.data.index = {\n        type: index.array.constructor.name,\n        array: Array.prototype.slice.call(index.array)\n      };\n    }\n\n    var attributes = this.attributes;\n\n    for (var key in attributes) {\n      var attribute = attributes[key];\n      var attributeData = attribute.toJSON();\n      if (attribute.name !== '') attributeData.name = attribute.name;\n      data.data.attributes[key] = attributeData;\n    }\n\n    var morphAttributes = {};\n    var hasMorphAttributes = false;\n\n    for (var key in this.morphAttributes) {\n      var attributeArray = this.morphAttributes[key];\n      var array = [];\n\n      for (var i = 0, il = attributeArray.length; i < il; i++) {\n        var attribute = attributeArray[i];\n        var attributeData = attribute.toJSON();\n        if (attribute.name !== '') attributeData.name = attribute.name;\n        array.push(attributeData);\n      }\n\n      if (array.length > 0) {\n        morphAttributes[key] = array;\n        hasMorphAttributes = true;\n      }\n    }\n\n    if (hasMorphAttributes) {\n      data.data.morphAttributes = morphAttributes;\n      data.data.morphTargetsRelative = this.morphTargetsRelative;\n    }\n\n    var groups = this.groups;\n\n    if (groups.length > 0) {\n      data.data.groups = JSON.parse(_JSON$stringify(groups));\n    }\n\n    var boundingSphere = this.boundingSphere;\n\n    if (boundingSphere !== null) {\n      data.data.boundingSphere = {\n        center: boundingSphere.center.toArray(),\n        radius: boundingSphere.radius\n      };\n    }\n\n    return data;\n  },\n  clone: function clone() {\n    /*\n     // Handle primitives\n    \t var parameters = this.parameters;\n    \t if ( parameters !== undefined ) {\n    \t var values = [];\n    \t for ( var key in parameters ) {\n    \t values.push( parameters[ key ] );\n    \t }\n    \t var geometry = Object.create( this.constructor.prototype );\n     this.constructor.apply( geometry, values );\n     return geometry;\n    \t }\n    \t return new this.constructor().copy( this );\n     */\n    return new BufferGeometry().copy(this);\n  },\n  copy: function copy(source) {\n    var name, i, l; // reset\n\n    this.index = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // name\n\n    this.name = source.name; // index\n\n    var index = source.index;\n\n    if (index !== null) {\n      this.setIndex(index.clone());\n    } // attributes\n\n\n    var attributes = source.attributes;\n\n    for (name in attributes) {\n      var attribute = attributes[name];\n      this.setAttribute(name, attribute.clone());\n    } // morph attributes\n\n\n    var morphAttributes = source.morphAttributes;\n\n    for (name in morphAttributes) {\n      var array = [];\n      var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (i = 0, l = morphAttribute.length; i < l; i++) {\n        array.push(morphAttribute[i].clone());\n      }\n\n      this.morphAttributes[name] = array;\n    }\n\n    this.morphTargetsRelative = source.morphTargetsRelative; // groups\n\n    var groups = source.groups;\n\n    for (i = 0, l = groups.length; i < l; i++) {\n      var group = groups[i];\n      this.addGroup(group.start, group.count, group.materialIndex);\n    } // bounding box\n\n\n    var boundingBox = source.boundingBox;\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    } // bounding sphere\n\n\n    var boundingSphere = source.boundingSphere;\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    } // draw range\n\n\n    this.drawRange.start = source.drawRange.start;\n    this.drawRange.count = source.drawRange.count; // user data\n\n    this.userData = source.userData;\n    return this;\n  },\n  dispose: function dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n});\nexport { BufferGeometry };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/core/BufferGeometry.js"],"names":["Vector3","Box3","EventDispatcher","BufferAttribute","Float32BufferAttribute","Uint16BufferAttribute","Uint32BufferAttribute","Sphere","DirectGeometry","Object3D","Matrix4","Matrix3","_Math","arrayMax","_bufferGeometryId","_m1","_obj","_offset","_box","_boxMorphTargets","_vector","BufferGeometry","value","uuid","generateUUID","name","type","index","attributes","morphAttributes","morphTargetsRelative","groups","boundingBox","boundingSphere","drawRange","start","count","Infinity","userData","prototype","constructor","isBufferGeometry","getIndex","setIndex","getAttribute","setAttribute","attribute","deleteAttribute","addGroup","materialIndex","push","undefined","clearGroups","setDrawRange","applyMatrix","matrix","position","applyMatrix4","needsUpdate","normal","normalMatrix","getNormalMatrix","applyNormalMatrix","tangent","transformDirection","computeBoundingBox","computeBoundingSphere","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","center","getCenter","negate","setFromObject","object","geometry","isPoints","isLine","positions","vertices","length","colors","copyVector3sArray","copyColorsArray","lineDistances","copyArray","clone","isMesh","isGeometry","fromGeometry","setFromPoints","points","i","l","point","updateFromObject","direct","__directGeometry","elementsNeedUpdate","verticesNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","uvsNeedUpdate","groupsNeedUpdate","normals","color","uv","copyVector2sArray","uvs","lineDistancesNeedUpdate","lineDistance","computeGroups","fromDirectGeometry","Float32Array","uvs2","morphTargets","array","morphTarget","data","skinIndices","copyVector4sArray","skinWeights","morphAttributesPosition","setFromBufferAttribute","il","morphAttribute","addVectors","min","expandByPoint","max","makeEmpty","isNaN","console","error","maxRadiusSq","fromBufferAttribute","Math","distanceToSquared","j","jl","add","radius","sqrt","computeFaceNormals","computeVertexNormals","vA","vB","vC","pA","pB","pC","cb","ab","indices","fromArray","subVectors","cross","normalizeNormals","merge","offset","warn","key","attribute1","attributeArray1","attribute2","attributeArray2","attributeOffset","itemSize","getX","getY","getZ","normalize","setXYZ","toNonIndexed","convertBufferAttribute","array2","index2","geometry2","newAttribute","morphArray","group","toJSON","metadata","version","generator","parameters","Array","slice","call","attributeData","hasMorphAttributes","attributeArray","JSON","parse","toArray","copy","source","dispose","dispatchEvent"],"mappings":"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","sourcesContent":["import { Vector3 } from '../math/Vector3.js';\nimport { Box3 } from '../math/Box3.js';\nimport { EventDispatcher } from './EventDispatcher.js';\nimport { BufferAttribute, Float32BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from './BufferAttribute.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { DirectGeometry } from './DirectGeometry.js';\nimport { Object3D } from './Object3D.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { _Math } from '../math/Math.js';\nimport { arrayMax } from '../utils.js';\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\n\nvar _m1 = new Matrix4();\nvar _obj = new Object3D();\nvar _offset = new Vector3();\nvar _box = new Box3();\nvar _boxMorphTargets = new Box3();\nvar _vector = new Vector3();\n\nfunction BufferGeometry() {\n\n\tObject.defineProperty( this, 'id', { value: _bufferGeometryId += 2 } );\n\n\tthis.uuid = _Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'BufferGeometry';\n\n\tthis.index = null;\n\tthis.attributes = {};\n\n\tthis.morphAttributes = {};\n\tthis.morphTargetsRelative = false;\n\n\tthis.groups = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.drawRange = { start: 0, count: Infinity };\n\n\tthis.userData = {};\n\n}\n\nBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: BufferGeometry,\n\n\tisBufferGeometry: true,\n\n\tgetIndex: function () {\n\n\t\treturn this.index;\n\n\t},\n\n\tsetIndex: function ( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t},\n\n\tgetAttribute: function ( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t},\n\n\tsetAttribute: function ( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t},\n\n\tdeleteAttribute: function ( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t},\n\n\taddGroup: function ( start, count, materialIndex ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\n\t\t} );\n\n\t},\n\n\tclearGroups: function () {\n\n\t\tthis.groups = [];\n\n\t},\n\n\tsetDrawRange: function ( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tvar normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tvar tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function ( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateY: function ( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateZ: function ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function ( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix( _obj.matrix );\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromObject: function ( object ) {\n\n\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object.isPoints || object.isLine ) {\n\n\t\t\tvar positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\n\t\t\tvar colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\n\n\t\t\tthis.setAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\tthis.setAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\t\tvar lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\n\n\t\t\t\tthis.setAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t} else if ( object.isMesh ) {\n\n\t\t\tif ( geometry && geometry.isGeometry ) {\n\n\t\t\t\tthis.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tvar position = [];\n\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tvar point = points[ i ];\n\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t}\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\treturn this;\n\n\t},\n\n\tupdateFromObject: function ( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object.isMesh ) {\n\n\t\t\tvar direct = geometry.__directGeometry;\n\n\t\t\tif ( geometry.elementsNeedUpdate === true ) {\n\n\t\t\t\tdirect = undefined;\n\t\t\t\tgeometry.elementsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( direct === undefined ) {\n\n\t\t\t\treturn this.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\tgeometry = direct;\n\n\t\t}\n\n\t\tvar attribute;\n\n\t\tif ( geometry.verticesNeedUpdate === true ) {\n\n\t\t\tattribute = this.attributes.position;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.normalsNeedUpdate === true ) {\n\n\t\t\tattribute = this.attributes.normal;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.normalsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.colorsNeedUpdate === true ) {\n\n\t\t\tattribute = this.attributes.color;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.uvsNeedUpdate ) {\n\n\t\t\tattribute = this.attributes.uv;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.uvsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\n\t\t\tattribute = this.attributes.lineDistance;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.groupsNeedUpdate ) {\n\n\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\tthis.groups = geometry.groups;\n\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\n\n\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\n\t},\n\n\tfromDirectGeometry: function ( geometry ) {\n\n\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\tthis.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\tthis.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t}\n\n\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\tthis.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\tthis.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\tthis.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t}\n\n\t\t// groups\n\n\t\tthis.groups = geometry.groups;\n\n\t\t// morphs\n\n\t\tfor ( var name in geometry.morphTargets ) {\n\n\t\t\tvar array = [];\n\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\n\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ i ];\n\n\t\t\t\tvar attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );\n\t\t\t\tattribute.name = morphTarget.name;\n\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget.data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\t// skinning\n\n\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\tvar skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\n\t\t\tthis.setAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t}\n\n\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\tvar skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\n\t\t\tthis.setAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tvar position = this.attributes.position;\n\t\tvar morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tvar position = this.attributes.position;\n\t\tvar morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tvar maxRadiusSq = 0;\n\n\t\t\tfor ( var i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tvar morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( var j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\t// backwards compatibility\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tvar index = this.index;\n\t\tvar attributes = this.attributes;\n\n\t\tif ( attributes.position ) {\n\n\t\t\tvar positions = attributes.position.array;\n\n\t\t\tif ( attributes.normal === undefined ) {\n\n\t\t\t\tthis.setAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tvar array = attributes.normal.array;\n\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar normals = attributes.normal.array;\n\n\t\t\tvar vA, vB, vC;\n\t\t\tvar pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tvar indices = index.array;\n\n\t\t\t\tfor ( var i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\n\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\tpC.fromArray( positions, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\n\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\n\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tattributes.normal.needsUpdate = true;\n\n\t\t}\n\n\t},\n\n\tmerge: function ( geometry, offset ) {\n\n\t\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( offset === undefined ) {\n\n\t\t\toffset = 0;\n\n\t\t\tconsole.warn(\n\t\t\t\t'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '\n\t\t\t\t+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'\n\t\t\t);\n\n\t\t}\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\tvar attribute1 = attributes[ key ];\n\t\t\tvar attributeArray1 = attribute1.array;\n\n\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\tvar attributeArray2 = attribute2.array;\n\n\t\t\tvar attributeOffset = attribute2.itemSize * offset;\n\t\t\tvar length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );\n\n\t\t\tfor ( var i = 0, j = attributeOffset; i < length; i ++, j ++ ) {\n\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnormalizeNormals: function () {\n\n\t\tvar normals = this.attributes.normal;\n\n\t\tfor ( var i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector.x = normals.getX( i );\n\t\t\t_vector.y = normals.getY( i );\n\t\t\t_vector.z = normals.getZ( i );\n\n\t\t\t_vector.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t},\n\n\ttoNonIndexed: function () {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tvar array = attribute.array;\n\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tvar index = 0, index2 = 0;\n\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar geometry2 = new BufferGeometry();\n\n\t\tvar indices = this.index.array;\n\t\tvar attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\n\t\t\tvar newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tvar morphAttributes = this.morphAttributes;\n\n\t\tfor ( name in morphAttributes ) {\n\n\t\t\tvar morphArray = [];\n\t\t\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tvar attribute = morphAttribute[ i ];\n\n\t\t\t\tvar newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tvar groups = this.groups;\n\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tdata.data = { attributes: {} };\n\n\t\tvar index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tvar attribute = attributes[ key ];\n\n\t\t\tvar attributeData = attribute.toJSON();\n\n\t\t\tif ( attribute.name !== '' ) attributeData.name = attribute.name;\n\n\t\t\tdata.data.attributes[ key ] = attributeData;\n\n\t\t}\n\n\t\tvar morphAttributes = {};\n\t\tvar hasMorphAttributes = false;\n\n\t\tfor ( var key in this.morphAttributes ) {\n\n\t\t\tvar attributeArray = this.morphAttributes[ key ];\n\n\t\t\tvar array = [];\n\n\t\t\tfor ( var i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tvar attribute = attributeArray[ i ];\n\n\t\t\t\tvar attributeData = attribute.toJSON();\n\n\t\t\t\tif ( attribute.name !== '' ) attributeData.name = attribute.name;\n\n\t\t\t\tarray.push( attributeData );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tvar groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tvar boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t // Handle primitives\n\n\t\t var parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t var values = [];\n\n\t\t for ( var key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t var geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n\t\treturn new BufferGeometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tvar name, i, l;\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tvar index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tvar attributes = source.attributes;\n\n\t\tfor ( name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone() );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tvar morphAttributes = source.morphAttributes;\n\n\t\tfor ( name in morphAttributes ) {\n\n\t\t\tvar array = [];\n\t\t\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tvar groups = source.groups;\n\n\t\tfor ( i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tvar boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tvar boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n\nexport { BufferGeometry };\n"]},"metadata":{},"sourceType":"module"}