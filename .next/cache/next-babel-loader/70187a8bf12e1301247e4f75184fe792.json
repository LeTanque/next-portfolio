{"ast":null,"code":"import _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport { PropertyBinding } from './PropertyBinding.js';\nimport { _Math } from '../math/Math.js';\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n *  - Add objects you would otherwise pass as 'root' to the\n *    constructor or the .clipAction method of AnimationMixer.\n *\n *  - Instead pass this object as 'root'.\n *\n *  - You can also add and remove objects later when the mixer\n *    is running.\n *\n * Note:\n *\n *    Objects of this class appear as one object to the mixer,\n *    so cache control of the individual objects must be done\n *    on the group.\n *\n * Limitation:\n *\n *  - The animated properties must be compatible among the\n *    all objects in the group.\n *\n *  - A single property can either be controlled through a\n *    target group or directly, but not both.\n *\n * @author tschw\n */\n\nfunction AnimationObjectGroup() {\n  this.uuid = _Math.generateUUID(); // cached objects followed by the active ones\n\n  this._objects = Array.prototype.slice.call(arguments);\n  this.nCachedObjects_ = 0; // threshold\n  // note: read by PropertyBinding.Composite\n\n  var indices = {};\n  this._indicesByUUID = indices; // for bookkeeping\n\n  for (var i = 0, n = arguments.length; i !== n; ++i) {\n    indices[arguments[i].uuid] = i;\n  }\n\n  this._paths = []; // inside: string\n\n  this._parsedPaths = []; // inside: { we don't care, here }\n\n  this._bindings = []; // inside: Array< PropertyBinding >\n\n  this._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n  var scope = this;\n  this.stats = {\n    objects: {\n      get total() {\n        return scope._objects.length;\n      },\n\n      get inUse() {\n        return this.total - scope.nCachedObjects_;\n      }\n\n    },\n\n    get bindingsPerObject() {\n      return scope._bindings.length;\n    }\n\n  };\n}\n\n_Object$assign(AnimationObjectGroup.prototype, {\n  isAnimationObjectGroup: true,\n  add: function add() {\n    var objects = this._objects,\n        nObjects = objects.length,\n        nCachedObjects = this.nCachedObjects_,\n        indicesByUUID = this._indicesByUUID,\n        paths = this._paths,\n        parsedPaths = this._parsedPaths,\n        bindings = this._bindings,\n        nBindings = bindings.length,\n        knownObject = undefined;\n\n    for (var i = 0, n = arguments.length; i !== n; ++i) {\n      var object = arguments[i],\n          uuid = object.uuid,\n          index = indicesByUUID[uuid];\n\n      if (index === undefined) {\n        // unknown object -> add it to the ACTIVE region\n        index = nObjects++;\n        indicesByUUID[uuid] = index;\n        objects.push(object); // accounting is done, now do the same for all bindings\n\n        for (var j = 0, m = nBindings; j !== m; ++j) {\n          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));\n        }\n      } else if (index < nCachedObjects) {\n        knownObject = objects[index]; // move existing object to the ACTIVE region\n\n        var firstActiveIndex = --nCachedObjects,\n            lastCachedObject = objects[firstActiveIndex];\n        indicesByUUID[lastCachedObject.uuid] = index;\n        objects[index] = lastCachedObject;\n        indicesByUUID[uuid] = firstActiveIndex;\n        objects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings\n\n        for (var j = 0, m = nBindings; j !== m; ++j) {\n          var bindingsForPath = bindings[j],\n              lastCached = bindingsForPath[firstActiveIndex],\n              binding = bindingsForPath[index];\n          bindingsForPath[index] = lastCached;\n\n          if (binding === undefined) {\n            // since we do not bother to create new bindings\n            // for objects that are cached, the binding may\n            // or may not exist\n            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);\n          }\n\n          bindingsForPath[firstActiveIndex] = binding;\n        }\n      } else if (objects[index] !== knownObject) {\n        console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');\n      } // else the object is already where we want it to be\n\n    } // for arguments\n\n\n    this.nCachedObjects_ = nCachedObjects;\n  },\n  remove: function remove() {\n    var objects = this._objects,\n        nCachedObjects = this.nCachedObjects_,\n        indicesByUUID = this._indicesByUUID,\n        bindings = this._bindings,\n        nBindings = bindings.length;\n\n    for (var i = 0, n = arguments.length; i !== n; ++i) {\n      var object = arguments[i],\n          uuid = object.uuid,\n          index = indicesByUUID[uuid];\n\n      if (index !== undefined && index >= nCachedObjects) {\n        // move existing object into the CACHED region\n        var lastCachedIndex = nCachedObjects++,\n            firstActiveObject = objects[lastCachedIndex];\n        indicesByUUID[firstActiveObject.uuid] = index;\n        objects[index] = firstActiveObject;\n        indicesByUUID[uuid] = lastCachedIndex;\n        objects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings\n\n        for (var j = 0, m = nBindings; j !== m; ++j) {\n          var bindingsForPath = bindings[j],\n              firstActive = bindingsForPath[lastCachedIndex],\n              binding = bindingsForPath[index];\n          bindingsForPath[index] = firstActive;\n          bindingsForPath[lastCachedIndex] = binding;\n        }\n      }\n    } // for arguments\n\n\n    this.nCachedObjects_ = nCachedObjects;\n  },\n  // remove & forget\n  uncache: function uncache() {\n    var objects = this._objects,\n        nObjects = objects.length,\n        nCachedObjects = this.nCachedObjects_,\n        indicesByUUID = this._indicesByUUID,\n        bindings = this._bindings,\n        nBindings = bindings.length;\n\n    for (var i = 0, n = arguments.length; i !== n; ++i) {\n      var object = arguments[i],\n          uuid = object.uuid,\n          index = indicesByUUID[uuid];\n\n      if (index !== undefined) {\n        delete indicesByUUID[uuid];\n\n        if (index < nCachedObjects) {\n          // object is cached, shrink the CACHED region\n          var firstActiveIndex = --nCachedObjects,\n              lastCachedObject = objects[firstActiveIndex],\n              lastIndex = --nObjects,\n              lastObject = objects[lastIndex]; // last cached object takes this object's place\n\n          indicesByUUID[lastCachedObject.uuid] = index;\n          objects[index] = lastCachedObject; // last object goes to the activated slot and pop\n\n          indicesByUUID[lastObject.uuid] = firstActiveIndex;\n          objects[firstActiveIndex] = lastObject;\n          objects.pop(); // accounting is done, now do the same for all bindings\n\n          for (var j = 0, m = nBindings; j !== m; ++j) {\n            var bindingsForPath = bindings[j],\n                lastCached = bindingsForPath[firstActiveIndex],\n                last = bindingsForPath[lastIndex];\n            bindingsForPath[index] = lastCached;\n            bindingsForPath[firstActiveIndex] = last;\n            bindingsForPath.pop();\n          }\n        } else {\n          // object is active, just swap with the last and pop\n          var lastIndex = --nObjects,\n              lastObject = objects[lastIndex];\n          indicesByUUID[lastObject.uuid] = index;\n          objects[index] = lastObject;\n          objects.pop(); // accounting is done, now do the same for all bindings\n\n          for (var j = 0, m = nBindings; j !== m; ++j) {\n            var bindingsForPath = bindings[j];\n            bindingsForPath[index] = bindingsForPath[lastIndex];\n            bindingsForPath.pop();\n          }\n        } // cached or active\n\n      } // if object is known\n\n    } // for arguments\n\n\n    this.nCachedObjects_ = nCachedObjects;\n  },\n  // Internal interface used by befriended PropertyBinding.Composite:\n  subscribe_: function subscribe_(path, parsedPath) {\n    // returns an array of bindings for the given path that is changed\n    // according to the contained objects in the group\n    var indicesByPath = this._bindingsIndicesByPath,\n        index = indicesByPath[path],\n        bindings = this._bindings;\n    if (index !== undefined) return bindings[index];\n    var paths = this._paths,\n        parsedPaths = this._parsedPaths,\n        objects = this._objects,\n        nObjects = objects.length,\n        nCachedObjects = this.nCachedObjects_,\n        bindingsForPath = new Array(nObjects);\n    index = bindings.length;\n    indicesByPath[path] = index;\n    paths.push(path);\n    parsedPaths.push(parsedPath);\n    bindings.push(bindingsForPath);\n\n    for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {\n      var object = objects[i];\n      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);\n    }\n\n    return bindingsForPath;\n  },\n  unsubscribe_: function unsubscribe_(path) {\n    // tells the group to forget about a property path and no longer\n    // update the array previously obtained with 'subscribe_'\n    var indicesByPath = this._bindingsIndicesByPath,\n        index = indicesByPath[path];\n\n    if (index !== undefined) {\n      var paths = this._paths,\n          parsedPaths = this._parsedPaths,\n          bindings = this._bindings,\n          lastBindingsIndex = bindings.length - 1,\n          lastBindings = bindings[lastBindingsIndex],\n          lastBindingsPath = path[lastBindingsIndex];\n      indicesByPath[lastBindingsPath] = index;\n      bindings[index] = lastBindings;\n      bindings.pop();\n      parsedPaths[index] = parsedPaths[lastBindingsIndex];\n      parsedPaths.pop();\n      paths[index] = paths[lastBindingsIndex];\n      paths.pop();\n    }\n  }\n});\n\nexport { AnimationObjectGroup };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/animation/AnimationObjectGroup.js"],"names":["PropertyBinding","_Math","AnimationObjectGroup","uuid","generateUUID","_objects","Array","prototype","slice","call","arguments","nCachedObjects_","indices","_indicesByUUID","i","n","length","_paths","_parsedPaths","_bindings","_bindingsIndicesByPath","scope","stats","objects","total","inUse","bindingsPerObject","isAnimationObjectGroup","add","nObjects","nCachedObjects","indicesByUUID","paths","parsedPaths","bindings","nBindings","knownObject","undefined","object","index","push","j","m","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","binding","console","error","remove","lastCachedIndex","firstActiveObject","firstActive","uncache","lastIndex","lastObject","pop","last","subscribe_","path","parsedPath","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","lastBindingsPath"],"mappings":"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","sourcesContent":["import { PropertyBinding } from './PropertyBinding.js';\nimport { _Math } from '../math/Math.js';\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n *  - Add objects you would otherwise pass as 'root' to the\n *    constructor or the .clipAction method of AnimationMixer.\n *\n *  - Instead pass this object as 'root'.\n *\n *  - You can also add and remove objects later when the mixer\n *    is running.\n *\n * Note:\n *\n *    Objects of this class appear as one object to the mixer,\n *    so cache control of the individual objects must be done\n *    on the group.\n *\n * Limitation:\n *\n *  - The animated properties must be compatible among the\n *    all objects in the group.\n *\n *  - A single property can either be controlled through a\n *    target group or directly, but not both.\n *\n * @author tschw\n */\n\nfunction AnimationObjectGroup() {\n\n\tthis.uuid = _Math.generateUUID();\n\n\t// cached objects followed by the active ones\n\tthis._objects = Array.prototype.slice.call( arguments );\n\n\tthis.nCachedObjects_ = 0; // threshold\n\t// note: read by PropertyBinding.Composite\n\n\tvar indices = {};\n\tthis._indicesByUUID = indices; // for bookkeeping\n\n\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t}\n\n\tthis._paths = []; // inside: string\n\tthis._parsedPaths = []; // inside: { we don't care, here }\n\tthis._bindings = []; // inside: Array< PropertyBinding >\n\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n\tvar scope = this;\n\n\tthis.stats = {\n\n\t\tobjects: {\n\t\t\tget total() {\n\n\t\t\t\treturn scope._objects.length;\n\n\t\t\t},\n\t\t\tget inUse() {\n\n\t\t\t\treturn this.total - scope.nCachedObjects_;\n\n\t\t\t}\n\t\t},\n\t\tget bindingsPerObject() {\n\n\t\t\treturn scope._bindings.length;\n\n\t\t}\n\n\t};\n\n}\n\nObject.assign( AnimationObjectGroup.prototype, {\n\n\tisAnimationObjectGroup: true,\n\n\tadd: function () {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length,\n\t\t\tknownObject = undefined;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tknownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject ) {\n\n\t\t\t\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\n\t\t\t\t\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\tremove: function () {\n\n\t\tvar objects = this._objects,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// remove & forget\n\tuncache: function () {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_: function ( path, parsedPath ) {\n\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ],\n\t\t\tbindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tvar paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\n\n\t\t\tvar object = objects[ i ];\n\t\t\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t},\n\n\tunsubscribe_: function ( path ) {\n\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tvar paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n} );\n\n\nexport { AnimationObjectGroup };\n"]},"metadata":{},"sourceType":"module"}