{"ast":null,"code":"import _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport { WrapAroundEnding, ZeroCurvatureEnding, ZeroSlopeEnding, LoopPingPong, LoopOnce, LoopRepeat } from '../constants.js';\n/**\n *\n * Action provided by AnimationMixer for scheduling clip playback on specific\n * objects.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n *\n */\n\nfunction AnimationAction(mixer, clip, localRoot) {\n  this._mixer = mixer;\n  this._clip = clip;\n  this._localRoot = localRoot || null;\n  var tracks = clip.tracks,\n      nTracks = tracks.length,\n      interpolants = new Array(nTracks);\n  var interpolantSettings = {\n    endingStart: ZeroCurvatureEnding,\n    endingEnd: ZeroCurvatureEnding\n  };\n\n  for (var i = 0; i !== nTracks; ++i) {\n    var interpolant = tracks[i].createInterpolant(null);\n    interpolants[i] = interpolant;\n    interpolant.settings = interpolantSettings;\n  }\n\n  this._interpolantSettings = interpolantSettings;\n  this._interpolants = interpolants; // bound by the mixer\n  // inside: PropertyMixer (managed by the mixer)\n\n  this._propertyBindings = new Array(nTracks);\n  this._cacheIndex = null; // for the memory manager\n\n  this._byClipCacheIndex = null; // for the memory manager\n\n  this._timeScaleInterpolant = null;\n  this._weightInterpolant = null;\n  this.loop = LoopRepeat;\n  this._loopCount = -1; // global mixer time when the action is to be started\n  // it's set back to 'null' upon start of the action\n\n  this._startTime = null; // scaled local time of the action\n  // gets clamped or wrapped to 0..clip.duration according to loop\n\n  this.time = 0;\n  this.timeScale = 1;\n  this._effectiveTimeScale = 1;\n  this.weight = 1;\n  this._effectiveWeight = 1;\n  this.repetitions = Infinity; // no. of repetitions when looping\n\n  this.paused = false; // true -> zero effective time scale\n\n  this.enabled = true; // false -> zero effective weight\n\n  this.clampWhenFinished = false; // keep feeding the last frame?\n\n  this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate\n\n  this.zeroSlopeAtEnd = true; // clips for start, loop and end\n}\n\n_Object$assign(AnimationAction.prototype, {\n  // State & Scheduling\n  play: function play() {\n    this._mixer._activateAction(this);\n\n    return this;\n  },\n  stop: function stop() {\n    this._mixer._deactivateAction(this);\n\n    return this.reset();\n  },\n  reset: function reset() {\n    this.paused = false;\n    this.enabled = true;\n    this.time = 0; // restart clip\n\n    this._loopCount = -1; // forget previous loops\n\n    this._startTime = null; // forget scheduling\n\n    return this.stopFading().stopWarping();\n  },\n  isRunning: function isRunning() {\n    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);\n  },\n  // return true when play has been called\n  isScheduled: function isScheduled() {\n    return this._mixer._isActiveAction(this);\n  },\n  startAt: function startAt(time) {\n    this._startTime = time;\n    return this;\n  },\n  setLoop: function setLoop(mode, repetitions) {\n    this.loop = mode;\n    this.repetitions = repetitions;\n    return this;\n  },\n  // Weight\n  // set the weight stopping any scheduled fading\n  // although .enabled = false yields an effective weight of zero, this\n  // method does *not* change .enabled, because it would be confusing\n  setEffectiveWeight: function setEffectiveWeight(weight) {\n    this.weight = weight; // note: same logic as when updated at runtime\n\n    this._effectiveWeight = this.enabled ? weight : 0;\n    return this.stopFading();\n  },\n  // return the weight considering fading and .enabled\n  getEffectiveWeight: function getEffectiveWeight() {\n    return this._effectiveWeight;\n  },\n  fadeIn: function fadeIn(duration) {\n    return this._scheduleFading(duration, 0, 1);\n  },\n  fadeOut: function fadeOut(duration) {\n    return this._scheduleFading(duration, 1, 0);\n  },\n  crossFadeFrom: function crossFadeFrom(fadeOutAction, duration, warp) {\n    fadeOutAction.fadeOut(duration);\n    this.fadeIn(duration);\n\n    if (warp) {\n      var fadeInDuration = this._clip.duration,\n          fadeOutDuration = fadeOutAction._clip.duration,\n          startEndRatio = fadeOutDuration / fadeInDuration,\n          endStartRatio = fadeInDuration / fadeOutDuration;\n      fadeOutAction.warp(1.0, startEndRatio, duration);\n      this.warp(endStartRatio, 1.0, duration);\n    }\n\n    return this;\n  },\n  crossFadeTo: function crossFadeTo(fadeInAction, duration, warp) {\n    return fadeInAction.crossFadeFrom(this, duration, warp);\n  },\n  stopFading: function stopFading() {\n    var weightInterpolant = this._weightInterpolant;\n\n    if (weightInterpolant !== null) {\n      this._weightInterpolant = null;\n\n      this._mixer._takeBackControlInterpolant(weightInterpolant);\n    }\n\n    return this;\n  },\n  // Time Scale Control\n  // set the time scale stopping any scheduled warping\n  // although .paused = true yields an effective time scale of zero, this\n  // method does *not* change .paused, because it would be confusing\n  setEffectiveTimeScale: function setEffectiveTimeScale(timeScale) {\n    this.timeScale = timeScale;\n    this._effectiveTimeScale = this.paused ? 0 : timeScale;\n    return this.stopWarping();\n  },\n  // return the time scale considering warping and .paused\n  getEffectiveTimeScale: function getEffectiveTimeScale() {\n    return this._effectiveTimeScale;\n  },\n  setDuration: function setDuration(duration) {\n    this.timeScale = this._clip.duration / duration;\n    return this.stopWarping();\n  },\n  syncWith: function syncWith(action) {\n    this.time = action.time;\n    this.timeScale = action.timeScale;\n    return this.stopWarping();\n  },\n  halt: function halt(duration) {\n    return this.warp(this._effectiveTimeScale, 0, duration);\n  },\n  warp: function warp(startTimeScale, endTimeScale, duration) {\n    var mixer = this._mixer,\n        now = mixer.time,\n        interpolant = this._timeScaleInterpolant,\n        timeScale = this.timeScale;\n\n    if (interpolant === null) {\n      interpolant = mixer._lendControlInterpolant();\n      this._timeScaleInterpolant = interpolant;\n    }\n\n    var times = interpolant.parameterPositions,\n        values = interpolant.sampleValues;\n    times[0] = now;\n    times[1] = now + duration;\n    values[0] = startTimeScale / timeScale;\n    values[1] = endTimeScale / timeScale;\n    return this;\n  },\n  stopWarping: function stopWarping() {\n    var timeScaleInterpolant = this._timeScaleInterpolant;\n\n    if (timeScaleInterpolant !== null) {\n      this._timeScaleInterpolant = null;\n\n      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);\n    }\n\n    return this;\n  },\n  // Object Accessors\n  getMixer: function getMixer() {\n    return this._mixer;\n  },\n  getClip: function getClip() {\n    return this._clip;\n  },\n  getRoot: function getRoot() {\n    return this._localRoot || this._mixer._root;\n  },\n  // Interna\n  _update: function _update(time, deltaTime, timeDirection, accuIndex) {\n    // called by the mixer\n    if (!this.enabled) {\n      // call ._updateWeight() to update ._effectiveWeight\n      this._updateWeight(time);\n\n      return;\n    }\n\n    var startTime = this._startTime;\n\n    if (startTime !== null) {\n      // check for scheduled start of action\n      var timeRunning = (time - startTime) * timeDirection;\n\n      if (timeRunning < 0 || timeDirection === 0) {\n        return; // yet to come / don't decide when delta = 0\n      } // start\n\n\n      this._startTime = null; // unschedule\n\n      deltaTime = timeDirection * timeRunning;\n    } // apply time scale and advance time\n\n\n    deltaTime *= this._updateTimeScale(time);\n\n    var clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in\n    // an effective weight of 0\n\n\n    var weight = this._updateWeight(time);\n\n    if (weight > 0) {\n      var interpolants = this._interpolants;\n      var propertyMixers = this._propertyBindings;\n\n      for (var j = 0, m = interpolants.length; j !== m; ++j) {\n        interpolants[j].evaluate(clipTime);\n        propertyMixers[j].accumulate(accuIndex, weight);\n      }\n    }\n  },\n  _updateWeight: function _updateWeight(time) {\n    var weight = 0;\n\n    if (this.enabled) {\n      weight = this.weight;\n      var interpolant = this._weightInterpolant;\n\n      if (interpolant !== null) {\n        var interpolantValue = interpolant.evaluate(time)[0];\n        weight *= interpolantValue;\n\n        if (time > interpolant.parameterPositions[1]) {\n          this.stopFading();\n\n          if (interpolantValue === 0) {\n            // faded out, disable\n            this.enabled = false;\n          }\n        }\n      }\n    }\n\n    this._effectiveWeight = weight;\n    return weight;\n  },\n  _updateTimeScale: function _updateTimeScale(time) {\n    var timeScale = 0;\n\n    if (!this.paused) {\n      timeScale = this.timeScale;\n      var interpolant = this._timeScaleInterpolant;\n\n      if (interpolant !== null) {\n        var interpolantValue = interpolant.evaluate(time)[0];\n        timeScale *= interpolantValue;\n\n        if (time > interpolant.parameterPositions[1]) {\n          this.stopWarping();\n\n          if (timeScale === 0) {\n            // motion has halted, pause\n            this.paused = true;\n          } else {\n            // warp done - apply final time scale\n            this.timeScale = timeScale;\n          }\n        }\n      }\n    }\n\n    this._effectiveTimeScale = timeScale;\n    return timeScale;\n  },\n  _updateTime: function _updateTime(deltaTime) {\n    var time = this.time + deltaTime;\n    var duration = this._clip.duration;\n    var loop = this.loop;\n    var loopCount = this._loopCount;\n    var pingPong = loop === LoopPingPong;\n\n    if (deltaTime === 0) {\n      if (loopCount === -1) return time;\n      return pingPong && (loopCount & 1) === 1 ? duration - time : time;\n    }\n\n    if (loop === LoopOnce) {\n      if (loopCount === -1) {\n        // just started\n        this._loopCount = 0;\n\n        this._setEndings(true, true, false);\n      }\n\n      handle_stop: {\n        if (time >= duration) {\n          time = duration;\n        } else if (time < 0) {\n          time = 0;\n        } else {\n          this.time = time;\n          break handle_stop;\n        }\n\n        if (this.clampWhenFinished) this.paused = true;else this.enabled = false;\n        this.time = time;\n\n        this._mixer.dispatchEvent({\n          type: 'finished',\n          action: this,\n          direction: deltaTime < 0 ? -1 : 1\n        });\n      }\n    } else {\n      // repetitive Repeat or PingPong\n      if (loopCount === -1) {\n        // just started\n        if (deltaTime >= 0) {\n          loopCount = 0;\n\n          this._setEndings(true, this.repetitions === 0, pingPong);\n        } else {\n          // when looping in reverse direction, the initial\n          // transition through zero counts as a repetition,\n          // so leave loopCount at -1\n          this._setEndings(this.repetitions === 0, true, pingPong);\n        }\n      }\n\n      if (time >= duration || time < 0) {\n        // wrap around\n        var loopDelta = Math.floor(time / duration); // signed\n\n        time -= duration * loopDelta;\n        loopCount += Math.abs(loopDelta);\n        var pending = this.repetitions - loopCount;\n\n        if (pending <= 0) {\n          // have to stop (switch state, clamp time, fire event)\n          if (this.clampWhenFinished) this.paused = true;else this.enabled = false;\n          time = deltaTime > 0 ? duration : 0;\n          this.time = time;\n\n          this._mixer.dispatchEvent({\n            type: 'finished',\n            action: this,\n            direction: deltaTime > 0 ? 1 : -1\n          });\n        } else {\n          // keep running\n          if (pending === 1) {\n            // entering the last round\n            var atStart = deltaTime < 0;\n\n            this._setEndings(atStart, !atStart, pingPong);\n          } else {\n            this._setEndings(false, false, pingPong);\n          }\n\n          this._loopCount = loopCount;\n          this.time = time;\n\n          this._mixer.dispatchEvent({\n            type: 'loop',\n            action: this,\n            loopDelta: loopDelta\n          });\n        }\n      } else {\n        this.time = time;\n      }\n\n      if (pingPong && (loopCount & 1) === 1) {\n        // invert time for the \"pong round\"\n        return duration - time;\n      }\n    }\n\n    return time;\n  },\n  _setEndings: function _setEndings(atStart, atEnd, pingPong) {\n    var settings = this._interpolantSettings;\n\n    if (pingPong) {\n      settings.endingStart = ZeroSlopeEnding;\n      settings.endingEnd = ZeroSlopeEnding;\n    } else {\n      // assuming for LoopOnce atStart == atEnd == true\n      if (atStart) {\n        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n      } else {\n        settings.endingStart = WrapAroundEnding;\n      }\n\n      if (atEnd) {\n        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n      } else {\n        settings.endingEnd = WrapAroundEnding;\n      }\n    }\n  },\n  _scheduleFading: function _scheduleFading(duration, weightNow, weightThen) {\n    var mixer = this._mixer,\n        now = mixer.time,\n        interpolant = this._weightInterpolant;\n\n    if (interpolant === null) {\n      interpolant = mixer._lendControlInterpolant();\n      this._weightInterpolant = interpolant;\n    }\n\n    var times = interpolant.parameterPositions,\n        values = interpolant.sampleValues;\n    times[0] = now;\n    values[0] = weightNow;\n    times[1] = now + duration;\n    values[1] = weightThen;\n    return this;\n  }\n});\n\nexport { AnimationAction };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/animation/AnimationAction.js"],"names":["WrapAroundEnding","ZeroCurvatureEnding","ZeroSlopeEnding","LoopPingPong","LoopOnce","LoopRepeat","AnimationAction","mixer","clip","localRoot","_mixer","_clip","_localRoot","tracks","nTracks","length","interpolants","Array","interpolantSettings","endingStart","endingEnd","i","interpolant","createInterpolant","settings","_interpolantSettings","_interpolants","_propertyBindings","_cacheIndex","_byClipCacheIndex","_timeScaleInterpolant","_weightInterpolant","loop","_loopCount","_startTime","time","timeScale","_effectiveTimeScale","weight","_effectiveWeight","repetitions","Infinity","paused","enabled","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","prototype","play","_activateAction","stop","_deactivateAction","reset","stopFading","stopWarping","isRunning","_isActiveAction","isScheduled","startAt","setLoop","mode","setEffectiveWeight","getEffectiveWeight","fadeIn","duration","_scheduleFading","fadeOut","crossFadeFrom","fadeOutAction","warp","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","weightInterpolant","_takeBackControlInterpolant","setEffectiveTimeScale","getEffectiveTimeScale","setDuration","syncWith","action","halt","startTimeScale","endTimeScale","now","_lendControlInterpolant","times","parameterPositions","values","sampleValues","timeScaleInterpolant","getMixer","getClip","getRoot","_root","_update","deltaTime","timeDirection","accuIndex","_updateWeight","startTime","timeRunning","_updateTimeScale","clipTime","_updateTime","propertyMixers","j","m","evaluate","accumulate","interpolantValue","loopCount","pingPong","_setEndings","handle_stop","dispatchEvent","type","direction","loopDelta","Math","floor","abs","pending","atStart","atEnd","weightNow","weightThen"],"mappings":"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","sourcesContent":["import { WrapAroundEnding, ZeroCurvatureEnding, ZeroSlopeEnding, LoopPingPong, LoopOnce, LoopRepeat } from '../constants.js';\n\n/**\n *\n * Action provided by AnimationMixer for scheduling clip playback on specific\n * objects.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n *\n */\n\nfunction AnimationAction( mixer, clip, localRoot ) {\n\n\tthis._mixer = mixer;\n\tthis._clip = clip;\n\tthis._localRoot = localRoot || null;\n\n\tvar tracks = clip.tracks,\n\t\tnTracks = tracks.length,\n\t\tinterpolants = new Array( nTracks );\n\n\tvar interpolantSettings = {\n\t\tendingStart: ZeroCurvatureEnding,\n\t\tendingEnd: ZeroCurvatureEnding\n\t};\n\n\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\tinterpolants[ i ] = interpolant;\n\t\tinterpolant.settings = interpolantSettings;\n\n\t}\n\n\tthis._interpolantSettings = interpolantSettings;\n\n\tthis._interpolants = interpolants; // bound by the mixer\n\n\t// inside: PropertyMixer (managed by the mixer)\n\tthis._propertyBindings = new Array( nTracks );\n\n\tthis._cacheIndex = null; // for the memory manager\n\tthis._byClipCacheIndex = null; // for the memory manager\n\n\tthis._timeScaleInterpolant = null;\n\tthis._weightInterpolant = null;\n\n\tthis.loop = LoopRepeat;\n\tthis._loopCount = - 1;\n\n\t// global mixer time when the action is to be started\n\t// it's set back to 'null' upon start of the action\n\tthis._startTime = null;\n\n\t// scaled local time of the action\n\t// gets clamped or wrapped to 0..clip.duration according to loop\n\tthis.time = 0;\n\n\tthis.timeScale = 1;\n\tthis._effectiveTimeScale = 1;\n\n\tthis.weight = 1;\n\tthis._effectiveWeight = 1;\n\n\tthis.repetitions = Infinity; // no. of repetitions when looping\n\n\tthis.paused = false; // true -> zero effective time scale\n\tthis.enabled = true; // false -> zero effective weight\n\n\tthis.clampWhenFinished = false;// keep feeding the last frame?\n\n\tthis.zeroSlopeAtStart = true;// for smooth interpolation w/o separate\n\tthis.zeroSlopeAtEnd = true;// clips for start, loop and end\n\n}\n\nObject.assign( AnimationAction.prototype, {\n\n\t// State & Scheduling\n\n\tplay: function () {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t},\n\n\tstop: function () {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t},\n\n\treset: function () {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0; // restart clip\n\t\tthis._loopCount = - 1;// forget previous loops\n\t\tthis._startTime = null;// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t},\n\n\tisRunning: function () {\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t},\n\n\t// return true when play has been called\n\tisScheduled: function () {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t},\n\n\tstartAt: function ( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t},\n\n\tsetLoop: function ( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t},\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight: function ( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t},\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight: function () {\n\n\t\treturn this._effectiveWeight;\n\n\t},\n\n\tfadeIn: function ( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t},\n\n\tfadeOut: function ( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t},\n\n\tcrossFadeFrom: function ( fadeOutAction, duration, warp ) {\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif ( warp ) {\n\n\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcrossFadeTo: function ( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t},\n\n\tstopFading: function () {\n\n\t\tvar weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Time Scale Control\n\n\t// set the time scale stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale: function ( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale: function () {\n\n\t\treturn this._effectiveTimeScale;\n\n\t},\n\n\tsetDuration: function ( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\tsyncWith: function ( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\thalt: function ( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t},\n\n\twarp: function ( startTimeScale, endTimeScale, duration ) {\n\n\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\tinterpolant = this._timeScaleInterpolant,\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tvar times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t},\n\n\tstopWarping: function () {\n\n\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Object Accessors\n\n\tgetMixer: function () {\n\n\t\treturn this._mixer;\n\n\t},\n\n\tgetClip: function () {\n\n\t\treturn this._clip;\n\n\t},\n\n\tgetRoot: function () {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t},\n\n\t// Interna\n\n\t_update: function ( time, deltaTime, timeDirection, accuIndex ) {\n\n\t\t// called by the mixer\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\n\t\t\tthis._updateWeight( time );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t}\n\n\t\t\t// start\n\n\t\t\tthis._startTime = null; // unschedule\n\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tvar clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tvar weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tvar interpolants = this._interpolants;\n\t\t\tvar propertyMixers = this._propertyBindings;\n\n\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_updateWeight: function ( time ) {\n\n\t\tvar weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tvar interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t},\n\n\t_updateTimeScale: function ( time ) {\n\n\t\tvar timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tvar interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t},\n\n\t_updateTime: function ( deltaTime ) {\n\n\t\tvar time = this.time + deltaTime;\n\t\tvar duration = this._clip.duration;\n\t\tvar loop = this.loop;\n\t\tvar loopCount = this._loopCount;\n\n\t\tvar pingPong = ( loop === LoopPingPong );\n\n\t\tif ( deltaTime === 0 ) {\n\n\t\t\tif ( loopCount === - 1 ) return time;\n\n\t\t\treturn ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;\n\n\t\t}\n\n\t\tif ( loop === LoopOnce ) {\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tthis._loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tbreak handle_stop;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis.time = time;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? - 1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings( true, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings( this.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\n\t\t\t\t// wrap around\n\n\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tvar pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending <= 0 ) {\n\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : - 1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 1 ) {\n\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.time = time;\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn time;\n\n\t},\n\n\t_setEndings: function ( atStart, atEnd, pingPong ) {\n\n\t\tvar settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart = ZeroSlopeEnding;\n\t\t\tsettings.endingEnd = ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_scheduleFading: function ( duration, weightNow, weightThen ) {\n\n\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\tinterpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tvar times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\n\t\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n\nexport { AnimationAction };\n"]},"metadata":{},"sourceType":"module"}