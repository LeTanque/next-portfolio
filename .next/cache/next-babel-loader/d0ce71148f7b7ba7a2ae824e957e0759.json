{"ast":null,"code":"import _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\n\n/**\n * @author jonobr1 / http://jonobr1.com\n * @author Mugen87 / https://github.com/Mugen87\n */\nimport { Geometry } from '../core/Geometry.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { ShapeUtils } from '../extras/ShapeUtils.js'; // ShapeGeometry\n\nfunction ShapeGeometry(shapes, curveSegments) {\n  Geometry.call(this);\n  this.type = 'ShapeGeometry';\n\n  if (typeof curveSegments === 'object') {\n    console.warn('THREE.ShapeGeometry: Options parameter has been removed.');\n    curveSegments = curveSegments.curveSegments;\n  }\n\n  this.parameters = {\n    shapes: shapes,\n    curveSegments: curveSegments\n  };\n  this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));\n  this.mergeVertices();\n}\n\nShapeGeometry.prototype = _Object$create(Geometry.prototype);\nShapeGeometry.prototype.constructor = ShapeGeometry;\n\nShapeGeometry.prototype.toJSON = function () {\n  var data = Geometry.prototype.toJSON.call(this);\n  var shapes = this.parameters.shapes;\n  return toJSON(shapes, data);\n}; // ShapeBufferGeometry\n\n\nfunction ShapeBufferGeometry(shapes, curveSegments) {\n  BufferGeometry.call(this);\n  this.type = 'ShapeBufferGeometry';\n  this.parameters = {\n    shapes: shapes,\n    curveSegments: curveSegments\n  };\n  curveSegments = curveSegments || 12; // buffers\n\n  var indices = [];\n  var vertices = [];\n  var normals = [];\n  var uvs = []; // helper variables\n\n  var groupStart = 0;\n  var groupCount = 0; // allow single and array values for \"shapes\" parameter\n\n  if (_Array$isArray(shapes) === false) {\n    addShape(shapes);\n  } else {\n    for (var i = 0; i < shapes.length; i++) {\n      addShape(shapes[i]);\n      this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support\n\n      groupStart += groupCount;\n      groupCount = 0;\n    }\n  } // build geometry\n\n\n  this.setIndex(indices);\n  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n  this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions\n\n  function addShape(shape) {\n    var i, l, shapeHole;\n    var indexOffset = vertices.length / 3;\n    var points = shape.extractPoints(curveSegments);\n    var shapeVertices = points.shape;\n    var shapeHoles = points.holes; // check direction of vertices\n\n    if (ShapeUtils.isClockWise(shapeVertices) === false) {\n      shapeVertices = shapeVertices.reverse();\n    }\n\n    for (i = 0, l = shapeHoles.length; i < l; i++) {\n      shapeHole = shapeHoles[i];\n\n      if (ShapeUtils.isClockWise(shapeHole) === true) {\n        shapeHoles[i] = shapeHole.reverse();\n      }\n    }\n\n    var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array\n\n    for (i = 0, l = shapeHoles.length; i < l; i++) {\n      shapeHole = shapeHoles[i];\n      shapeVertices = shapeVertices.concat(shapeHole);\n    } // vertices, normals, uvs\n\n\n    for (i = 0, l = shapeVertices.length; i < l; i++) {\n      var vertex = shapeVertices[i];\n      vertices.push(vertex.x, vertex.y, 0);\n      normals.push(0, 0, 1);\n      uvs.push(vertex.x, vertex.y); // world uvs\n    } // incides\n\n\n    for (i = 0, l = faces.length; i < l; i++) {\n      var face = faces[i];\n      var a = face[0] + indexOffset;\n      var b = face[1] + indexOffset;\n      var c = face[2] + indexOffset;\n      indices.push(a, b, c);\n      groupCount += 3;\n    }\n  }\n}\n\nShapeBufferGeometry.prototype = _Object$create(BufferGeometry.prototype);\nShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;\n\nShapeBufferGeometry.prototype.toJSON = function () {\n  var data = BufferGeometry.prototype.toJSON.call(this);\n  var shapes = this.parameters.shapes;\n  return toJSON(shapes, data);\n}; //\n\n\nfunction toJSON(shapes, data) {\n  data.shapes = [];\n\n  if (_Array$isArray(shapes)) {\n    for (var i = 0, l = shapes.length; i < l; i++) {\n      var shape = shapes[i];\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n\n  return data;\n}\n\nexport { ShapeGeometry, ShapeBufferGeometry };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/geometries/ShapeGeometry.js"],"names":["Geometry","BufferGeometry","Float32BufferAttribute","ShapeUtils","ShapeGeometry","shapes","curveSegments","call","type","console","warn","parameters","fromBufferGeometry","ShapeBufferGeometry","mergeVertices","prototype","constructor","toJSON","data","indices","vertices","normals","uvs","groupStart","groupCount","addShape","i","length","addGroup","setIndex","setAttribute","shape","l","shapeHole","indexOffset","points","extractPoints","shapeVertices","shapeHoles","holes","isClockWise","reverse","faces","triangulateShape","concat","vertex","push","x","y","face","a","b","c","uuid"],"mappings":"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","sourcesContent":["/**\n * @author jonobr1 / http://jonobr1.com\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nimport { Geometry } from '../core/Geometry.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { ShapeUtils } from '../extras/ShapeUtils.js';\n\n// ShapeGeometry\n\nfunction ShapeGeometry( shapes, curveSegments ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'ShapeGeometry';\n\n\tif ( typeof curveSegments === 'object' ) {\n\n\t\tconsole.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );\n\n\t\tcurveSegments = curveSegments.curveSegments;\n\n\t}\n\n\tthis.parameters = {\n\t\tshapes: shapes,\n\t\tcurveSegments: curveSegments\n\t};\n\n\tthis.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );\n\tthis.mergeVertices();\n\n}\n\nShapeGeometry.prototype = Object.create( Geometry.prototype );\nShapeGeometry.prototype.constructor = ShapeGeometry;\n\nShapeGeometry.prototype.toJSON = function () {\n\n\tvar data = Geometry.prototype.toJSON.call( this );\n\n\tvar shapes = this.parameters.shapes;\n\n\treturn toJSON( shapes, data );\n\n};\n\n// ShapeBufferGeometry\n\nfunction ShapeBufferGeometry( shapes, curveSegments ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'ShapeBufferGeometry';\n\n\tthis.parameters = {\n\t\tshapes: shapes,\n\t\tcurveSegments: curveSegments\n\t};\n\n\tcurveSegments = curveSegments || 12;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar groupStart = 0;\n\tvar groupCount = 0;\n\n\t// allow single and array values for \"shapes\" parameter\n\n\tif ( Array.isArray( shapes ) === false ) {\n\n\t\taddShape( shapes );\n\n\t} else {\n\n\t\tfor ( var i = 0; i < shapes.length; i ++ ) {\n\n\t\t\taddShape( shapes[ i ] );\n\n\t\t\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\n\n\t\t\tgroupStart += groupCount;\n\t\t\tgroupCount = 0;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n\t// helper functions\n\n\tfunction addShape( shape ) {\n\n\t\tvar i, l, shapeHole;\n\n\t\tvar indexOffset = vertices.length / 3;\n\t\tvar points = shape.extractPoints( curveSegments );\n\n\t\tvar shapeVertices = points.shape;\n\t\tvar shapeHoles = points.holes;\n\n\t\t// check direction of vertices\n\n\t\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\n\n\t\t\tshapeVertices = shapeVertices.reverse();\n\n\t\t}\n\n\t\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\tshapeHole = shapeHoles[ i ];\n\n\t\t\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\n\n\t\t\t\tshapeHoles[ i ] = shapeHole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\n\n\t\t// join vertices of inner and outer paths to a single array\n\n\t\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\tshapeHole = shapeHoles[ i ];\n\t\t\tshapeVertices = shapeVertices.concat( shapeHole );\n\n\t\t}\n\n\t\t// vertices, normals, uvs\n\n\t\tfor ( i = 0, l = shapeVertices.length; i < l; i ++ ) {\n\n\t\t\tvar vertex = shapeVertices[ i ];\n\n\t\t\tvertices.push( vertex.x, vertex.y, 0 );\n\t\t\tnormals.push( 0, 0, 1 );\n\t\t\tuvs.push( vertex.x, vertex.y ); // world uvs\n\n\t\t}\n\n\t\t// incides\n\n\t\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tvar a = face[ 0 ] + indexOffset;\n\t\t\tvar b = face[ 1 ] + indexOffset;\n\t\t\tvar c = face[ 2 ] + indexOffset;\n\n\t\t\tindices.push( a, b, c );\n\t\t\tgroupCount += 3;\n\n\t\t}\n\n\t}\n\n}\n\nShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;\n\nShapeBufferGeometry.prototype.toJSON = function () {\n\n\tvar data = BufferGeometry.prototype.toJSON.call( this );\n\n\tvar shapes = this.parameters.shapes;\n\n\treturn toJSON( shapes, data );\n\n};\n\n//\n\nfunction toJSON( shapes, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tvar shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\treturn data;\n\n}\n\n\nexport { ShapeGeometry, ShapeBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}