{"ast":null,"code":"import _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport { EventDispatcher } from './EventDispatcher.js';\nimport { Face3 } from './Face3.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Box3 } from '../math/Box3.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Color } from '../math/Color.js';\nimport { Object3D } from './Object3D.js';\nimport { _Math } from '../math/Math.js';\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author bhouston / http://clara.io\n */\n\nvar _geometryId = 0; // Geometry uses even numbers as Id\n\nvar _m1 = new Matrix4();\n\nvar _obj = new Object3D();\n\nvar _offset = new Vector3();\n\nfunction Geometry() {\n  _Object$defineProperty(this, 'id', {\n    value: _geometryId += 2\n  });\n\n  this.uuid = _Math.generateUUID();\n  this.name = '';\n  this.type = 'Geometry';\n  this.vertices = [];\n  this.colors = [];\n  this.faces = [];\n  this.faceVertexUvs = [[]];\n  this.morphTargets = [];\n  this.morphNormals = [];\n  this.skinWeights = [];\n  this.skinIndices = [];\n  this.lineDistances = [];\n  this.boundingBox = null;\n  this.boundingSphere = null; // update flags\n\n  this.elementsNeedUpdate = false;\n  this.verticesNeedUpdate = false;\n  this.uvsNeedUpdate = false;\n  this.normalsNeedUpdate = false;\n  this.colorsNeedUpdate = false;\n  this.lineDistancesNeedUpdate = false;\n  this.groupsNeedUpdate = false;\n}\n\nGeometry.prototype = _Object$assign(_Object$create(EventDispatcher.prototype), {\n  constructor: Geometry,\n  isGeometry: true,\n  applyMatrix: function applyMatrix(matrix) {\n    var normalMatrix = new Matrix3().getNormalMatrix(matrix);\n\n    for (var i = 0, il = this.vertices.length; i < il; i++) {\n      var vertex = this.vertices[i];\n      vertex.applyMatrix4(matrix);\n    }\n\n    for (var i = 0, il = this.faces.length; i < il; i++) {\n      var face = this.faces[i];\n      face.normal.applyMatrix3(normalMatrix).normalize();\n\n      for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n      }\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    this.verticesNeedUpdate = true;\n    this.normalsNeedUpdate = true;\n    return this;\n  },\n  rotateX: function rotateX(angle) {\n    // rotate geometry around world x-axis\n    _m1.makeRotationX(angle);\n\n    this.applyMatrix(_m1);\n    return this;\n  },\n  rotateY: function rotateY(angle) {\n    // rotate geometry around world y-axis\n    _m1.makeRotationY(angle);\n\n    this.applyMatrix(_m1);\n    return this;\n  },\n  rotateZ: function rotateZ(angle) {\n    // rotate geometry around world z-axis\n    _m1.makeRotationZ(angle);\n\n    this.applyMatrix(_m1);\n    return this;\n  },\n  translate: function translate(x, y, z) {\n    // translate geometry\n    _m1.makeTranslation(x, y, z);\n\n    this.applyMatrix(_m1);\n    return this;\n  },\n  scale: function scale(x, y, z) {\n    // scale geometry\n    _m1.makeScale(x, y, z);\n\n    this.applyMatrix(_m1);\n    return this;\n  },\n  lookAt: function lookAt(vector) {\n    _obj.lookAt(vector);\n\n    _obj.updateMatrix();\n\n    this.applyMatrix(_obj.matrix);\n    return this;\n  },\n  fromBufferGeometry: function fromBufferGeometry(geometry) {\n    var scope = this;\n    var indices = geometry.index !== null ? geometry.index.array : undefined;\n    var attributes = geometry.attributes;\n\n    if (attributes.position === undefined) {\n      console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');\n      return this;\n    }\n\n    var positions = attributes.position.array;\n    var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n    var colors = attributes.color !== undefined ? attributes.color.array : undefined;\n    var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n    var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n    if (uvs2 !== undefined) this.faceVertexUvs[1] = [];\n\n    for (var i = 0; i < positions.length; i += 3) {\n      scope.vertices.push(new Vector3().fromArray(positions, i));\n\n      if (colors !== undefined) {\n        scope.colors.push(new Color().fromArray(colors, i));\n      }\n    }\n\n    function addFace(a, b, c, materialIndex) {\n      var vertexColors = colors === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n      var vertexNormals = normals === undefined ? [] : [new Vector3().fromArray(normals, a * 3), new Vector3().fromArray(normals, b * 3), new Vector3().fromArray(normals, c * 3)];\n      var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n      scope.faces.push(face);\n\n      if (uvs !== undefined) {\n        scope.faceVertexUvs[0].push([new Vector2().fromArray(uvs, a * 2), new Vector2().fromArray(uvs, b * 2), new Vector2().fromArray(uvs, c * 2)]);\n      }\n\n      if (uvs2 !== undefined) {\n        scope.faceVertexUvs[1].push([new Vector2().fromArray(uvs2, a * 2), new Vector2().fromArray(uvs2, b * 2), new Vector2().fromArray(uvs2, c * 2)]);\n      }\n    }\n\n    var groups = geometry.groups;\n\n    if (groups.length > 0) {\n      for (var i = 0; i < groups.length; i++) {\n        var group = groups[i];\n        var start = group.start;\n        var count = group.count;\n\n        for (var j = start, jl = start + count; j < jl; j += 3) {\n          if (indices !== undefined) {\n            addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex);\n          }\n        }\n      }\n    } else {\n      if (indices !== undefined) {\n        for (var i = 0; i < indices.length; i += 3) {\n          addFace(indices[i], indices[i + 1], indices[i + 2]);\n        }\n      } else {\n        for (var i = 0; i < positions.length / 3; i += 3) {\n          addFace(i, i + 1, i + 2);\n        }\n      }\n    }\n\n    this.computeFaceNormals();\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    return this;\n  },\n  center: function center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  },\n  normalize: function normalize() {\n    this.computeBoundingSphere();\n    var center = this.boundingSphere.center;\n    var radius = this.boundingSphere.radius;\n    var s = radius === 0 ? 1 : 1.0 / radius;\n    var matrix = new Matrix4();\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n    this.applyMatrix(matrix);\n    return this;\n  },\n  computeFaceNormals: function computeFaceNormals() {\n    var cb = new Vector3(),\n        ab = new Vector3();\n\n    for (var f = 0, fl = this.faces.length; f < fl; f++) {\n      var face = this.faces[f];\n      var vA = this.vertices[face.a];\n      var vB = this.vertices[face.b];\n      var vC = this.vertices[face.c];\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab);\n      cb.normalize();\n      face.normal.copy(cb);\n    }\n  },\n  computeVertexNormals: function computeVertexNormals(areaWeighted) {\n    if (areaWeighted === undefined) areaWeighted = true;\n    var v, vl, f, fl, face, vertices;\n    vertices = new Array(this.vertices.length);\n\n    for (v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3();\n    }\n\n    if (areaWeighted) {\n      // vertex normals weighted by triangle areas\n      // http://www.iquilezles.org/www/articles/normals/normals.htm\n      var vA, vB, vC;\n      var cb = new Vector3(),\n          ab = new Vector3();\n\n      for (f = 0, fl = this.faces.length; f < fl; f++) {\n        face = this.faces[f];\n        vA = this.vertices[face.a];\n        vB = this.vertices[face.b];\n        vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        vertices[face.a].add(cb);\n        vertices[face.b].add(cb);\n        vertices[face.c].add(cb);\n      }\n    } else {\n      this.computeFaceNormals();\n\n      for (f = 0, fl = this.faces.length; f < fl; f++) {\n        face = this.faces[f];\n        vertices[face.a].add(face.normal);\n        vertices[face.b].add(face.normal);\n        vertices[face.c].add(face.normal);\n      }\n    }\n\n    for (v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize();\n    }\n\n    for (f = 0, fl = this.faces.length; f < fl; f++) {\n      face = this.faces[f];\n      var vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a]);\n        vertexNormals[1].copy(vertices[face.b]);\n        vertexNormals[2].copy(vertices[face.c]);\n      } else {\n        vertexNormals[0] = vertices[face.a].clone();\n        vertexNormals[1] = vertices[face.b].clone();\n        vertexNormals[2] = vertices[face.c].clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  },\n  computeFlatVertexNormals: function computeFlatVertexNormals() {\n    var f, fl, face;\n    this.computeFaceNormals();\n\n    for (f = 0, fl = this.faces.length; f < fl; f++) {\n      face = this.faces[f];\n      var vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal);\n        vertexNormals[1].copy(face.normal);\n        vertexNormals[2].copy(face.normal);\n      } else {\n        vertexNormals[0] = face.normal.clone();\n        vertexNormals[1] = face.normal.clone();\n        vertexNormals[2] = face.normal.clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  },\n  computeMorphNormals: function computeMorphNormals() {\n    var i, il, f, fl, face; // save original normals\n    // - create temp variables on first access\n    //   otherwise just copy (for faster repeated calls)\n\n    for (f = 0, fl = this.faces.length; f < fl; f++) {\n      face = this.faces[f];\n\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone();\n      } else {\n        face.__originalFaceNormal.copy(face.normal);\n      }\n\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n\n      for (i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n        }\n      }\n    } // use temp geometry to compute face and vertex normals for each morph\n\n\n    var tmpGeo = new Geometry();\n    tmpGeo.faces = this.faces;\n\n    for (i = 0, il = this.morphTargets.length; i < il; i++) {\n      // create on first access\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {};\n        this.morphNormals[i].faceNormals = [];\n        this.morphNormals[i].vertexNormals = [];\n        var dstNormalsFace = this.morphNormals[i].faceNormals;\n        var dstNormalsVertex = this.morphNormals[i].vertexNormals;\n        var faceNormal, vertexNormals;\n\n        for (f = 0, fl = this.faces.length; f < fl; f++) {\n          faceNormal = new Vector3();\n          vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3()\n          };\n          dstNormalsFace.push(faceNormal);\n          dstNormalsVertex.push(vertexNormals);\n        }\n      }\n\n      var morphNormals = this.morphNormals[i]; // set vertices to morph target\n\n      tmpGeo.vertices = this.morphTargets[i].vertices; // compute morph normals\n\n      tmpGeo.computeFaceNormals();\n      tmpGeo.computeVertexNormals(); // store morph normals\n\n      var faceNormal, vertexNormals;\n\n      for (f = 0, fl = this.faces.length; f < fl; f++) {\n        face = this.faces[f];\n        faceNormal = morphNormals.faceNormals[f];\n        vertexNormals = morphNormals.vertexNormals[f];\n        faceNormal.copy(face.normal);\n        vertexNormals.a.copy(face.vertexNormals[0]);\n        vertexNormals.b.copy(face.vertexNormals[1]);\n        vertexNormals.c.copy(face.vertexNormals[2]);\n      }\n    } // restore original normals\n\n\n    for (f = 0, fl = this.faces.length; f < fl; f++) {\n      face = this.faces[f];\n      face.normal = face.__originalFaceNormal;\n      face.vertexNormals = face.__originalVertexNormals;\n    }\n  },\n  computeBoundingBox: function computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    this.boundingBox.setFromPoints(this.vertices);\n  },\n  computeBoundingSphere: function computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    this.boundingSphere.setFromPoints(this.vertices);\n  },\n  merge: function merge(geometry, matrix, materialIndexOffset) {\n    if (!(geometry && geometry.isGeometry)) {\n      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\n      return;\n    }\n\n    var normalMatrix,\n        vertexOffset = this.vertices.length,\n        vertices1 = this.vertices,\n        vertices2 = geometry.vertices,\n        faces1 = this.faces,\n        faces2 = geometry.faces,\n        colors1 = this.colors,\n        colors2 = geometry.colors;\n    if (materialIndexOffset === undefined) materialIndexOffset = 0;\n\n    if (matrix !== undefined) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    } // vertices\n\n\n    for (var i = 0, il = vertices2.length; i < il; i++) {\n      var vertex = vertices2[i];\n      var vertexCopy = vertex.clone();\n      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\n      vertices1.push(vertexCopy);\n    } // colors\n\n\n    for (var i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone());\n    } // faces\n\n\n    for (i = 0, il = faces2.length; i < il; i++) {\n      var face = faces2[i],\n          faceCopy,\n          normal,\n          color,\n          faceVertexNormals = face.vertexNormals,\n          faceVertexColors = face.vertexColors;\n      faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n      faceCopy.normal.copy(face.normal);\n\n      if (normalMatrix !== undefined) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n      }\n\n      for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone();\n\n        if (normalMatrix !== undefined) {\n          normal.applyMatrix3(normalMatrix).normalize();\n        }\n\n        faceCopy.vertexNormals.push(normal);\n      }\n\n      faceCopy.color.copy(face.color);\n\n      for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j];\n        faceCopy.vertexColors.push(color.clone());\n      }\n\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n      faces1.push(faceCopy);\n    } // uvs\n\n\n    for (var i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      var faceVertexUvs2 = geometry.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];\n\n      for (var j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        var uvs2 = faceVertexUvs2[j],\n            uvsCopy = [];\n\n        for (var k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n  },\n  mergeMesh: function mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\n      return;\n    }\n\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n    this.merge(mesh.geometry, mesh.matrix);\n  },\n\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n  mergeVertices: function mergeVertices() {\n    var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\n    var unique = [],\n        changes = [];\n    var v, key;\n    var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\n    var precision = Math.pow(10, precisionPoints);\n    var i, il, face;\n    var indices, j, jl;\n\n    for (i = 0, il = this.vertices.length; i < il; i++) {\n      v = this.vertices[i];\n      key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);\n\n      if (verticesMap[key] === undefined) {\n        verticesMap[key] = i;\n        unique.push(this.vertices[i]);\n        changes[i] = unique.length - 1;\n      } else {\n        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n        changes[i] = changes[verticesMap[key]];\n      }\n    } // if faces are completely degenerate after merging vertices, we\n    // have to remove them from the geometry.\n\n\n    var faceIndicesToRemove = [];\n\n    for (i = 0, il = this.faces.length; i < il; i++) {\n      face = this.faces[i];\n      face.a = changes[face.a];\n      face.b = changes[face.b];\n      face.c = changes[face.c];\n      indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3\n      // we have to remove the face as nothing can be saved\n\n      for (var n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i);\n          break;\n        }\n      }\n    }\n\n    for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      var idx = faceIndicesToRemove[i];\n      this.faces.splice(idx, 1);\n\n      for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1);\n      }\n    } // Use unique set of vertices\n\n\n    var diff = this.vertices.length - unique.length;\n    this.vertices = unique;\n    return diff;\n  },\n  setFromPoints: function setFromPoints(points) {\n    this.vertices = [];\n\n    for (var i = 0, l = points.length; i < l; i++) {\n      var point = points[i];\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n    }\n\n    return this;\n  },\n  sortFacesByMaterialIndex: function sortFacesByMaterialIndex() {\n    var faces = this.faces;\n    var length = faces.length; // tag faces\n\n    for (var i = 0; i < length; i++) {\n      faces[i]._id = i;\n    } // sort faces\n\n\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex;\n    }\n\n    faces.sort(materialIndexSort); // sort uvs\n\n    var uvs1 = this.faceVertexUvs[0];\n    var uvs2 = this.faceVertexUvs[1];\n    var newUvs1, newUvs2;\n    if (uvs1 && uvs1.length === length) newUvs1 = [];\n    if (uvs2 && uvs2.length === length) newUvs2 = [];\n\n    for (var i = 0; i < length; i++) {\n      var id = faces[i]._id;\n      if (newUvs1) newUvs1.push(uvs1[id]);\n      if (newUvs2) newUvs2.push(uvs2[id]);\n    }\n\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n  },\n  toJSON: function toJSON() {\n    var data = {\n      metadata: {\n        version: 4.5,\n        type: 'Geometry',\n        generator: 'Geometry.toJSON'\n      }\n    }; // standard Geometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n\n    if (this.parameters !== undefined) {\n      var parameters = this.parameters;\n\n      for (var key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n\n      return data;\n    }\n\n    var vertices = [];\n\n    for (var i = 0; i < this.vertices.length; i++) {\n      var vertex = this.vertices[i];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n\n    var faces = [];\n    var normals = [];\n    var normalsHash = {};\n    var colors = [];\n    var colorsHash = {};\n    var uvs = [];\n    var uvsHash = {};\n\n    for (var i = 0; i < this.faces.length; i++) {\n      var face = this.faces[i];\n      var hasMaterial = true;\n      var hasFaceUv = false; // deprecated\n\n      var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\n      var hasFaceNormal = face.normal.length() > 0;\n      var hasFaceVertexNormal = face.vertexNormals.length > 0;\n      var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n      var hasFaceVertexColor = face.vertexColors.length > 0;\n      var faceType = 0;\n      faceType = setBit(faceType, 0, 0); // isQuad\n\n      faceType = setBit(faceType, 1, hasMaterial);\n      faceType = setBit(faceType, 2, hasFaceUv);\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\n      faceType = setBit(faceType, 4, hasFaceNormal);\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\n      faceType = setBit(faceType, 6, hasFaceColor);\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\n      faces.push(faceType);\n      faces.push(face.a, face.b, face.c);\n      faces.push(face.materialIndex);\n\n      if (hasFaceVertexUv) {\n        var faceVertexUvs = this.faceVertexUvs[0][i];\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n      }\n\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal));\n      }\n\n      if (hasFaceVertexNormal) {\n        var vertexNormals = face.vertexNormals;\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n      }\n\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color));\n      }\n\n      if (hasFaceVertexColor) {\n        var vertexColors = face.vertexColors;\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n      }\n    }\n\n    function setBit(value, position, enabled) {\n      return enabled ? value | 1 << position : value & ~(1 << position);\n    }\n\n    function getNormalIndex(normal) {\n      var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n      if (normalsHash[hash] !== undefined) {\n        return normalsHash[hash];\n      }\n\n      normalsHash[hash] = normals.length / 3;\n      normals.push(normal.x, normal.y, normal.z);\n      return normalsHash[hash];\n    }\n\n    function getColorIndex(color) {\n      var hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n      if (colorsHash[hash] !== undefined) {\n        return colorsHash[hash];\n      }\n\n      colorsHash[hash] = colors.length;\n      colors.push(color.getHex());\n      return colorsHash[hash];\n    }\n\n    function getUvIndex(uv) {\n      var hash = uv.x.toString() + uv.y.toString();\n\n      if (uvsHash[hash] !== undefined) {\n        return uvsHash[hash];\n      }\n\n      uvsHash[hash] = uvs.length / 2;\n      uvs.push(uv.x, uv.y);\n      return uvsHash[hash];\n    }\n\n    data.data = {};\n    data.data.vertices = vertices;\n    data.data.normals = normals;\n    if (colors.length > 0) data.data.colors = colors;\n    if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\n\n    data.data.faces = faces;\n    return data;\n  },\n  clone: function clone() {\n    /*\n     // Handle primitives\n    \t var parameters = this.parameters;\n    \t if ( parameters !== undefined ) {\n    \t var values = [];\n    \t for ( var key in parameters ) {\n    \t values.push( parameters[ key ] );\n    \t }\n    \t var geometry = Object.create( this.constructor.prototype );\n     this.constructor.apply( geometry, values );\n     return geometry;\n    \t }\n    \t return new this.constructor().copy( this );\n     */\n    return new Geometry().copy(this);\n  },\n  copy: function copy(source) {\n    var i, il, j, jl, k, kl; // reset\n\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // name\n\n    this.name = source.name; // vertices\n\n    var vertices = source.vertices;\n\n    for (i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone());\n    } // colors\n\n\n    var colors = source.colors;\n\n    for (i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone());\n    } // faces\n\n\n    var faces = source.faces;\n\n    for (i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone());\n    } // face vertex uvs\n\n\n    for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      var faceVertexUvs = source.faceVertexUvs[i];\n\n      if (this.faceVertexUvs[i] === undefined) {\n        this.faceVertexUvs[i] = [];\n      }\n\n      for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        var uvs = faceVertexUvs[j],\n            uvsCopy = [];\n\n        for (k = 0, kl = uvs.length; k < kl; k++) {\n          var uv = uvs[k];\n          uvsCopy.push(uv.clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    } // morph targets\n\n\n    var morphTargets = source.morphTargets;\n\n    for (i = 0, il = morphTargets.length; i < il; i++) {\n      var morphTarget = {};\n      morphTarget.name = morphTargets[i].name; // vertices\n\n      if (morphTargets[i].vertices !== undefined) {\n        morphTarget.vertices = [];\n\n        for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n        }\n      } // normals\n\n\n      if (morphTargets[i].normals !== undefined) {\n        morphTarget.normals = [];\n\n        for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone());\n        }\n      }\n\n      this.morphTargets.push(morphTarget);\n    } // morph normals\n\n\n    var morphNormals = source.morphNormals;\n\n    for (i = 0, il = morphNormals.length; i < il; i++) {\n      var morphNormal = {}; // vertex normals\n\n      if (morphNormals[i].vertexNormals !== undefined) {\n        morphNormal.vertexNormals = [];\n\n        for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          var srcVertexNormal = morphNormals[i].vertexNormals[j];\n          var destVertexNormal = {};\n          destVertexNormal.a = srcVertexNormal.a.clone();\n          destVertexNormal.b = srcVertexNormal.b.clone();\n          destVertexNormal.c = srcVertexNormal.c.clone();\n          morphNormal.vertexNormals.push(destVertexNormal);\n        }\n      } // face normals\n\n\n      if (morphNormals[i].faceNormals !== undefined) {\n        morphNormal.faceNormals = [];\n\n        for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n        }\n      }\n\n      this.morphNormals.push(morphNormal);\n    } // skin weights\n\n\n    var skinWeights = source.skinWeights;\n\n    for (i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone());\n    } // skin indices\n\n\n    var skinIndices = source.skinIndices;\n\n    for (i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone());\n    } // line distances\n\n\n    var lineDistances = source.lineDistances;\n\n    for (i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i]);\n    } // bounding box\n\n\n    var boundingBox = source.boundingBox;\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    } // bounding sphere\n\n\n    var boundingSphere = source.boundingSphere;\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    } // update flags\n\n\n    this.elementsNeedUpdate = source.elementsNeedUpdate;\n    this.verticesNeedUpdate = source.verticesNeedUpdate;\n    this.uvsNeedUpdate = source.uvsNeedUpdate;\n    this.normalsNeedUpdate = source.normalsNeedUpdate;\n    this.colorsNeedUpdate = source.colorsNeedUpdate;\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n    this.groupsNeedUpdate = source.groupsNeedUpdate;\n    return this;\n  },\n  dispose: function dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n});\nexport { Geometry };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/core/Geometry.js"],"names":["EventDispatcher","Face3","Matrix3","Sphere","Box3","Vector3","Matrix4","Vector2","Color","Object3D","_Math","_geometryId","_m1","_obj","_offset","Geometry","value","uuid","generateUUID","name","type","vertices","colors","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","lineDistances","boundingBox","boundingSphere","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","prototype","constructor","isGeometry","applyMatrix","matrix","normalMatrix","getNormalMatrix","i","il","length","vertex","applyMatrix4","face","normal","applyMatrix3","normalize","j","jl","vertexNormals","computeBoundingBox","computeBoundingSphere","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","fromBufferGeometry","geometry","scope","indices","index","array","undefined","attributes","position","console","error","positions","normals","color","uvs","uv","uvs2","uv2","push","fromArray","addFace","a","b","c","materialIndex","vertexColors","clone","groups","group","start","count","computeFaceNormals","center","getCenter","negate","radius","s","set","cb","ab","f","fl","vA","vB","vC","subVectors","cross","copy","computeVertexNormals","areaWeighted","v","vl","Array","add","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","dstNormalsFace","dstNormalsVertex","faceNormal","setFromPoints","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","colors1","colors2","vertexCopy","faceCopy","faceVertexNormals","faceVertexColors","faceVertexUvs2","uvsCopy","k","kl","mergeMesh","mesh","isMesh","matrixAutoUpdate","mergeVertices","verticesMap","unique","changes","key","precisionPoints","precision","Math","pow","round","faceIndicesToRemove","n","idx","splice","diff","points","l","point","sortFacesByMaterialIndex","_id","materialIndexSort","sort","uvs1","newUvs1","newUvs2","id","toJSON","data","metadata","version","generator","parameters","normalsHash","colorsHash","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","r","g","hasFaceVertexColor","faceType","setBit","getUvIndex","getNormalIndex","getColorIndex","enabled","hash","toString","getHex","source","morphTarget","morphNormal","srcVertexNormal","destVertexNormal","dispose","dispatchEvent"],"mappings":"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","sourcesContent":["import { EventDispatcher } from './EventDispatcher.js';\nimport { Face3 } from './Face3.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Box3 } from '../math/Box3.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Color } from '../math/Color.js';\nimport { Object3D } from './Object3D.js';\nimport { _Math } from '../math/Math.js';\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author bhouston / http://clara.io\n */\n\nvar _geometryId = 0; // Geometry uses even numbers as Id\nvar _m1 = new Matrix4();\nvar _obj = new Object3D();\nvar _offset = new Vector3();\n\nfunction Geometry() {\n\n\tObject.defineProperty( this, 'id', { value: _geometryId += 2 } );\n\n\tthis.uuid = _Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Geometry';\n\n\tthis.vertices = [];\n\tthis.colors = [];\n\tthis.faces = [];\n\tthis.faceVertexUvs = [[]];\n\n\tthis.morphTargets = [];\n\tthis.morphNormals = [];\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\tthis.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.elementsNeedUpdate = false;\n\tthis.verticesNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.lineDistancesNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n}\n\nGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: Geometry,\n\n\tisGeometry: true,\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.verticesNeedUpdate = true;\n\t\tthis.normalsNeedUpdate = true;\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function ( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateY: function ( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateZ: function ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function ( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix( _obj.matrix );\n\n\t\treturn this;\n\n\t},\n\n\tfromBufferGeometry: function ( geometry ) {\n\n\t\tvar scope = this;\n\n\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\tvar attributes = geometry.attributes;\n\n\t\tif ( attributes.position === undefined ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar positions = attributes.position.array;\n\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\n\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\tfor ( var i = 0; i < positions.length; i += 3 ) {\n\n\t\t\tscope.vertices.push( new Vector3().fromArray( positions, i ) );\n\n\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\tscope.colors.push( new Color().fromArray( colors, i ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\tvar vertexColors = ( colors === undefined ) ? [] : [\n\t\t\t\tscope.colors[ a ].clone(),\n\t\t\t\tscope.colors[ b ].clone(),\n\t\t\t\tscope.colors[ c ].clone() ];\n\n\t\t\tvar vertexNormals = ( normals === undefined ) ? [] : [\n\t\t\t\tnew Vector3().fromArray( normals, a * 3 ),\n\t\t\t\tnew Vector3().fromArray( normals, b * 3 ),\n\t\t\t\tnew Vector3().fromArray( normals, c * 3 )\n\t\t\t];\n\n\t\t\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\tscope.faces.push( face );\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [\n\t\t\t\t\tnew Vector2().fromArray( uvs, a * 2 ),\n\t\t\t\t\tnew Vector2().fromArray( uvs, b * 2 ),\n\t\t\t\t\tnew Vector2().fromArray( uvs, c * 2 )\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [\n\t\t\t\t\tnew Vector2().fromArray( uvs2, a * 2 ),\n\t\t\t\t\tnew Vector2().fromArray( uvs2, b * 2 ),\n\t\t\t\t\tnew Vector2().fromArray( uvs2, c * 2 )\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar groups = geometry.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\tvar start = group.start;\n\t\t\t\tvar count = group.count;\n\n\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\tif ( indices !== undefined ) {\n\n\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\taddFace( j, j + 1, j + 2, group.materialIndex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( indices !== undefined ) {\n\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeFaceNormals();\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\tthis.computeBoundingSphere();\n\n\t\tvar center = this.boundingSphere.center;\n\t\tvar radius = this.boundingSphere.radius;\n\n\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\tvar matrix = new Matrix4();\n\t\tmatrix.set(\n\t\t\ts, 0, 0, - s * center.x,\n\t\t\t0, s, 0, - s * center.y,\n\t\t\t0, 0, s, - s * center.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\tthis.applyMatrix( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tvar face = this.faces[ f ];\n\n\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\tvar vC = this.vertices[ face.c ];\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab );\n\n\t\t\tcb.normalize();\n\n\t\t\tface.normal.copy( cb );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\n\t\tvar v, vl, f, fl, face, vertices;\n\n\t\tvertices = new Array( this.vertices.length );\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ] = new Vector3();\n\n\t\t}\n\n\t\tif ( areaWeighted ) {\n\n\t\t\t// vertex normals weighted by triangle areas\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\tvar vA, vB, vC;\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ].normalize();\n\n\t\t}\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeFlatVertexNormals: function () {\n\n\t\tvar f, fl, face;\n\n\t\tthis.computeFaceNormals();\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\n\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\n\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\n\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\n\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeMorphNormals: function () {\n\n\t\tvar i, il, f, fl, face;\n\n\t\t// save original normals\n\t\t// - create temp variables on first access\n\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t} else {\n\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t}\n\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\tvar tmpGeo = new Geometry();\n\t\ttmpGeo.faces = this.faces;\n\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t// create on first access\n\n\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tfaceNormal = new Vector3();\n\t\t\t\t\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t// set vertices to morph target\n\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t// compute morph normals\n\n\t\t\ttmpGeo.computeFaceNormals();\n\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t// store morph normals\n\n\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore original normals\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t},\n\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\n\t\tif ( ! ( geometry && geometry.isGeometry ) ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar normalMatrix,\n\t\t\tvertexOffset = this.vertices.length,\n\t\t\tvertices1 = this.vertices,\n\t\t\tvertices2 = geometry.vertices,\n\t\t\tfaces1 = this.faces,\n\t\t\tfaces2 = geometry.faces,\n\t\t\tcolors1 = this.colors,\n\t\t\tcolors2 = geometry.colors;\n\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\tif ( matrix !== undefined ) {\n\n\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\tvertices1.push( vertexCopy );\n\n\t\t}\n\n\t\t// colors\n\n\t\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\n\n\t\t\tcolors1.push( colors2[ i ].clone() );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t}\n\n\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t}\n\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\tfaces1.push( faceCopy );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( var i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tvar faceVertexUvs2 = geometry.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) this.faceVertexUvs[ i ] = [];\n\n\t\t\tfor ( var j = 0, jl = faceVertexUvs2.length; j < jl; j ++ ) {\n\n\t\t\t\tvar uvs2 = faceVertexUvs2[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( var k = 0, kl = uvs2.length; k < kl; k ++ ) {\n\n\t\t\t\t\tuvsCopy.push( uvs2[ k ].clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tmergeMesh: function ( mesh ) {\n\n\t\tif ( ! ( mesh && mesh.isMesh ) ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( mesh.matrixAutoUpdate ) mesh.updateMatrix();\n\n\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t},\n\n\t/*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */\n\n\tmergeVertices: function () {\n\n\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\tvar unique = [], changes = [];\n\n\t\tvar v, key;\n\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\tvar i, il, face;\n\t\tvar indices, j, jl;\n\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tv = this.vertices[ i ];\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// if faces are completely degenerate after merging vertices, we\n\t\t// have to remove them from the geometry.\n\t\tvar faceIndicesToRemove = [];\n\n\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tface = this.faces[ i ];\n\n\t\t\tface.a = changes[ face.a ];\n\t\t\tface.b = changes[ face.b ];\n\t\t\tface.c = changes[ face.c ];\n\n\t\t\tindices = [ face.a, face.b, face.c ];\n\n\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t// we have to remove the face as nothing can be saved\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\tvar idx = faceIndicesToRemove[ i ];\n\n\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Use unique set of vertices\n\n\t\tvar diff = this.vertices.length - unique.length;\n\t\tthis.vertices = unique;\n\t\treturn diff;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.vertices = [];\n\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tvar point = points[ i ];\n\t\t\tthis.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsortFacesByMaterialIndex: function () {\n\n\t\tvar faces = this.faces;\n\t\tvar length = faces.length;\n\n\t\t// tag faces\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tfaces[ i ]._id = i;\n\n\t\t}\n\n\t\t// sort faces\n\n\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t}\n\n\t\tfaces.sort( materialIndexSort );\n\n\t\t// sort uvs\n\n\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\tvar newUvs1, newUvs2;\n\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tvar id = faces[ i ]._id;\n\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t}\n\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Geometry',\n\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Geometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tvar vertices = [];\n\n\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tvar faces = [];\n\t\tvar normals = [];\n\t\tvar normalsHash = {};\n\t\tvar colors = [];\n\t\tvar colorsHash = {};\n\t\tvar uvs = [];\n\t\tvar uvsHash = {};\n\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\n\t\t\tvar hasMaterial = true;\n\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\tvar faceType = 0;\n\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\tfaces.push( faceType );\n\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\tfaces.push( face.materialIndex );\n\n\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t}\n\n\t\tfunction getNormalIndex( normal ) {\n\n\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\treturn normalsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getColorIndex( color ) {\n\n\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\tcolors.push( color.getHex() );\n\n\t\t\treturn colorsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getUvIndex( uv ) {\n\n\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\treturn uvsHash[ hash ];\n\n\t\t}\n\n\t\tdata.data = {};\n\n\t\tdata.data.vertices = vertices;\n\t\tdata.data.normals = normals;\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\tdata.data.faces = faces;\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t // Handle primitives\n\n\t\t var parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t var values = [];\n\n\t\t for ( var key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t var geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n\t\treturn new Geometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tvar i, il, j, jl, k, kl;\n\n\t\t// reset\n\n\t\tthis.vertices = [];\n\t\tthis.colors = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [[]];\n\t\tthis.morphTargets = [];\n\t\tthis.morphNormals = [];\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\t\tthis.lineDistances = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// vertices\n\n\t\tvar vertices = source.vertices;\n\n\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t}\n\n\t\t// colors\n\n\t\tvar colors = source.colors;\n\n\t\tfor ( i = 0, il = colors.length; i < il; i ++ ) {\n\n\t\t\tthis.colors.push( colors[ i ].clone() );\n\n\t\t}\n\n\t\t// faces\n\n\t\tvar faces = source.faces;\n\n\t\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t}\n\n\t\t// face vertex uvs\n\n\t\tfor ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\tvar uv = uvs[ k ];\n\n\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tvar morphTargets = source.morphTargets;\n\n\t\tfor ( i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tvar morphTarget = {};\n\t\t\tmorphTarget.name = morphTargets[ i ].name;\n\n\t\t\t// vertices\n\n\t\t\tif ( morphTargets[ i ].vertices !== undefined ) {\n\n\t\t\t\tmorphTarget.vertices = [];\n\n\t\t\t\tfor ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normals\n\n\t\t\tif ( morphTargets[ i ].normals !== undefined ) {\n\n\t\t\t\tmorphTarget.normals = [];\n\n\t\t\t\tfor ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.push( morphTarget );\n\n\t\t}\n\n\t\t// morph normals\n\n\t\tvar morphNormals = source.morphNormals;\n\n\t\tfor ( i = 0, il = morphNormals.length; i < il; i ++ ) {\n\n\t\t\tvar morphNormal = {};\n\n\t\t\t// vertex normals\n\n\t\t\tif ( morphNormals[ i ].vertexNormals !== undefined ) {\n\n\t\t\t\tmorphNormal.vertexNormals = [];\n\n\t\t\t\tfor ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\n\t\t\t\t\tvar destVertexNormal = {};\n\n\t\t\t\t\tdestVertexNormal.a = srcVertexNormal.a.clone();\n\t\t\t\t\tdestVertexNormal.b = srcVertexNormal.b.clone();\n\t\t\t\t\tdestVertexNormal.c = srcVertexNormal.c.clone();\n\n\t\t\t\t\tmorphNormal.vertexNormals.push( destVertexNormal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// face normals\n\n\t\t\tif ( morphNormals[ i ].faceNormals !== undefined ) {\n\n\t\t\t\tmorphNormal.faceNormals = [];\n\n\t\t\t\tfor ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.morphNormals.push( morphNormal );\n\n\t\t}\n\n\t\t// skin weights\n\n\t\tvar skinWeights = source.skinWeights;\n\n\t\tfor ( i = 0, il = skinWeights.length; i < il; i ++ ) {\n\n\t\t\tthis.skinWeights.push( skinWeights[ i ].clone() );\n\n\t\t}\n\n\t\t// skin indices\n\n\t\tvar skinIndices = source.skinIndices;\n\n\t\tfor ( i = 0, il = skinIndices.length; i < il; i ++ ) {\n\n\t\t\tthis.skinIndices.push( skinIndices[ i ].clone() );\n\n\t\t}\n\n\t\t// line distances\n\n\t\tvar lineDistances = source.lineDistances;\n\n\t\tfor ( i = 0, il = lineDistances.length; i < il; i ++ ) {\n\n\t\t\tthis.lineDistances.push( lineDistances[ i ] );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tvar boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tvar boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// update flags\n\n\t\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\n\t\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\n\t\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\n\t\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\n\t\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n\t\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n\nexport { Geometry };\n"]},"metadata":{},"sourceType":"module"}