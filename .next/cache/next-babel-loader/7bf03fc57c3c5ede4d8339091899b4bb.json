{"ast":null,"code":"import _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  defines: { \"label\" : \"value\" },\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n *\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\nimport { Material } from './Material.js';\nimport { cloneUniforms } from '../renderers/shaders/UniformsUtils.js';\nimport default_vertex from '../renderers/shaders/ShaderChunk/default_vertex.glsl.js';\nimport default_fragment from '../renderers/shaders/ShaderChunk/default_fragment.glsl.js';\n\nfunction ShaderMaterial(parameters) {\n  Material.call(this);\n  this.type = 'ShaderMaterial';\n  this.defines = {};\n  this.uniforms = {};\n  this.vertexShader = default_vertex;\n  this.fragmentShader = default_fragment;\n  this.linewidth = 1;\n  this.wireframe = false;\n  this.wireframeLinewidth = 1;\n  this.fog = false; // set to use scene fog\n\n  this.lights = false; // set to use scene lights\n\n  this.clipping = false; // set to use user-defined clipping planes\n\n  this.skinning = false; // set to use skinning attribute streams\n\n  this.morphTargets = false; // set to use morph targets\n\n  this.morphNormals = false; // set to use morph normals\n\n  this.extensions = {\n    derivatives: false,\n    // set to use derivatives\n    fragDepth: false,\n    // set to use fragment depth values\n    drawBuffers: false,\n    // set to use draw buffers\n    shaderTextureLOD: false // set to use shader texture LOD\n\n  }; // When rendered geometry doesn't include these attributes but the material does,\n  // use these default values in WebGL. This avoids errors when buffer data is missing.\n\n  this.defaultAttributeValues = {\n    'color': [1, 1, 1],\n    'uv': [0, 0],\n    'uv2': [0, 0]\n  };\n  this.index0AttributeName = undefined;\n  this.uniformsNeedUpdate = false;\n\n  if (parameters !== undefined) {\n    if (parameters.attributes !== undefined) {\n      console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');\n    }\n\n    this.setValues(parameters);\n  }\n}\n\nShaderMaterial.prototype = _Object$create(Material.prototype);\nShaderMaterial.prototype.constructor = ShaderMaterial;\nShaderMaterial.prototype.isShaderMaterial = true;\n\nShaderMaterial.prototype.copy = function (source) {\n  Material.prototype.copy.call(this, source);\n  this.fragmentShader = source.fragmentShader;\n  this.vertexShader = source.vertexShader;\n  this.uniforms = cloneUniforms(source.uniforms);\n  this.defines = _Object$assign({}, source.defines);\n  this.wireframe = source.wireframe;\n  this.wireframeLinewidth = source.wireframeLinewidth;\n  this.lights = source.lights;\n  this.clipping = source.clipping;\n  this.skinning = source.skinning;\n  this.morphTargets = source.morphTargets;\n  this.morphNormals = source.morphNormals;\n  this.extensions = source.extensions;\n  return this;\n};\n\nShaderMaterial.prototype.toJSON = function (meta) {\n  var data = Material.prototype.toJSON.call(this, meta);\n  data.uniforms = {};\n\n  for (var name in this.uniforms) {\n    var uniform = this.uniforms[name];\n    var value = uniform.value;\n\n    if (value && value.isTexture) {\n      data.uniforms[name] = {\n        type: 't',\n        value: value.toJSON(meta).uuid\n      };\n    } else if (value && value.isColor) {\n      data.uniforms[name] = {\n        type: 'c',\n        value: value.getHex()\n      };\n    } else if (value && value.isVector2) {\n      data.uniforms[name] = {\n        type: 'v2',\n        value: value.toArray()\n      };\n    } else if (value && value.isVector3) {\n      data.uniforms[name] = {\n        type: 'v3',\n        value: value.toArray()\n      };\n    } else if (value && value.isVector4) {\n      data.uniforms[name] = {\n        type: 'v4',\n        value: value.toArray()\n      };\n    } else if (value && value.isMatrix3) {\n      data.uniforms[name] = {\n        type: 'm3',\n        value: value.toArray()\n      };\n    } else if (value && value.isMatrix4) {\n      data.uniforms[name] = {\n        type: 'm4',\n        value: value.toArray()\n      };\n    } else {\n      data.uniforms[name] = {\n        value: value\n      }; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n    }\n  }\n\n  if (_Object$keys(this.defines).length > 0) data.defines = this.defines;\n  data.vertexShader = this.vertexShader;\n  data.fragmentShader = this.fragmentShader;\n  var extensions = {};\n\n  for (var key in this.extensions) {\n    if (this.extensions[key] === true) extensions[key] = true;\n  }\n\n  if (_Object$keys(extensions).length > 0) data.extensions = extensions;\n  return data;\n};\n\nexport { ShaderMaterial };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/materials/ShaderMaterial.js"],"names":["Material","cloneUniforms","default_vertex","default_fragment","ShaderMaterial","parameters","call","type","defines","uniforms","vertexShader","fragmentShader","linewidth","wireframe","wireframeLinewidth","fog","lights","clipping","skinning","morphTargets","morphNormals","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","index0AttributeName","undefined","uniformsNeedUpdate","attributes","console","error","setValues","prototype","constructor","isShaderMaterial","copy","source","toJSON","meta","data","name","uniform","value","isTexture","uuid","isColor","getHex","isVector2","toArray","isVector3","isVector4","isMatrix3","isMatrix4","length","key"],"mappings":"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","sourcesContent":["/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  defines: { \"label\" : \"value\" },\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n *\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nimport { Material } from './Material.js';\nimport { cloneUniforms } from '../renderers/shaders/UniformsUtils.js';\n\nimport default_vertex from '../renderers/shaders/ShaderChunk/default_vertex.glsl.js';\nimport default_fragment from '../renderers/shaders/ShaderChunk/default_fragment.glsl.js';\n\nfunction ShaderMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'ShaderMaterial';\n\n\tthis.defines = {};\n\tthis.uniforms = {};\n\n\tthis.vertexShader = default_vertex;\n\tthis.fragmentShader = default_fragment;\n\n\tthis.linewidth = 1;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false; // set to use scene fog\n\tthis.lights = false; // set to use scene lights\n\tthis.clipping = false; // set to use user-defined clipping planes\n\n\tthis.skinning = false; // set to use skinning attribute streams\n\tthis.morphTargets = false; // set to use morph targets\n\tthis.morphNormals = false; // set to use morph normals\n\n\tthis.extensions = {\n\t\tderivatives: false, // set to use derivatives\n\t\tfragDepth: false, // set to use fragment depth values\n\t\tdrawBuffers: false, // set to use draw buffers\n\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t};\n\n\t// When rendered geometry doesn't include these attributes but the material does,\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\tthis.defaultAttributeValues = {\n\t\t'color': [ 1, 1, 1 ],\n\t\t'uv': [ 0, 0 ],\n\t\t'uv2': [ 0, 0 ]\n\t};\n\n\tthis.index0AttributeName = undefined;\n\tthis.uniformsNeedUpdate = false;\n\n\tif ( parameters !== undefined ) {\n\n\t\tif ( parameters.attributes !== undefined ) {\n\n\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n\nShaderMaterial.prototype = Object.create( Material.prototype );\nShaderMaterial.prototype.constructor = ShaderMaterial;\n\nShaderMaterial.prototype.isShaderMaterial = true;\n\nShaderMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.fragmentShader = source.fragmentShader;\n\tthis.vertexShader = source.vertexShader;\n\n\tthis.uniforms = cloneUniforms( source.uniforms );\n\n\tthis.defines = Object.assign( {}, source.defines );\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\tthis.lights = source.lights;\n\tthis.clipping = source.clipping;\n\n\tthis.skinning = source.skinning;\n\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\tthis.extensions = source.extensions;\n\n\treturn this;\n\n};\n\nShaderMaterial.prototype.toJSON = function ( meta ) {\n\n\tvar data = Material.prototype.toJSON.call( this, meta );\n\n\tdata.uniforms = {};\n\n\tfor ( var name in this.uniforms ) {\n\n\t\tvar uniform = this.uniforms[ name ];\n\t\tvar value = uniform.value;\n\n\t\tif ( value && value.isTexture ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 't',\n\t\t\t\tvalue: value.toJSON( meta ).uuid\n\t\t\t};\n\n\t\t} else if ( value && value.isColor ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'c',\n\t\t\t\tvalue: value.getHex()\n\t\t\t};\n\n\t\t} else if ( value && value.isVector2 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'v2',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isVector3 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'v3',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isVector4 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'v4',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isMatrix3 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'm3',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isMatrix4 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'm4',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\tvalue: value\n\t\t\t};\n\n\t\t\t// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n\n\t\t}\n\n\t}\n\n\tif ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;\n\n\tdata.vertexShader = this.vertexShader;\n\tdata.fragmentShader = this.fragmentShader;\n\n\tvar extensions = {};\n\n\tfor ( var key in this.extensions ) {\n\n\t\tif ( this.extensions[ key ] === true ) extensions[ key ] = true;\n\n\t}\n\n\tif ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;\n\n\treturn data;\n\n};\n\n\nexport { ShaderMaterial };\n"]},"metadata":{},"sourceType":"module"}