{"ast":null,"code":"import _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport { Mesh, OrthographicCamera, PlaneBufferGeometry, Scene, ShaderMaterial, UniformsUtils } from \"three/src/Three\";\nimport { Pass } from \"./Pass.js\";\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar ShaderPass = function (shader, textureID) {\n  Pass.call(this);\n  this.textureID = textureID !== undefined ? textureID : \"tDiffuse\";\n\n  if (shader instanceof ShaderMaterial) {\n    this.uniforms = shader.uniforms;\n    this.material = shader;\n  } else if (shader) {\n    this.uniforms = UniformsUtils.clone(shader.uniforms);\n    this.material = new ShaderMaterial({\n      defines: _Object$assign({}, shader.defines),\n      uniforms: this.uniforms,\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader\n    });\n  }\n\n  this.camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n  this.scene = new Scene();\n  this.quad = new Mesh(new PlaneBufferGeometry(2, 2), null);\n  this.quad.frustumCulled = false; // Avoid getting clipped\n\n  this.scene.add(this.quad);\n};\n\nShaderPass.prototype = _Object$assign(_Object$create(Pass.prototype), {\n  constructor: ShaderPass,\n  render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    if (this.uniforms[this.textureID]) {\n      this.uniforms[this.textureID].value = readBuffer.texture;\n    }\n\n    this.quad.material = this.material;\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      renderer.render(this.scene, this.camera);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n      renderer.render(this.scene, this.camera);\n    }\n  }\n});\nexport { ShaderPass };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/components/threejs-render/resources/postprocessing/ShaderPass.js"],"names":["ShaderPass","Pass","textureID","shader","UniformsUtils","defines","uniforms","vertexShader","fragmentShader","constructor","render","readBuffer","renderer"],"mappings":";;AAAA,SAAA,IAAA,EAAA,kBAAA,EAAA,mBAAA,EAAA,KAAA,EAAA,cAAA,EAAA,aAAA,QAAA,iBAAA;AAQA,SAAA,IAAA,QAAA,WAAA;AACA;;;;AAIA,IAAIA,UAAU,GAAG,UAAA,MAAA,EAAA,SAAA,EAA4B;AACzCC,EAAAA,IAAI,CAAJA,IAAAA,CAAAA,IAAAA;AAEA,OAAA,SAAA,GAAiBC,SAAS,KAATA,SAAAA,GAAAA,SAAAA,GAAjB,UAAA;;AAEA,MAAIC,MAAM,YAAV,cAAA,EAAsC;AAClC,SAAA,QAAA,GAAgBA,MAAM,CAAtB,QAAA;AAEA,SAAA,QAAA,GAAA,MAAA;AAHJ,GAAA,MAIO,IAAA,MAAA,EAAY;AACf,SAAA,QAAA,GAAgBC,aAAa,CAAbA,KAAAA,CAAoBD,MAAM,CAA1C,QAAgBC,CAAhB;AAEA,SAAA,QAAA,GAAgB,IAAA,cAAA,CAAmB;AAC/BC,MAAAA,OAAO,EAAE,cAAA,CAAA,EAAA,EAAkBF,MAAM,CADF,OACtB,CADsB;AAE/BG,MAAAA,QAAQ,EAAE,KAFqB,QAAA;AAG/BC,MAAAA,YAAY,EAAEJ,MAAM,CAHW,YAAA;AAI/BK,MAAAA,cAAc,EAAEL,MAAM,CAACK;AAJQ,KAAnB,CAAhB;AAMH;;AAED,OAAA,MAAA,GAAc,IAAA,kBAAA,CAAuB,CAAvB,CAAA,EAAA,CAAA,EAAA,CAAA,EAAiC,CAAjC,CAAA,EAAA,CAAA,EAAd,CAAc,CAAd;AACA,OAAA,KAAA,GAAa,IAAb,KAAa,EAAb;AAEA,OAAA,IAAA,GAAY,IAAA,IAAA,CAAS,IAAA,mBAAA,CAAA,CAAA,EAAT,CAAS,CAAT,EAAZ,IAAY,CAAZ;AACA,OAAA,IAAA,CAAA,aAAA,GAxByC,KAwBzC,CAxByC,CAwBR;;AACjC,OAAA,KAAA,CAAA,GAAA,CAAe,KAAf,IAAA;AAzBJ,CAAA;;AA4BAR,UAAU,CAAVA,SAAAA,GAAuB,cAAA,CAAc,cAAA,CAAcC,IAAI,CAAhC,SAAc,CAAd,EAA6C;AAChEQ,EAAAA,WAAW,EADqD,UAAA;AAGhEC,EAAAA,MAAM,EAAE,UAAA,QAAA,EAAA,WAAA,EAAA,UAAA,EAAA,SAAA,EAAA,UAAA,EAAmE;AACvE,QAAI,KAAA,QAAA,CAAc,KAAlB,SAAI,CAAJ,EAAmC;AAC/B,WAAA,QAAA,CAAc,KAAd,SAAA,EAAA,KAAA,GAAsCC,UAAU,CAAhD,OAAA;AACH;;AAED,SAAA,IAAA,CAAA,QAAA,GAAqB,KAArB,QAAA;;AAEA,QAAI,KAAJ,cAAA,EAAyB;AACrBC,MAAAA,QAAQ,CAARA,eAAAA,CAAAA,IAAAA;AACAA,MAAAA,QAAQ,CAARA,MAAAA,CAAgB,KAAhBA,KAAAA,EAA4B,KAA5BA,MAAAA;AAFJ,KAAA,MAGO;AACHA,MAAAA,QAAQ,CAARA,eAAAA,CAAAA,WAAAA;AACA,UAAI,KAAJ,KAAA,EAAgBA,QAAQ,CAARA,KAAAA;AAChBA,MAAAA,QAAQ,CAARA,MAAAA,CAAgB,KAAhBA,KAAAA,EAA4B,KAA5BA,MAAAA;AACH;AACJ;AAlB+D,CAA7C,CAAvBZ;AAqBA,SAAA,UAAA","sourcesContent":["import {\n    Mesh,\n    OrthographicCamera,\n    PlaneBufferGeometry,\n    Scene,\n    ShaderMaterial,\n    UniformsUtils\n} from \"three/src/Three\";\nimport { Pass } from \"./Pass.js\";\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar ShaderPass = function(shader, textureID) {\n    Pass.call(this);\n\n    this.textureID = textureID !== undefined ? textureID : \"tDiffuse\";\n\n    if (shader instanceof ShaderMaterial) {\n        this.uniforms = shader.uniforms;\n\n        this.material = shader;\n    } else if (shader) {\n        this.uniforms = UniformsUtils.clone(shader.uniforms);\n\n        this.material = new ShaderMaterial({\n            defines: Object.assign({}, shader.defines),\n            uniforms: this.uniforms,\n            vertexShader: shader.vertexShader,\n            fragmentShader: shader.fragmentShader\n        });\n    }\n\n    this.camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    this.scene = new Scene();\n\n    this.quad = new Mesh(new PlaneBufferGeometry(2, 2), null);\n    this.quad.frustumCulled = false; // Avoid getting clipped\n    this.scene.add(this.quad);\n};\n\nShaderPass.prototype = Object.assign(Object.create(Pass.prototype), {\n    constructor: ShaderPass,\n\n    render: function(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n        if (this.uniforms[this.textureID]) {\n            this.uniforms[this.textureID].value = readBuffer.texture;\n        }\n\n        this.quad.material = this.material;\n\n        if (this.renderToScreen) {\n            renderer.setRenderTarget(null);\n            renderer.render(this.scene, this.camera);\n        } else {\n            renderer.setRenderTarget(writeBuffer);\n            if (this.clear) renderer.clear();\n            renderer.render(this.scene, this.camera);\n        }\n    }\n});\n\nexport { ShaderPass };\n"]},"metadata":{},"sourceType":"module"}