{"ast":null,"code":"import _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\n\n/**\n * @author oosmoxiecode\n * @author Mugen87 / https://github.com/Mugen87\n *\n * based on http://www.blackpawn.com/texts/pqtorus/\n */\nimport { Geometry } from '../core/Geometry.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js'; // TorusKnotGeometry\n\nfunction TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {\n  Geometry.call(this);\n  this.type = 'TorusKnotGeometry';\n  this.parameters = {\n    radius: radius,\n    tube: tube,\n    tubularSegments: tubularSegments,\n    radialSegments: radialSegments,\n    p: p,\n    q: q\n  };\n  if (heightScale !== undefined) console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');\n  this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));\n  this.mergeVertices();\n}\n\nTorusKnotGeometry.prototype = _Object$create(Geometry.prototype);\nTorusKnotGeometry.prototype.constructor = TorusKnotGeometry; // TorusKnotBufferGeometry\n\nfunction TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {\n  BufferGeometry.call(this);\n  this.type = 'TorusKnotBufferGeometry';\n  this.parameters = {\n    radius: radius,\n    tube: tube,\n    tubularSegments: tubularSegments,\n    radialSegments: radialSegments,\n    p: p,\n    q: q\n  };\n  radius = radius || 1;\n  tube = tube || 0.4;\n  tubularSegments = Math.floor(tubularSegments) || 64;\n  radialSegments = Math.floor(radialSegments) || 8;\n  p = p || 2;\n  q = q || 3; // buffers\n\n  var indices = [];\n  var vertices = [];\n  var normals = [];\n  var uvs = []; // helper variables\n\n  var i, j;\n  var vertex = new Vector3();\n  var normal = new Vector3();\n  var P1 = new Vector3();\n  var P2 = new Vector3();\n  var B = new Vector3();\n  var T = new Vector3();\n  var N = new Vector3(); // generate vertices, normals and uvs\n\n  for (i = 0; i <= tubularSegments; ++i) {\n    // the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n    var u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n    // these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n    calculatePositionOnCurve(u, p, q, radius, P1);\n    calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis\n\n    T.subVectors(P2, P1);\n    N.addVectors(P2, P1);\n    B.crossVectors(T, N);\n    N.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it\n\n    B.normalize();\n    N.normalize();\n\n    for (j = 0; j <= radialSegments; ++j) {\n      // now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n      // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n      var v = j / radialSegments * Math.PI * 2;\n      var cx = -tube * Math.cos(v);\n      var cy = tube * Math.sin(v); // now calculate the final vertex position.\n      // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n      vertex.x = P1.x + (cx * N.x + cy * B.x);\n      vertex.y = P1.y + (cx * N.y + cy * B.y);\n      vertex.z = P1.z + (cx * N.z + cy * B.z);\n      vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n      normal.subVectors(vertex, P1).normalize();\n      normals.push(normal.x, normal.y, normal.z); // uv\n\n      uvs.push(i / tubularSegments);\n      uvs.push(j / radialSegments);\n    }\n  } // generate indices\n\n\n  for (j = 1; j <= tubularSegments; j++) {\n    for (i = 1; i <= radialSegments; i++) {\n      // indices\n      var a = (radialSegments + 1) * (j - 1) + (i - 1);\n      var b = (radialSegments + 1) * j + (i - 1);\n      var c = (radialSegments + 1) * j + i;\n      var d = (radialSegments + 1) * (j - 1) + i; // faces\n\n      indices.push(a, b, d);\n      indices.push(b, c, d);\n    }\n  } // build geometry\n\n\n  this.setIndex(indices);\n  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n  this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve\n\n  function calculatePositionOnCurve(u, p, q, radius, position) {\n    var cu = Math.cos(u);\n    var su = Math.sin(u);\n    var quOverP = q / p * u;\n    var cs = Math.cos(quOverP);\n    position.x = radius * (2 + cs) * 0.5 * cu;\n    position.y = radius * (2 + cs) * su * 0.5;\n    position.z = radius * Math.sin(quOverP) * 0.5;\n  }\n}\n\nTorusKnotBufferGeometry.prototype = _Object$create(BufferGeometry.prototype);\nTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\nexport { TorusKnotGeometry, TorusKnotBufferGeometry };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/geometries/TorusKnotGeometry.js"],"names":["Geometry","BufferGeometry","Float32BufferAttribute","Vector3","TorusKnotGeometry","radius","tube","tubularSegments","radialSegments","p","q","heightScale","call","type","parameters","undefined","console","warn","fromBufferGeometry","TorusKnotBufferGeometry","mergeVertices","prototype","constructor","Math","floor","indices","vertices","normals","uvs","i","j","vertex","normal","P1","P2","B","T","N","u","PI","calculatePositionOnCurve","subVectors","addVectors","crossVectors","normalize","v","cx","cos","cy","sin","x","y","z","push","a","b","c","d","setIndex","setAttribute","position","cu","su","quOverP","cs"],"mappings":"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","sourcesContent":["/**\n * @author oosmoxiecode\n * @author Mugen87 / https://github.com/Mugen87\n *\n * based on http://www.blackpawn.com/texts/pqtorus/\n */\n\nimport { Geometry } from '../core/Geometry.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\n// TorusKnotGeometry\n\nfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'TorusKnotGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\ttubularSegments: tubularSegments,\n\t\tradialSegments: radialSegments,\n\t\tp: p,\n\t\tq: q\n\t};\n\n\tif ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\n\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\tthis.mergeVertices();\n\n}\n\nTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\nTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\n\n// TorusKnotBufferGeometry\n\nfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'TorusKnotBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\ttubularSegments: tubularSegments,\n\t\tradialSegments: radialSegments,\n\t\tp: p,\n\t\tq: q\n\t};\n\n\tradius = radius || 1;\n\ttube = tube || 0.4;\n\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\tp = p || 2;\n\tq = q || 3;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar i, j;\n\n\tvar vertex = new Vector3();\n\tvar normal = new Vector3();\n\n\tvar P1 = new Vector3();\n\tvar P2 = new Vector3();\n\n\tvar B = new Vector3();\n\tvar T = new Vector3();\n\tvar N = new Vector3();\n\n\t// generate vertices, normals and uvs\n\n\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t// calculate orthonormal basis\n\n\t\tT.subVectors( P2, P1 );\n\t\tN.addVectors( P2, P1 );\n\t\tB.crossVectors( T, N );\n\t\tN.crossVectors( B, T );\n\n\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\tB.normalize();\n\t\tN.normalize();\n\n\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\tvar cy = tube * Math.sin( v );\n\n\t\t\t// now calculate the final vertex position.\n\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t// uv\n\n\t\t\tuvs.push( i / tubularSegments );\n\t\t\tuvs.push( j / radialSegments );\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t// indices\n\n\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t// faces\n\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t// this function calculates the current position on the torus curve\n\n\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\tvar cu = Math.cos( u );\n\t\tvar su = Math.sin( u );\n\t\tvar quOverP = q / p * u;\n\t\tvar cs = Math.cos( quOverP );\n\n\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t}\n\n}\n\nTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\n\n\nexport { TorusKnotGeometry, TorusKnotBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}