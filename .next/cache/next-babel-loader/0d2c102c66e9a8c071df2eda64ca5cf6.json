{"ast":null,"code":"import _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nfunction WireframeGeometry(geometry) {\n  BufferGeometry.call(this);\n  this.type = 'WireframeGeometry'; // buffer\n\n  var vertices = []; // helper variables\n\n  var i, j, l, o, ol;\n  var edge = [0, 0],\n      edges = {},\n      e,\n      edge1,\n      edge2;\n  var key,\n      keys = ['a', 'b', 'c'];\n  var vertex; // different logic for Geometry and BufferGeometry\n\n  if (geometry && geometry.isGeometry) {\n    // create a data structure that contains all edges without duplicates\n    var faces = geometry.faces;\n\n    for (i = 0, l = faces.length; i < l; i++) {\n      var face = faces[i];\n\n      for (j = 0; j < 3; j++) {\n        edge1 = face[keys[j]];\n        edge2 = face[keys[(j + 1) % 3]];\n        edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates\n\n        edge[1] = Math.max(edge1, edge2);\n        key = edge[0] + ',' + edge[1];\n\n        if (edges[key] === undefined) {\n          edges[key] = {\n            index1: edge[0],\n            index2: edge[1]\n          };\n        }\n      }\n    } // generate vertices\n\n\n    for (key in edges) {\n      e = edges[key];\n      vertex = geometry.vertices[e.index1];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n      vertex = geometry.vertices[e.index2];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n  } else if (geometry && geometry.isBufferGeometry) {\n    var position, indices, groups;\n    var group, start, count;\n    var index1, index2;\n    vertex = new Vector3();\n\n    if (geometry.index !== null) {\n      // indexed BufferGeometry\n      position = geometry.attributes.position;\n      indices = geometry.index;\n      groups = geometry.groups;\n\n      if (groups.length === 0) {\n        groups = [{\n          start: 0,\n          count: indices.count,\n          materialIndex: 0\n        }];\n      } // create a data structure that contains all eges without duplicates\n\n\n      for (o = 0, ol = groups.length; o < ol; ++o) {\n        group = groups[o];\n        start = group.start;\n        count = group.count;\n\n        for (i = start, l = start + count; i < l; i += 3) {\n          for (j = 0; j < 3; j++) {\n            edge1 = indices.getX(i + j);\n            edge2 = indices.getX(i + (j + 1) % 3);\n            edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates\n\n            edge[1] = Math.max(edge1, edge2);\n            key = edge[0] + ',' + edge[1];\n\n            if (edges[key] === undefined) {\n              edges[key] = {\n                index1: edge[0],\n                index2: edge[1]\n              };\n            }\n          }\n        }\n      } // generate vertices\n\n\n      for (key in edges) {\n        e = edges[key];\n        vertex.fromBufferAttribute(position, e.index1);\n        vertices.push(vertex.x, vertex.y, vertex.z);\n        vertex.fromBufferAttribute(position, e.index2);\n        vertices.push(vertex.x, vertex.y, vertex.z);\n      }\n    } else {\n      // non-indexed BufferGeometry\n      position = geometry.attributes.position;\n\n      for (i = 0, l = position.count / 3; i < l; i++) {\n        for (j = 0; j < 3; j++) {\n          // three edges per triangle, an edge is represented as (index1, index2)\n          // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n          index1 = 3 * i + j;\n          vertex.fromBufferAttribute(position, index1);\n          vertices.push(vertex.x, vertex.y, vertex.z);\n          index2 = 3 * i + (j + 1) % 3;\n          vertex.fromBufferAttribute(position, index2);\n          vertices.push(vertex.x, vertex.y, vertex.z);\n        }\n      }\n    }\n  } // build geometry\n\n\n  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n}\n\nWireframeGeometry.prototype = _Object$create(BufferGeometry.prototype);\nWireframeGeometry.prototype.constructor = WireframeGeometry;\nexport { WireframeGeometry };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/geometries/WireframeGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector3","WireframeGeometry","geometry","call","type","vertices","i","j","l","o","ol","edge","edges","e","edge1","edge2","key","keys","vertex","isGeometry","faces","length","face","Math","min","max","undefined","index1","index2","push","x","y","z","isBufferGeometry","position","indices","groups","group","start","count","index","attributes","materialIndex","getX","fromBufferAttribute","setAttribute","prototype","constructor"],"mappings":"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","sourcesContent":["/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nfunction WireframeGeometry( geometry ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'WireframeGeometry';\n\n\t// buffer\n\n\tvar vertices = [];\n\n\t// helper variables\n\n\tvar i, j, l, o, ol;\n\tvar edge = [ 0, 0 ], edges = {}, e, edge1, edge2;\n\tvar key, keys = [ 'a', 'b', 'c' ];\n\tvar vertex;\n\n\t// different logic for Geometry and BufferGeometry\n\n\tif ( geometry && geometry.isGeometry ) {\n\n\t\t// create a data structure that contains all edges without duplicates\n\n\t\tvar faces = geometry.faces;\n\n\t\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\tedge1 = face[ keys[ j ] ];\n\t\t\t\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\n\t\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\n\t\t\t\tkey = edge[ 0 ] + ',' + edge[ 1 ];\n\n\t\t\t\tif ( edges[ key ] === undefined ) {\n\n\t\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate vertices\n\n\t\tfor ( key in edges ) {\n\n\t\t\te = edges[ key ];\n\n\t\t\tvertex = geometry.vertices[ e.index1 ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\tvertex = geometry.vertices[ e.index2 ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t} else if ( geometry && geometry.isBufferGeometry ) {\n\n\t\tvar position, indices, groups;\n\t\tvar group, start, count;\n\t\tvar index1, index2;\n\n\t\tvertex = new Vector3();\n\n\t\tif ( geometry.index !== null ) {\n\n\t\t\t// indexed BufferGeometry\n\n\t\t\tposition = geometry.attributes.position;\n\t\t\tindices = geometry.index;\n\t\t\tgroups = geometry.groups;\n\n\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\n\n\t\t\t}\n\n\t\t\t// create a data structure that contains all eges without duplicates\n\n\t\t\tfor ( o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\tgroup = groups[ o ];\n\n\t\t\t\tstart = group.start;\n\t\t\t\tcount = group.count;\n\n\t\t\t\tfor ( i = start, l = ( start + count ); i < l; i += 3 ) {\n\n\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tedge1 = indices.getX( i + j );\n\t\t\t\t\t\tedge2 = indices.getX( i + ( j + 1 ) % 3 );\n\t\t\t\t\t\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\n\t\t\t\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\n\t\t\t\t\t\tkey = edge[ 0 ] + ',' + edge[ 1 ];\n\n\t\t\t\t\t\tif ( edges[ key ] === undefined ) {\n\n\t\t\t\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// generate vertices\n\n\t\t\tfor ( key in edges ) {\n\n\t\t\t\te = edges[ key ];\n\n\t\t\t\tvertex.fromBufferAttribute( position, e.index1 );\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\tvertex.fromBufferAttribute( position, e.index2 );\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// non-indexed BufferGeometry\n\n\t\t\tposition = geometry.attributes.position;\n\n\t\t\tfor ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\n\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\n\t\t\t\t\tindex1 = 3 * i + j;\n\t\t\t\t\tvertex.fromBufferAttribute( position, index1 );\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\tindex2 = 3 * i + ( ( j + 1 ) % 3 );\n\t\t\t\t\tvertex.fromBufferAttribute( position, index2 );\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n}\n\nWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\nWireframeGeometry.prototype.constructor = WireframeGeometry;\n\n\nexport { WireframeGeometry };\n"]},"metadata":{},"sourceType":"module"}