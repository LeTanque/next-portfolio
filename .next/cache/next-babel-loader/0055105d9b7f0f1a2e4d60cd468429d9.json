{"ast":null,"code":"import _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\nimport { EventDispatcher } from '../core/EventDispatcher.js';\nimport { MirroredRepeatWrapping, ClampToEdgeWrapping, RepeatWrapping, LinearEncoding, UnsignedByteType, RGBAFormat, LinearMipmapLinearFilter, LinearFilter, UVMapping } from '../constants.js';\nimport { _Math } from '../math/Math.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { ImageUtils } from '../extras/ImageUtils.js';\nvar textureId = 0;\n\nfunction Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {\n  _Object$defineProperty(this, 'id', {\n    value: textureId++\n  });\n\n  this.uuid = _Math.generateUUID();\n  this.name = '';\n  this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\n  this.mipmaps = [];\n  this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\n  this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\n  this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\n  this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n  this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;\n  this.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n  this.format = format !== undefined ? format : RGBAFormat;\n  this.internalFormat = null;\n  this.type = type !== undefined ? type : UnsignedByteType;\n  this.offset = new Vector2(0, 0);\n  this.repeat = new Vector2(1, 1);\n  this.center = new Vector2(0, 0);\n  this.rotation = 0;\n  this.matrixAutoUpdate = true;\n  this.matrix = new Matrix3();\n  this.generateMipmaps = true;\n  this.premultiplyAlpha = false;\n  this.flipY = true;\n  this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n  // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n  //\n  // Also changing the encoding after already used by a Material will not automatically make the Material\n  // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\n  this.encoding = encoding !== undefined ? encoding : LinearEncoding;\n  this.version = 0;\n  this.onUpdate = null;\n}\n\nTexture.DEFAULT_IMAGE = undefined;\nTexture.DEFAULT_MAPPING = UVMapping;\nTexture.prototype = _Object$assign(_Object$create(EventDispatcher.prototype), {\n  constructor: Texture,\n  isTexture: true,\n  updateMatrix: function () {\n    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\n  },\n  clone: function () {\n    return new this.constructor().copy(this);\n  },\n  copy: function (source) {\n    this.name = source.name;\n    this.image = source.image;\n    this.mipmaps = source.mipmaps.slice(0);\n    this.mapping = source.mapping;\n    this.wrapS = source.wrapS;\n    this.wrapT = source.wrapT;\n    this.magFilter = source.magFilter;\n    this.minFilter = source.minFilter;\n    this.anisotropy = source.anisotropy;\n    this.format = source.format;\n    this.internalFormat = source.internalFormat;\n    this.type = source.type;\n    this.offset.copy(source.offset);\n    this.repeat.copy(source.repeat);\n    this.center.copy(source.center);\n    this.rotation = source.rotation;\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrix.copy(source.matrix);\n    this.generateMipmaps = source.generateMipmaps;\n    this.premultiplyAlpha = source.premultiplyAlpha;\n    this.flipY = source.flipY;\n    this.unpackAlignment = source.unpackAlignment;\n    this.encoding = source.encoding;\n    return this;\n  },\n  toJSON: function (meta) {\n    var isRootObject = meta === undefined || typeof meta === 'string';\n\n    if (!isRootObject && meta.textures[this.uuid] !== undefined) {\n      return meta.textures[this.uuid];\n    }\n\n    var output = {\n      metadata: {\n        version: 4.5,\n        type: 'Texture',\n        generator: 'Texture.toJSON'\n      },\n      uuid: this.uuid,\n      name: this.name,\n      mapping: this.mapping,\n      repeat: [this.repeat.x, this.repeat.y],\n      offset: [this.offset.x, this.offset.y],\n      center: [this.center.x, this.center.y],\n      rotation: this.rotation,\n      wrap: [this.wrapS, this.wrapT],\n      format: this.format,\n      type: this.type,\n      encoding: this.encoding,\n      minFilter: this.minFilter,\n      magFilter: this.magFilter,\n      anisotropy: this.anisotropy,\n      flipY: this.flipY,\n      premultiplyAlpha: this.premultiplyAlpha,\n      unpackAlignment: this.unpackAlignment\n    };\n\n    if (this.image !== undefined) {\n      // TODO: Move to THREE.Image\n      var image = this.image;\n\n      if (image.uuid === undefined) {\n        image.uuid = _Math.generateUUID(); // UGH\n      }\n\n      if (!isRootObject && meta.images[image.uuid] === undefined) {\n        var url;\n\n        if (_Array$isArray(image)) {\n          // process array of images e.g. CubeTexture\n          url = [];\n\n          for (var i = 0, l = image.length; i < l; i++) {\n            url.push(ImageUtils.getDataURL(image[i]));\n          }\n        } else {\n          // process single image\n          url = ImageUtils.getDataURL(image);\n        }\n\n        meta.images[image.uuid] = {\n          uuid: image.uuid,\n          url: url\n        };\n      }\n\n      output.image = image.uuid;\n    }\n\n    if (!isRootObject) {\n      meta.textures[this.uuid] = output;\n    }\n\n    return output;\n  },\n  dispose: function () {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  },\n  transformUv: function (uv) {\n    if (this.mapping !== UVMapping) return uv;\n    uv.applyMatrix3(this.matrix);\n\n    if (uv.x < 0 || uv.x > 1) {\n      switch (this.wrapS) {\n        case RepeatWrapping:\n          uv.x = uv.x - Math.floor(uv.x);\n          break;\n\n        case ClampToEdgeWrapping:\n          uv.x = uv.x < 0 ? 0 : 1;\n          break;\n\n        case MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n            uv.x = Math.ceil(uv.x) - uv.x;\n          } else {\n            uv.x = uv.x - Math.floor(uv.x);\n          }\n\n          break;\n      }\n    }\n\n    if (uv.y < 0 || uv.y > 1) {\n      switch (this.wrapT) {\n        case RepeatWrapping:\n          uv.y = uv.y - Math.floor(uv.y);\n          break;\n\n        case ClampToEdgeWrapping:\n          uv.y = uv.y < 0 ? 0 : 1;\n          break;\n\n        case MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n            uv.y = Math.ceil(uv.y) - uv.y;\n          } else {\n            uv.y = uv.y - Math.floor(uv.y);\n          }\n\n          break;\n      }\n    }\n\n    if (this.flipY) {\n      uv.y = 1 - uv.y;\n    }\n\n    return uv;\n  }\n});\n\n_Object$defineProperty(Texture.prototype, \"needsUpdate\", {\n  set: function (value) {\n    if (value === true) this.version++;\n  }\n});\n\nexport { Texture };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/textures/Texture.js"],"names":["EventDispatcher","MirroredRepeatWrapping","ClampToEdgeWrapping","RepeatWrapping","LinearEncoding","UnsignedByteType","RGBAFormat","LinearMipmapLinearFilter","LinearFilter","UVMapping","_Math","Vector2","Matrix3","ImageUtils","textureId","Texture","image","mapping","wrapS","wrapT","magFilter","minFilter","format","type","anisotropy","encoding","value","uuid","generateUUID","name","undefined","DEFAULT_IMAGE","mipmaps","DEFAULT_MAPPING","internalFormat","offset","repeat","center","rotation","matrixAutoUpdate","matrix","generateMipmaps","premultiplyAlpha","flipY","unpackAlignment","version","onUpdate","prototype","constructor","isTexture","updateMatrix","setUvTransform","x","y","clone","copy","source","slice","toJSON","meta","isRootObject","textures","output","metadata","generator","wrap","images","url","i","l","length","push","getDataURL","dispose","dispatchEvent","transformUv","uv","applyMatrix3","Math","floor","abs","ceil","set"],"mappings":"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","sourcesContent":["/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nimport { EventDispatcher } from '../core/EventDispatcher.js';\nimport {\n\tMirroredRepeatWrapping,\n\tClampToEdgeWrapping,\n\tRepeatWrapping,\n\tLinearEncoding,\n\tUnsignedByteType,\n\tRGBAFormat,\n\tLinearMipmapLinearFilter,\n\tLinearFilter,\n\tUVMapping\n} from '../constants.js';\nimport { _Math } from '../math/Math.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { ImageUtils } from '../extras/ImageUtils.js';\n\nvar textureId = 0;\n\nfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\tObject.defineProperty( this, 'id', { value: textureId ++ } );\n\n\tthis.uuid = _Math.generateUUID();\n\n\tthis.name = '';\n\n\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\n\tthis.mipmaps = [];\n\n\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\n\n\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\n\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;\n\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\tthis.format = format !== undefined ? format : RGBAFormat;\n\tthis.internalFormat = null;\n\tthis.type = type !== undefined ? type : UnsignedByteType;\n\n\tthis.offset = new Vector2( 0, 0 );\n\tthis.repeat = new Vector2( 1, 1 );\n\tthis.center = new Vector2( 0, 0 );\n\tthis.rotation = 0;\n\n\tthis.matrixAutoUpdate = true;\n\tthis.matrix = new Matrix3();\n\n\tthis.generateMipmaps = true;\n\tthis.premultiplyAlpha = false;\n\tthis.flipY = true;\n\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t//\n\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\tthis.encoding = encoding !== undefined ? encoding : LinearEncoding;\n\n\tthis.version = 0;\n\tthis.onUpdate = null;\n\n}\n\nTexture.DEFAULT_IMAGE = undefined;\nTexture.DEFAULT_MAPPING = UVMapping;\n\nTexture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: Texture,\n\n\tisTexture: true,\n\n\tupdateMatrix: function () {\n\n\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.image = source.image;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.internalFormat = source.internalFormat;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\t\tthis.center.copy( source.center );\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrix.copy( source.matrix );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.encoding = source.encoding;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tvar output = {\n\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\tmapping: this.mapping,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\trotation: this.rotation,\n\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tformat: this.format,\n\t\t\ttype: this.type,\n\t\t\tencoding: this.encoding,\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy,\n\n\t\t\tflipY: this.flipY,\n\n\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\tunpackAlignment: this.unpackAlignment\n\n\t\t};\n\n\t\tif ( this.image !== undefined ) {\n\n\t\t\t// TODO: Move to THREE.Image\n\n\t\t\tvar image = this.image;\n\n\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\timage.uuid = _Math.generateUUID(); // UGH\n\n\t\t\t}\n\n\t\t\tif ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\tvar url;\n\n\t\t\t\tif ( Array.isArray( image ) ) {\n\n\t\t\t\t\t// process array of images e.g. CubeTexture\n\n\t\t\t\t\turl = [];\n\n\t\t\t\t\tfor ( var i = 0, l = image.length; i < l; i ++ ) {\n\n\t\t\t\t\t\turl.push( ImageUtils.getDataURL( image[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// process single image\n\n\t\t\t\t\turl = ImageUtils.getDataURL( image );\n\n\t\t\t\t}\n\n\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\turl: url\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\toutput.image = image.uuid;\n\n\t\t}\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t},\n\n\ttransformUv: function ( uv ) {\n\n\t\tif ( this.mapping !== UVMapping ) return uv;\n\n\t\tuv.applyMatrix3( this.matrix );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t\treturn uv;\n\n\t}\n\n} );\n\nObject.defineProperty( Texture.prototype, \"needsUpdate\", {\n\n\tset: function ( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n} );\n\n\nexport { Texture };\n"]},"metadata":{},"sourceType":"module"}