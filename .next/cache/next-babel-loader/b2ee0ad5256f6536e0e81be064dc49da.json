{"ast":null,"code":"/**\n * @author felixturner / http://airtight.cc/\n *\n * RGB Shift Shader\n * Shifts red and blue channels from center in opposite directions\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n * by Tom Butterworth / http://kriss.cx/tom/\n *\n * amount: shift distance (1 is width of input)\n * angle: shift angle in radians\n */\nvar DigitalGlitch = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    //diffuse texture\n    tDisp: {\n      value: null\n    },\n    //displacement texture for digital glitch squares\n    byp: {\n      value: 0\n    },\n    //apply the glitch ?\n    amount: {\n      value: 0.08\n    },\n    angle: {\n      value: 0.02\n    },\n    seed: {\n      value: 0.02\n    },\n    seed_x: {\n      value: 0.02\n    },\n    //-1,1\n    seed_y: {\n      value: 0.02\n    },\n    //-1,1\n    distortion_x: {\n      value: 0.5\n    },\n    distortion_y: {\n      value: 0.6\n    },\n    col_s: {\n      value: 0.05\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform int byp;\", //should we apply the glitch ?\n  \"uniform sampler2D tDiffuse;\", \"uniform sampler2D tDisp;\", \"uniform float amount;\", \"uniform float angle;\", \"uniform float seed;\", \"uniform float seed_x;\", \"uniform float seed_y;\", \"uniform float distortion_x;\", \"uniform float distortion_y;\", \"uniform float col_s;\", \"varying vec2 vUv;\", \"float rand(vec2 co){\", \"return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\", \"}\", \"void main() {\", \"if(byp<1) {\", \"vec2 p = vUv;\", \"float xs = floor(gl_FragCoord.x / 0.5);\", \"float ys = floor(gl_FragCoord.y / 0.5);\", //based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\n  \"vec4 normal = texture2D (tDisp, p*seed*seed);\", \"if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {\", \"if(seed_x>0.){\", \"p.y = 1. - (p.y + distortion_y);\", \"}\", \"else {\", \"p.y = distortion_y;\", \"}\", \"}\", \"if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {\", \"if(seed_y>0.){\", \"p.x=distortion_x;\", \"}\", \"else {\", \"p.x = 1. - (p.x + distortion_x);\", \"}\", \"}\", \"p.x+=normal.x*seed_x*(seed/5.);\", \"p.y+=normal.y*seed_y*(seed/5.);\", //base from RGB shift shader\n  \"vec2 offset = amount * vec2( cos(angle), sin(angle));\", \"vec4 cr = texture2D(tDiffuse, p + offset);\", \"vec4 cga = texture2D(tDiffuse, p);\", \"vec4 cb = texture2D(tDiffuse, p - offset);\", \"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\", //add noise\n  \"vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.05);\", \"gl_FragColor = gl_FragColor+ snow;\", \"}\", \"else {\", \"gl_FragColor=texture2D (tDiffuse, vUv);\", \"}\", \"}\"].join(\"\\n\")\n};\nexport { DigitalGlitch };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/components/threejs-render/resources/shaders/DigitalGlitch.js"],"names":["DigitalGlitch","uniforms","tDiffuse","value","tDisp","byp","amount","angle","seed","seed_x","seed_y","distortion_x","distortion_y","col_s","vertexShader","fragmentShader"],"mappings":"AAAA;;;;;;;;;;;AAYA,IAAIA,aAAa,GAAG;AAChBC,EAAAA,QAAQ,EAAE;AACNC,IAAAA,QAAQ,EAAE;AAAEC,MAAAA,KAAK,EAAE;AAAT,KADJ;AACqB;AAC3BC,IAAAA,KAAK,EAAE;AAAED,MAAAA,KAAK,EAAE;AAAT,KAFD;AAEkB;AACxBE,IAAAA,GAAG,EAAE;AAAEF,MAAAA,KAAK,EAAE;AAAT,KAHC;AAGa;AACnBG,IAAAA,MAAM,EAAE;AAAEH,MAAAA,KAAK,EAAE;AAAT,KAJF;AAKNI,IAAAA,KAAK,EAAE;AAAEJ,MAAAA,KAAK,EAAE;AAAT,KALD;AAMNK,IAAAA,IAAI,EAAE;AAAEL,MAAAA,KAAK,EAAE;AAAT,KANA;AAONM,IAAAA,MAAM,EAAE;AAAEN,MAAAA,KAAK,EAAE;AAAT,KAPF;AAOmB;AACzBO,IAAAA,MAAM,EAAE;AAAEP,MAAAA,KAAK,EAAE;AAAT,KARF;AAQmB;AACzBQ,IAAAA,YAAY,EAAE;AAAER,MAAAA,KAAK,EAAE;AAAT,KATR;AAUNS,IAAAA,YAAY,EAAE;AAAET,MAAAA,KAAK,EAAE;AAAT,KAVR;AAWNU,IAAAA,KAAK,EAAE;AAAEV,MAAAA,KAAK,EAAE;AAAT;AAXD,GADM;AAehBW,EAAAA,YAAY,EAAE,CAAA,mBAAA,EAAA,eAAA,EAAA,WAAA,EAAA,2EAAA,EAAA,GAAA,EAAA,IAAA,CAfE,IAeF,CAfE;AAuBhBC,EAAAA,cAAc,EAAE,CAAA,kBAAA,EACQ;AADR,+BAAA,EAAA,0BAAA,EAAA,uBAAA,EAAA,sBAAA,EAAA,qBAAA,EAAA,uBAAA,EAAA,uBAAA,EAAA,6BAAA,EAAA,6BAAA,EAAA,sBAAA,EAAA,mBAAA,EAAA,sBAAA,EAAA,mEAAA,EAAA,GAAA,EAAA,eAAA,EAAA,aAAA,EAAA,eAAA,EAAA,yCAAA,EAAA,yCAAA,EAqBZ;AArBY,iDAAA,EAAA,6DAAA,EAAA,gBAAA,EAAA,kCAAA,EAAA,GAAA,EAAA,QAAA,EAAA,qBAAA,EAAA,GAAA,EAAA,GAAA,EAAA,6DAAA,EAAA,gBAAA,EAAA,mBAAA,EAAA,GAAA,EAAA,QAAA,EAAA,kCAAA,EAAA,GAAA,EAAA,GAAA,EAAA,iCAAA,EAAA,iCAAA,EAyCZ;AAzCY,yDAAA,EAAA,4CAAA,EAAA,oCAAA,EAAA,4CAAA,EAAA,gDAAA,EA+CZ;AA/CY,2EAAA,EAAA,oCAAA,EAAA,GAAA,EAAA,QAAA,EAAA,yCAAA,EAAA,GAAA,EAAA,GAAA,EAAA,IAAA,CAAA,IAAA;AAvBA,CAApB;AAiFA,SAAA,aAAA","sourcesContent":["/**\n * @author felixturner / http://airtight.cc/\n *\n * RGB Shift Shader\n * Shifts red and blue channels from center in opposite directions\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n * by Tom Butterworth / http://kriss.cx/tom/\n *\n * amount: shift distance (1 is width of input)\n * angle: shift angle in radians\n */\n\nvar DigitalGlitch = {\n    uniforms: {\n        tDiffuse: { value: null }, //diffuse texture\n        tDisp: { value: null }, //displacement texture for digital glitch squares\n        byp: { value: 0 }, //apply the glitch ?\n        amount: { value: 0.08 },\n        angle: { value: 0.02 },\n        seed: { value: 0.02 },\n        seed_x: { value: 0.02 }, //-1,1\n        seed_y: { value: 0.02 }, //-1,1\n        distortion_x: { value: 0.5 },\n        distortion_y: { value: 0.6 },\n        col_s: { value: 0.05 }\n    },\n\n    vertexShader: [\n        \"varying vec2 vUv;\",\n        \"void main() {\",\n        \"vUv = uv;\",\n        \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n        \"}\"\n    ].join(\"\\n\"),\n\n    fragmentShader: [\n        \"uniform int byp;\", //should we apply the glitch ?\n        \"uniform sampler2D tDiffuse;\",\n        \"uniform sampler2D tDisp;\",\n        \"uniform float amount;\",\n        \"uniform float angle;\",\n        \"uniform float seed;\",\n        \"uniform float seed_x;\",\n        \"uniform float seed_y;\",\n        \"uniform float distortion_x;\",\n        \"uniform float distortion_y;\",\n        \"uniform float col_s;\",\n        \"varying vec2 vUv;\",\n        \"float rand(vec2 co){\",\n        \"return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\",\n        \"}\",\n        \"void main() {\",\n        \"if(byp<1) {\",\n        \"vec2 p = vUv;\",\n        \"float xs = floor(gl_FragCoord.x / 0.5);\",\n        \"float ys = floor(gl_FragCoord.y / 0.5);\",\n        //based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\n        \"vec4 normal = texture2D (tDisp, p*seed*seed);\",\n        \"if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {\",\n        \"if(seed_x>0.){\",\n        \"p.y = 1. - (p.y + distortion_y);\",\n        \"}\",\n        \"else {\",\n        \"p.y = distortion_y;\",\n        \"}\",\n        \"}\",\n        \"if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {\",\n        \"if(seed_y>0.){\",\n        \"p.x=distortion_x;\",\n        \"}\",\n        \"else {\",\n        \"p.x = 1. - (p.x + distortion_x);\",\n        \"}\",\n        \"}\",\n        \"p.x+=normal.x*seed_x*(seed/5.);\",\n        \"p.y+=normal.y*seed_y*(seed/5.);\",\n        //base from RGB shift shader\n        \"vec2 offset = amount * vec2( cos(angle), sin(angle));\",\n        \"vec4 cr = texture2D(tDiffuse, p + offset);\",\n        \"vec4 cga = texture2D(tDiffuse, p);\",\n        \"vec4 cb = texture2D(tDiffuse, p - offset);\",\n        \"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\",\n        //add noise\n        \"vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.05);\",\n        \"gl_FragColor = gl_FragColor+ snow;\",\n        \"}\",\n        \"else {\",\n        \"gl_FragColor=texture2D (tDiffuse, vUv);\",\n        \"}\",\n        \"}\"\n    ].join(\"\\n\")\n};\n\nexport { DigitalGlitch };\n"]},"metadata":{},"sourceType":"module"}