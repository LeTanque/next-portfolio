{"ast":null,"code":"import _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\nimport { Geometry } from '../core/Geometry.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js'; // CylinderGeometry\n\nfunction CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {\n  Geometry.call(this);\n  this.type = 'CylinderGeometry';\n  this.parameters = {\n    radiusTop: radiusTop,\n    radiusBottom: radiusBottom,\n    height: height,\n    radialSegments: radialSegments,\n    heightSegments: heightSegments,\n    openEnded: openEnded,\n    thetaStart: thetaStart,\n    thetaLength: thetaLength\n  };\n  this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));\n  this.mergeVertices();\n}\n\nCylinderGeometry.prototype = _Object$create(Geometry.prototype);\nCylinderGeometry.prototype.constructor = CylinderGeometry; // CylinderBufferGeometry\n\nfunction CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {\n  BufferGeometry.call(this);\n  this.type = 'CylinderBufferGeometry';\n  this.parameters = {\n    radiusTop: radiusTop,\n    radiusBottom: radiusBottom,\n    height: height,\n    radialSegments: radialSegments,\n    heightSegments: heightSegments,\n    openEnded: openEnded,\n    thetaStart: thetaStart,\n    thetaLength: thetaLength\n  };\n  var scope = this;\n  radiusTop = radiusTop !== undefined ? radiusTop : 1;\n  radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;\n  height = height || 1;\n  radialSegments = Math.floor(radialSegments) || 8;\n  heightSegments = Math.floor(heightSegments) || 1;\n  openEnded = openEnded !== undefined ? openEnded : false;\n  thetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2; // buffers\n\n  var indices = [];\n  var vertices = [];\n  var normals = [];\n  var uvs = []; // helper variables\n\n  var index = 0;\n  var indexArray = [];\n  var halfHeight = height / 2;\n  var groupStart = 0; // generate geometry\n\n  generateTorso();\n\n  if (openEnded === false) {\n    if (radiusTop > 0) generateCap(true);\n    if (radiusBottom > 0) generateCap(false);\n  } // build geometry\n\n\n  this.setIndex(indices);\n  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n  this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n  function generateTorso() {\n    var x, y;\n    var normal = new Vector3();\n    var vertex = new Vector3();\n    var groupCount = 0; // this will be used to calculate the normal\n\n    var slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs\n\n    for (y = 0; y <= heightSegments; y++) {\n      var indexRow = [];\n      var v = y / heightSegments; // calculate the radius of the current row\n\n      var radius = v * (radiusBottom - radiusTop) + radiusTop;\n\n      for (x = 0; x <= radialSegments; x++) {\n        var u = x / radialSegments;\n        var theta = u * thetaLength + thetaStart;\n        var sinTheta = Math.sin(theta);\n        var cosTheta = Math.cos(theta); // vertex\n\n        vertex.x = radius * sinTheta;\n        vertex.y = -v * height + halfHeight;\n        vertex.z = radius * cosTheta;\n        vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n        normal.set(sinTheta, slope, cosTheta).normalize();\n        normals.push(normal.x, normal.y, normal.z); // uv\n\n        uvs.push(u, 1 - v); // save index of vertex in respective row\n\n        indexRow.push(index++);\n      } // now save vertices of the row in our index array\n\n\n      indexArray.push(indexRow);\n    } // generate indices\n\n\n    for (x = 0; x < radialSegments; x++) {\n      for (y = 0; y < heightSegments; y++) {\n        // we use the index array to access the correct indices\n        var a = indexArray[y][x];\n        var b = indexArray[y + 1][x];\n        var c = indexArray[y + 1][x + 1];\n        var d = indexArray[y][x + 1]; // faces\n\n        indices.push(a, b, d);\n        indices.push(b, c, d); // update group counter\n\n        groupCount += 6;\n      }\n    } // add a group to the geometry. this will ensure multi material support\n\n\n    scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups\n\n    groupStart += groupCount;\n  }\n\n  function generateCap(top) {\n    var x, centerIndexStart, centerIndexEnd;\n    var uv = new Vector2();\n    var vertex = new Vector3();\n    var groupCount = 0;\n    var radius = top === true ? radiusTop : radiusBottom;\n    var sign = top === true ? 1 : -1; // save the index of the first center vertex\n\n    centerIndexStart = index; // first we generate the center vertex data of the cap.\n    // because the geometry needs one set of uvs per face,\n    // we must generate a center vertex per face/segment\n\n    for (x = 1; x <= radialSegments; x++) {\n      // vertex\n      vertices.push(0, halfHeight * sign, 0); // normal\n\n      normals.push(0, sign, 0); // uv\n\n      uvs.push(0.5, 0.5); // increase index\n\n      index++;\n    } // save the index of the last center vertex\n\n\n    centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs\n\n    for (x = 0; x <= radialSegments; x++) {\n      var u = x / radialSegments;\n      var theta = u * thetaLength + thetaStart;\n      var cosTheta = Math.cos(theta);\n      var sinTheta = Math.sin(theta); // vertex\n\n      vertex.x = radius * sinTheta;\n      vertex.y = halfHeight * sign;\n      vertex.z = radius * cosTheta;\n      vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n      normals.push(0, sign, 0); // uv\n\n      uv.x = cosTheta * 0.5 + 0.5;\n      uv.y = sinTheta * 0.5 * sign + 0.5;\n      uvs.push(uv.x, uv.y); // increase index\n\n      index++;\n    } // generate indices\n\n\n    for (x = 0; x < radialSegments; x++) {\n      var c = centerIndexStart + x;\n      var i = centerIndexEnd + x;\n\n      if (top === true) {\n        // face top\n        indices.push(i, i + 1, c);\n      } else {\n        // face bottom\n        indices.push(i + 1, i, c);\n      }\n\n      groupCount += 3;\n    } // add a group to the geometry. this will ensure multi material support\n\n\n    scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups\n\n    groupStart += groupCount;\n  }\n}\n\nCylinderBufferGeometry.prototype = _Object$create(BufferGeometry.prototype);\nCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\nexport { CylinderGeometry, CylinderBufferGeometry };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/geometries/CylinderGeometry.js"],"names":["Geometry","BufferGeometry","Float32BufferAttribute","Vector3","Vector2","CylinderGeometry","radiusTop","radiusBottom","height","radialSegments","heightSegments","openEnded","thetaStart","thetaLength","call","type","parameters","fromBufferGeometry","CylinderBufferGeometry","mergeVertices","prototype","constructor","scope","undefined","Math","floor","PI","indices","vertices","normals","uvs","index","indexArray","halfHeight","groupStart","generateTorso","generateCap","setIndex","setAttribute","x","y","normal","vertex","groupCount","slope","indexRow","v","radius","u","theta","sinTheta","sin","cosTheta","cos","z","push","set","normalize","a","b","c","d","addGroup","top","centerIndexStart","centerIndexEnd","uv","sign","i"],"mappings":"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","sourcesContent":["/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nimport { Geometry } from '../core/Geometry.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\n\n// CylinderGeometry\n\nfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'CylinderGeometry';\n\n\tthis.parameters = {\n\t\tradiusTop: radiusTop,\n\t\tradiusBottom: radiusBottom,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\tthis.mergeVertices();\n\n}\n\nCylinderGeometry.prototype = Object.create( Geometry.prototype );\nCylinderGeometry.prototype.constructor = CylinderGeometry;\n\n// CylinderBufferGeometry\n\nfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'CylinderBufferGeometry';\n\n\tthis.parameters = {\n\t\tradiusTop: radiusTop,\n\t\tradiusBottom: radiusBottom,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tvar scope = this;\n\n\tradiusTop = radiusTop !== undefined ? radiusTop : 1;\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 1;\n\theight = height || 1;\n\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\theightSegments = Math.floor( heightSegments ) || 1;\n\n\topenEnded = openEnded !== undefined ? openEnded : false;\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar index = 0;\n\tvar indexArray = [];\n\tvar halfHeight = height / 2;\n\tvar groupStart = 0;\n\n\t// generate geometry\n\n\tgenerateTorso();\n\n\tif ( openEnded === false ) {\n\n\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\tfunction generateTorso() {\n\n\t\tvar x, y;\n\t\tvar normal = new Vector3();\n\t\tvar vertex = new Vector3();\n\n\t\tvar groupCount = 0;\n\n\t\t// this will be used to calculate the normal\n\t\tvar slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\tvar indexRow = [];\n\n\t\t\tvar v = y / heightSegments;\n\n\t\t\t// calculate the radius of the current row\n\n\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tvar u = x / radialSegments;\n\n\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\t\t\tvar cosTheta = Math.cos( theta );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u, 1 - v );\n\n\t\t\t\t// save index of vertex in respective row\n\n\t\t\t\tindexRow.push( index ++ );\n\n\t\t\t}\n\n\t\t\t// now save vertices of the row in our index array\n\n\t\t\tindexArray.push( indexRow );\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t// we use the index array to access the correct indices\n\n\t\t\t\tvar a = indexArray[ y ][ x ];\n\t\t\t\tvar b = indexArray[ y + 1 ][ x ];\n\t\t\t\tvar c = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\tvar d = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t// update group counter\n\n\t\t\t\tgroupCount += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t// calculate new start value for groups\n\n\t\tgroupStart += groupCount;\n\n\t}\n\n\tfunction generateCap( top ) {\n\n\t\tvar x, centerIndexStart, centerIndexEnd;\n\n\t\tvar uv = new Vector2();\n\t\tvar vertex = new Vector3();\n\n\t\tvar groupCount = 0;\n\n\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\tvar sign = ( top === true ) ? 1 : - 1;\n\n\t\t// save the index of the first center vertex\n\t\tcenterIndexStart = index;\n\n\t\t// first we generate the center vertex data of the cap.\n\t\t// because the geometry needs one set of uvs per face,\n\t\t// we must generate a center vertex per face/segment\n\n\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t// vertex\n\n\t\t\tvertices.push( 0, halfHeight * sign, 0 );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t// uv\n\n\t\t\tuvs.push( 0.5, 0.5 );\n\n\t\t\t// increase index\n\n\t\t\tindex ++;\n\n\t\t}\n\n\t\t// save the index of the last center vertex\n\n\t\tcenterIndexEnd = index;\n\n\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\tvar u = x / radialSegments;\n\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\tvar sinTheta = Math.sin( theta );\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = radius * sinTheta;\n\t\t\tvertex.y = halfHeight * sign;\n\t\t\tvertex.z = radius * cosTheta;\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t// uv\n\n\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t// increase index\n\n\t\t\tindex ++;\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tvar c = centerIndexStart + x;\n\t\t\tvar i = centerIndexEnd + x;\n\n\t\t\tif ( top === true ) {\n\n\t\t\t\t// face top\n\n\t\t\t\tindices.push( i, i + 1, c );\n\n\t\t\t} else {\n\n\t\t\t\t// face bottom\n\n\t\t\t\tindices.push( i + 1, i, c );\n\n\t\t\t}\n\n\t\t\tgroupCount += 3;\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t// calculate new start value for groups\n\n\t\tgroupStart += groupCount;\n\n\t}\n\n}\n\nCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\n\n\nexport { CylinderGeometry, CylinderBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}