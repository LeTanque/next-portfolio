{"ast":null,"code":"import _Number$EPSILON from \"@babel/runtime-corejs2/core-js/number/epsilon\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\nimport { Geometry } from '../core/Geometry.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { ShapeUtils } from '../extras/ShapeUtils.js'; // ExtrudeGeometry\n\nfunction ExtrudeGeometry(shapes, options) {\n  Geometry.call(this);\n  this.type = 'ExtrudeGeometry';\n  this.parameters = {\n    shapes: shapes,\n    options: options\n  };\n  this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));\n  this.mergeVertices();\n}\n\nExtrudeGeometry.prototype = _Object$create(Geometry.prototype);\nExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\n\nExtrudeGeometry.prototype.toJSON = function () {\n  var data = Geometry.prototype.toJSON.call(this);\n  var shapes = this.parameters.shapes;\n  var options = this.parameters.options;\n  return toJSON(shapes, options, data);\n}; // ExtrudeBufferGeometry\n\n\nfunction ExtrudeBufferGeometry(shapes, options) {\n  BufferGeometry.call(this);\n  this.type = 'ExtrudeBufferGeometry';\n  this.parameters = {\n    shapes: shapes,\n    options: options\n  };\n  shapes = _Array$isArray(shapes) ? shapes : [shapes];\n  var scope = this;\n  var verticesArray = [];\n  var uvArray = [];\n\n  for (var i = 0, l = shapes.length; i < l; i++) {\n    var shape = shapes[i];\n    addShape(shape);\n  } // build geometry\n\n\n  this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));\n  this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));\n  this.computeVertexNormals(); // functions\n\n  function addShape(shape) {\n    var placeholder = []; // options\n\n    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n    var steps = options.steps !== undefined ? options.steps : 1;\n    var depth = options.depth !== undefined ? options.depth : 100;\n    var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n    var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\n    var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\n    var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n    var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n    var extrudePath = options.extrudePath;\n    var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options\n\n    if (options.amount !== undefined) {\n      console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');\n      depth = options.amount;\n    } //\n\n\n    var extrudePts,\n        extrudeByPath = false;\n    var splineTube, binormal, normal, position2;\n\n    if (extrudePath) {\n      extrudePts = extrudePath.getSpacedPoints(steps);\n      extrudeByPath = true;\n      bevelEnabled = false; // bevels not supported for path extrusion\n      // SETUP TNB variables\n      // TODO1 - have a .isClosed in spline?\n\n      splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n      binormal = new Vector3();\n      normal = new Vector3();\n      position2 = new Vector3();\n    } // Safeguards if bevels are not enabled\n\n\n    if (!bevelEnabled) {\n      bevelSegments = 0;\n      bevelThickness = 0;\n      bevelSize = 0;\n      bevelOffset = 0;\n    } // Variables initialization\n\n\n    var ahole, h, hl; // looping of holes\n\n    var shapePoints = shape.extractPoints(curveSegments);\n    var vertices = shapePoints.shape;\n    var holes = shapePoints.holes;\n    var reverse = !ShapeUtils.isClockWise(vertices);\n\n    if (reverse) {\n      vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n      for (h = 0, hl = holes.length; h < hl; h++) {\n        ahole = holes[h];\n\n        if (ShapeUtils.isClockWise(ahole)) {\n          holes[h] = ahole.reverse();\n        }\n      }\n    }\n\n    var faces = ShapeUtils.triangulateShape(vertices, holes);\n    /* Vertices */\n\n    var contour = vertices; // vertices has all points but contour has only points of circumference\n\n    for (h = 0, hl = holes.length; h < hl; h++) {\n      ahole = holes[h];\n      vertices = vertices.concat(ahole);\n    }\n\n    function scalePt2(pt, vec, size) {\n      if (!vec) console.error(\"THREE.ExtrudeGeometry: vec does not exist\");\n      return vec.clone().multiplyScalar(size).add(pt);\n    }\n\n    var b,\n        bs,\n        t,\n        z,\n        vert,\n        vlen = vertices.length,\n        face,\n        flen = faces.length; // Find directions for point movement\n\n    function getBevelVec(inPt, inPrev, inNext) {\n      // computes for inPt the corresponding point inPt' on a new contour\n      //   shifted by 1 unit (length of normalized vector) to the left\n      // if we walk along contour clockwise, this new contour is outside the old one\n      //\n      // inPt' is the intersection of the two lines parallel to the two\n      //  adjacent edges of inPt at a distance of 1 unit on the left side.\n      var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n      // good reading for geometry algorithms (here: line-line intersection)\n      // http://geomalgorithms.com/a05-_intersect-1.html\n\n      var v_prev_x = inPt.x - inPrev.x,\n          v_prev_y = inPt.y - inPrev.y;\n      var v_next_x = inNext.x - inPt.x,\n          v_next_y = inNext.y - inPt.y;\n      var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges\n\n      var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;\n\n      if (Math.abs(collinear0) > _Number$EPSILON) {\n        // not collinear\n        // length of vectors for normalizing\n        var v_prev_len = Math.sqrt(v_prev_lensq);\n        var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left\n\n        var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;\n        var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;\n        var ptNextShift_x = inNext.x - v_next_y / v_next_len;\n        var ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point\n\n        var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point\n\n        v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;\n        v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly\n        //  but prevent crazy spikes\n\n        var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;\n\n        if (v_trans_lensq <= 2) {\n          return new Vector2(v_trans_x, v_trans_y);\n        } else {\n          shrink_by = Math.sqrt(v_trans_lensq / 2);\n        }\n      } else {\n        // handle special case of collinear edges\n        var direction_eq = false; // assumes: opposite\n\n        if (v_prev_x > _Number$EPSILON) {\n          if (v_next_x > _Number$EPSILON) {\n            direction_eq = true;\n          }\n        } else {\n          if (v_prev_x < -_Number$EPSILON) {\n            if (v_next_x < -_Number$EPSILON) {\n              direction_eq = true;\n            }\n          } else {\n            if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {\n              direction_eq = true;\n            }\n          }\n        }\n\n        if (direction_eq) {\n          // console.log(\"Warning: lines are a straight sequence\");\n          v_trans_x = -v_prev_y;\n          v_trans_y = v_prev_x;\n          shrink_by = Math.sqrt(v_prev_lensq);\n        } else {\n          // console.log(\"Warning: lines are a straight spike\");\n          v_trans_x = v_prev_x;\n          v_trans_y = v_prev_y;\n          shrink_by = Math.sqrt(v_prev_lensq / 2);\n        }\n      }\n\n      return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);\n    }\n\n    var contourMovements = [];\n\n    for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n      if (j === il) j = 0;\n      if (k === il) k = 0; //  (j)---(i)---(k)\n      // console.log('i,j,k', i, j , k)\n\n      contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);\n    }\n\n    var holesMovements = [],\n        oneHoleMovements,\n        verticesMovements = contourMovements.concat();\n\n    for (h = 0, hl = holes.length; h < hl; h++) {\n      ahole = holes[h];\n      oneHoleMovements = [];\n\n      for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n        if (j === il) j = 0;\n        if (k === il) k = 0; //  (j)---(i)---(k)\n\n        oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);\n      }\n\n      holesMovements.push(oneHoleMovements);\n      verticesMovements = verticesMovements.concat(oneHoleMovements);\n    } // Loop bevelSegments, 1 for the front, 1 for the back\n\n\n    for (b = 0; b < bevelSegments; b++) {\n      //for ( b = bevelSegments; b > 0; b -- ) {\n      t = b / bevelSegments;\n      z = bevelThickness * Math.cos(t * Math.PI / 2);\n      bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape\n\n      for (i = 0, il = contour.length; i < il; i++) {\n        vert = scalePt2(contour[i], contourMovements[i], bs);\n        v(vert.x, vert.y, -z);\n      } // expand holes\n\n\n      for (h = 0, hl = holes.length; h < hl; h++) {\n        ahole = holes[h];\n        oneHoleMovements = holesMovements[h];\n\n        for (i = 0, il = ahole.length; i < il; i++) {\n          vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n          v(vert.x, vert.y, -z);\n        }\n      }\n    }\n\n    bs = bevelSize + bevelOffset; // Back facing vertices\n\n    for (i = 0; i < vlen; i++) {\n      vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n\n      if (!extrudeByPath) {\n        v(vert.x, vert.y, 0);\n      } else {\n        // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n        normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);\n        binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);\n        position2.copy(extrudePts[0]).add(normal).add(binormal);\n        v(position2.x, position2.y, position2.z);\n      }\n    } // Add stepped vertices...\n    // Including front facing vertices\n\n\n    var s;\n\n    for (s = 1; s <= steps; s++) {\n      for (i = 0; i < vlen; i++) {\n        vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n\n        if (!extrudeByPath) {\n          v(vert.x, vert.y, depth / steps * s);\n        } else {\n          // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n          normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);\n          binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);\n          position2.copy(extrudePts[s]).add(normal).add(binormal);\n          v(position2.x, position2.y, position2.z);\n        }\n      }\n    } // Add bevel segments planes\n    //for ( b = 1; b <= bevelSegments; b ++ ) {\n\n\n    for (b = bevelSegments - 1; b >= 0; b--) {\n      t = b / bevelSegments;\n      z = bevelThickness * Math.cos(t * Math.PI / 2);\n      bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape\n\n      for (i = 0, il = contour.length; i < il; i++) {\n        vert = scalePt2(contour[i], contourMovements[i], bs);\n        v(vert.x, vert.y, depth + z);\n      } // expand holes\n\n\n      for (h = 0, hl = holes.length; h < hl; h++) {\n        ahole = holes[h];\n        oneHoleMovements = holesMovements[h];\n\n        for (i = 0, il = ahole.length; i < il; i++) {\n          vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n\n          if (!extrudeByPath) {\n            v(vert.x, vert.y, depth + z);\n          } else {\n            v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);\n          }\n        }\n      }\n    }\n    /* Faces */\n    // Top and bottom faces\n\n\n    buildLidFaces(); // Sides faces\n\n    buildSideFaces(); /////  Internal functions\n\n    function buildLidFaces() {\n      var start = verticesArray.length / 3;\n\n      if (bevelEnabled) {\n        var layer = 0; // steps + 1\n\n        var offset = vlen * layer; // Bottom faces\n\n        for (i = 0; i < flen; i++) {\n          face = faces[i];\n          f3(face[2] + offset, face[1] + offset, face[0] + offset);\n        }\n\n        layer = steps + bevelSegments * 2;\n        offset = vlen * layer; // Top faces\n\n        for (i = 0; i < flen; i++) {\n          face = faces[i];\n          f3(face[0] + offset, face[1] + offset, face[2] + offset);\n        }\n      } else {\n        // Bottom faces\n        for (i = 0; i < flen; i++) {\n          face = faces[i];\n          f3(face[2], face[1], face[0]);\n        } // Top faces\n\n\n        for (i = 0; i < flen; i++) {\n          face = faces[i];\n          f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);\n        }\n      }\n\n      scope.addGroup(start, verticesArray.length / 3 - start, 0);\n    } // Create faces for the z-sides of the shape\n\n\n    function buildSideFaces() {\n      var start = verticesArray.length / 3;\n      var layeroffset = 0;\n      sidewalls(contour, layeroffset);\n      layeroffset += contour.length;\n\n      for (h = 0, hl = holes.length; h < hl; h++) {\n        ahole = holes[h];\n        sidewalls(ahole, layeroffset); //, true\n\n        layeroffset += ahole.length;\n      }\n\n      scope.addGroup(start, verticesArray.length / 3 - start, 1);\n    }\n\n    function sidewalls(contour, layeroffset) {\n      var j, k;\n      i = contour.length;\n\n      while (--i >= 0) {\n        j = i;\n        k = i - 1;\n        if (k < 0) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);\n\n        var s = 0,\n            sl = steps + bevelSegments * 2;\n\n        for (s = 0; s < sl; s++) {\n          var slen1 = vlen * s;\n          var slen2 = vlen * (s + 1);\n          var a = layeroffset + j + slen1,\n              b = layeroffset + k + slen1,\n              c = layeroffset + k + slen2,\n              d = layeroffset + j + slen2;\n          f4(a, b, c, d);\n        }\n      }\n    }\n\n    function v(x, y, z) {\n      placeholder.push(x);\n      placeholder.push(y);\n      placeholder.push(z);\n    }\n\n    function f3(a, b, c) {\n      addVertex(a);\n      addVertex(b);\n      addVertex(c);\n      var nextIndex = verticesArray.length / 3;\n      var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n      addUV(uvs[0]);\n      addUV(uvs[1]);\n      addUV(uvs[2]);\n    }\n\n    function f4(a, b, c, d) {\n      addVertex(a);\n      addVertex(b);\n      addVertex(d);\n      addVertex(b);\n      addVertex(c);\n      addVertex(d);\n      var nextIndex = verticesArray.length / 3;\n      var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n      addUV(uvs[0]);\n      addUV(uvs[1]);\n      addUV(uvs[3]);\n      addUV(uvs[1]);\n      addUV(uvs[2]);\n      addUV(uvs[3]);\n    }\n\n    function addVertex(index) {\n      verticesArray.push(placeholder[index * 3 + 0]);\n      verticesArray.push(placeholder[index * 3 + 1]);\n      verticesArray.push(placeholder[index * 3 + 2]);\n    }\n\n    function addUV(vector2) {\n      uvArray.push(vector2.x);\n      uvArray.push(vector2.y);\n    }\n  }\n}\n\nExtrudeBufferGeometry.prototype = _Object$create(BufferGeometry.prototype);\nExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;\n\nExtrudeBufferGeometry.prototype.toJSON = function () {\n  var data = BufferGeometry.prototype.toJSON.call(this);\n  var shapes = this.parameters.shapes;\n  var options = this.parameters.options;\n  return toJSON(shapes, options, data);\n}; //\n\n\nvar WorldUVGenerator = {\n  generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {\n    var a_x = vertices[indexA * 3];\n    var a_y = vertices[indexA * 3 + 1];\n    var b_x = vertices[indexB * 3];\n    var b_y = vertices[indexB * 3 + 1];\n    var c_x = vertices[indexC * 3];\n    var c_y = vertices[indexC * 3 + 1];\n    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];\n  },\n  generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {\n    var a_x = vertices[indexA * 3];\n    var a_y = vertices[indexA * 3 + 1];\n    var a_z = vertices[indexA * 3 + 2];\n    var b_x = vertices[indexB * 3];\n    var b_y = vertices[indexB * 3 + 1];\n    var b_z = vertices[indexB * 3 + 2];\n    var c_x = vertices[indexC * 3];\n    var c_y = vertices[indexC * 3 + 1];\n    var c_z = vertices[indexC * 3 + 2];\n    var d_x = vertices[indexD * 3];\n    var d_y = vertices[indexD * 3 + 1];\n    var d_z = vertices[indexD * 3 + 2];\n\n    if (Math.abs(a_y - b_y) < 0.01) {\n      return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];\n    } else {\n      return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];\n    }\n  }\n};\n\nfunction toJSON(shapes, options, data) {\n  //\n  data.shapes = [];\n\n  if (_Array$isArray(shapes)) {\n    for (var i = 0, l = shapes.length; i < l; i++) {\n      var shape = shapes[i];\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  } //\n\n\n  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();\n  return data;\n}\n\nexport { ExtrudeGeometry, ExtrudeBufferGeometry };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/geometries/ExtrudeGeometry.js"],"names":["Geometry","BufferGeometry","Float32BufferAttribute","Vector2","Vector3","ShapeUtils","ExtrudeGeometry","shapes","options","call","type","parameters","fromBufferGeometry","ExtrudeBufferGeometry","mergeVertices","prototype","constructor","toJSON","data","scope","verticesArray","uvArray","i","l","length","shape","addShape","setAttribute","computeVertexNormals","placeholder","curveSegments","undefined","steps","depth","bevelEnabled","bevelThickness","bevelSize","bevelOffset","bevelSegments","extrudePath","uvgen","UVGenerator","WorldUVGenerator","amount","console","warn","extrudePts","extrudeByPath","splineTube","binormal","normal","position2","getSpacedPoints","computeFrenetFrames","ahole","h","hl","shapePoints","extractPoints","vertices","holes","reverse","isClockWise","faces","triangulateShape","contour","concat","scalePt2","pt","vec","size","error","clone","multiplyScalar","add","b","bs","t","z","vert","vlen","face","flen","getBevelVec","inPt","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","x","v_prev_y","y","v_next_x","v_next_y","v_prev_lensq","collinear0","Math","abs","v_prev_len","sqrt","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","sign","contourMovements","il","j","k","holesMovements","oneHoleMovements","verticesMovements","push","cos","PI","sin","v","copy","normals","binormals","s","buildLidFaces","buildSideFaces","start","layer","offset","f3","addGroup","layeroffset","sidewalls","sl","slen1","slen2","a","c","d","f4","addVertex","nextIndex","uvs","generateTopUV","addUV","generateSideWallUV","index","vector2","geometry","indexA","indexB","indexC","a_x","a_y","b_x","b_y","c_x","c_y","indexD","a_z","b_z","c_z","d_x","d_y","d_z","uuid"],"mappings":"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","sourcesContent":["/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\nimport { Geometry } from '../core/Geometry.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { ShapeUtils } from '../extras/ShapeUtils.js';\n\n// ExtrudeGeometry\n\nfunction ExtrudeGeometry( shapes, options ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'ExtrudeGeometry';\n\n\tthis.parameters = {\n\t\tshapes: shapes,\n\t\toptions: options\n\t};\n\n\tthis.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );\n\tthis.mergeVertices();\n\n}\n\nExtrudeGeometry.prototype = Object.create( Geometry.prototype );\nExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\n\nExtrudeGeometry.prototype.toJSON = function () {\n\n\tvar data = Geometry.prototype.toJSON.call( this );\n\n\tvar shapes = this.parameters.shapes;\n\tvar options = this.parameters.options;\n\n\treturn toJSON( shapes, options, data );\n\n};\n\n// ExtrudeBufferGeometry\n\nfunction ExtrudeBufferGeometry( shapes, options ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'ExtrudeBufferGeometry';\n\n\tthis.parameters = {\n\t\tshapes: shapes,\n\t\toptions: options\n\t};\n\n\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\tvar scope = this;\n\n\tvar verticesArray = [];\n\tvar uvArray = [];\n\n\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\tvar shape = shapes[ i ];\n\t\taddShape( shape );\n\n\t}\n\n\t// build geometry\n\n\tthis.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\n\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\n\n\tthis.computeVertexNormals();\n\n\t// functions\n\n\tfunction addShape( shape ) {\n\n\t\tvar placeholder = [];\n\n\t\t// options\n\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\n\t\tvar depth = options.depth !== undefined ? options.depth : 100;\n\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\n\t\tvar bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\tvar extrudePath = options.extrudePath;\n\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\n\n\t\t// deprecated options\n\n\t\tif ( options.amount !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );\n\t\t\tdepth = options.amount;\n\n\t\t}\n\n\t\t//\n\n\t\tvar extrudePts, extrudeByPath = false;\n\t\tvar splineTube, binormal, normal, position2;\n\n\t\tif ( extrudePath ) {\n\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\textrudeByPath = true;\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t// SETUP TNB variables\n\n\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\tbinormal = new Vector3();\n\t\t\tnormal = new Vector3();\n\t\t\tposition2 = new Vector3();\n\n\t\t}\n\n\t\t// Safeguards if bevels are not enabled\n\n\t\tif ( ! bevelEnabled ) {\n\n\t\t\tbevelSegments = 0;\n\t\t\tbevelThickness = 0;\n\t\t\tbevelSize = 0;\n\t\t\tbevelOffset = 0;\n\n\t\t}\n\n\t\t// Variables initialization\n\n\t\tvar ahole, h, hl; // looping of holes\n\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\t\tvar vertices = shapePoints.shape;\n\t\tvar holes = shapePoints.holes;\n\n\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\tif ( reverse ) {\n\n\t\t\tvertices = vertices.reverse();\n\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t/* Vertices */\n\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tvertices = vertices.concat( ahole );\n\n\t\t}\n\n\n\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t\t}\n\n\t\tvar b, bs, t, z,\n\t\t\tvert, vlen = vertices.length,\n\t\t\tface, flen = faces.length;\n\n\n\t\t// Find directions for point movement\n\n\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t//\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\tvar v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\tvar v_prev_x = inPt.x - inPrev.x,\n\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\tvar v_next_x = inNext.x - inPt.x,\n\t\t\t\tv_next_y = inNext.y - inPt.y;\n\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t// check for collinear edges\n\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t// not collinear\n\n\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\tvar sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\n\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t//  but prevent crazy spikes\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\tvar direction_eq = false; // assumes: opposite\n\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t}\n\n\n\t\tvar contourMovements = [];\n\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t}\n\n\t\tvar holesMovements = [],\n\t\t\toneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\toneHoleMovements = [];\n\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t}\n\n\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t}\n\n\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t// contract shape\n\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t}\n\n\t\t\t// expand holes\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tbs = bevelSize + bevelOffset;\n\n\t\t// Back facing vertices\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add stepped vertices...\n\t\t// Including front facing vertices\n\n\t\tvar s;\n\n\t\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, depth / steps * s );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// Add bevel segments planes\n\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t// contract shape\n\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t}\n\n\t\t\t// expand holes\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/* Faces */\n\n\t\t// Top and bottom faces\n\n\t\tbuildLidFaces();\n\n\t\t// Sides faces\n\n\t\tbuildSideFaces();\n\n\n\t\t/////  Internal functions\n\n\t\tfunction buildLidFaces() {\n\n\t\t\tvar start = verticesArray.length / 3;\n\n\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\tvar layer = 0; // steps + 1\n\t\t\t\tvar offset = vlen * layer;\n\n\t\t\t\t// Bottom faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t}\n\n\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t// Top faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bottom faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\t// Top faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\n\n\t\t}\n\n\t\t// Create faces for the z-sides of the shape\n\n\t\tfunction buildSideFaces() {\n\n\t\t\tvar start = verticesArray.length / 3;\n\t\t\tvar layeroffset = 0;\n\t\t\tsidewalls( contour, layeroffset );\n\t\t\tlayeroffset += contour.length;\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t//, true\n\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t}\n\n\n\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\n\n\n\t\t}\n\n\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\tvar j, k;\n\t\t\ti = contour.length;\n\n\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\tj = i;\n\t\t\t\tk = i - 1;\n\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\tvar s = 0,\n\t\t\t\t\tsl = steps + bevelSegments * 2;\n\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\tf4( a, b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction v( x, y, z ) {\n\n\t\t\tplaceholder.push( x );\n\t\t\tplaceholder.push( y );\n\t\t\tplaceholder.push( z );\n\n\t\t}\n\n\n\t\tfunction f3( a, b, c ) {\n\n\t\t\taddVertex( a );\n\t\t\taddVertex( b );\n\t\t\taddVertex( c );\n\n\t\t\tvar nextIndex = verticesArray.length / 3;\n\t\t\tvar uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\taddUV( uvs[ 0 ] );\n\t\t\taddUV( uvs[ 1 ] );\n\t\t\taddUV( uvs[ 2 ] );\n\n\t\t}\n\n\t\tfunction f4( a, b, c, d ) {\n\n\t\t\taddVertex( a );\n\t\t\taddVertex( b );\n\t\t\taddVertex( d );\n\n\t\t\taddVertex( b );\n\t\t\taddVertex( c );\n\t\t\taddVertex( d );\n\n\n\t\t\tvar nextIndex = verticesArray.length / 3;\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\taddUV( uvs[ 0 ] );\n\t\t\taddUV( uvs[ 1 ] );\n\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\taddUV( uvs[ 1 ] );\n\t\t\taddUV( uvs[ 2 ] );\n\t\t\taddUV( uvs[ 3 ] );\n\n\t\t}\n\n\t\tfunction addVertex( index ) {\n\n\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\n\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\n\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\n\n\t\t}\n\n\n\t\tfunction addUV( vector2 ) {\n\n\t\t\tuvArray.push( vector2.x );\n\t\t\tuvArray.push( vector2.y );\n\n\t\t}\n\n\t}\n\n}\n\nExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;\n\nExtrudeBufferGeometry.prototype.toJSON = function () {\n\n\tvar data = BufferGeometry.prototype.toJSON.call( this );\n\n\tvar shapes = this.parameters.shapes;\n\tvar options = this.parameters.options;\n\n\treturn toJSON( shapes, options, data );\n\n};\n\n//\n\nvar WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\n\n\t\tvar a_x = vertices[ indexA * 3 ];\n\t\tvar a_y = vertices[ indexA * 3 + 1 ];\n\t\tvar b_x = vertices[ indexB * 3 ];\n\t\tvar b_y = vertices[ indexB * 3 + 1 ];\n\t\tvar c_x = vertices[ indexC * 3 ];\n\t\tvar c_y = vertices[ indexC * 3 + 1 ];\n\n\t\treturn [\n\t\t\tnew Vector2( a_x, a_y ),\n\t\t\tnew Vector2( b_x, b_y ),\n\t\t\tnew Vector2( c_x, c_y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\n\n\t\tvar a_x = vertices[ indexA * 3 ];\n\t\tvar a_y = vertices[ indexA * 3 + 1 ];\n\t\tvar a_z = vertices[ indexA * 3 + 2 ];\n\t\tvar b_x = vertices[ indexB * 3 ];\n\t\tvar b_y = vertices[ indexB * 3 + 1 ];\n\t\tvar b_z = vertices[ indexB * 3 + 2 ];\n\t\tvar c_x = vertices[ indexC * 3 ];\n\t\tvar c_y = vertices[ indexC * 3 + 1 ];\n\t\tvar c_z = vertices[ indexC * 3 + 2 ];\n\t\tvar d_x = vertices[ indexD * 3 ];\n\t\tvar d_y = vertices[ indexD * 3 + 1 ];\n\t\tvar d_z = vertices[ indexD * 3 + 2 ];\n\n\t\tif ( Math.abs( a_y - b_y ) < 0.01 ) {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_x, 1 - a_z ),\n\t\t\t\tnew Vector2( b_x, 1 - b_z ),\n\t\t\t\tnew Vector2( c_x, 1 - c_z ),\n\t\t\t\tnew Vector2( d_x, 1 - d_z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_y, 1 - a_z ),\n\t\t\t\tnew Vector2( b_y, 1 - b_z ),\n\t\t\t\tnew Vector2( c_y, 1 - c_z ),\n\t\t\t\tnew Vector2( d_y, 1 - d_z )\n\t\t\t];\n\n\t\t}\n\n\t}\n};\n\nfunction toJSON( shapes, options, data ) {\n\n\t//\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tvar shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\t//\n\n\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\n\n\treturn data;\n\n}\n\n\nexport { ExtrudeGeometry, ExtrudeBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}