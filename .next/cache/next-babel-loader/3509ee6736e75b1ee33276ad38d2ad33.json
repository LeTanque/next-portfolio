{"ast":null,"code":"import _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport { Curve } from './Curve.js';\nimport * as Curves from '../curves/Curves.js';\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n **/\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nfunction CurvePath() {\n  Curve.call(this);\n  this.type = 'CurvePath';\n  this.curves = [];\n  this.autoClose = false; // Automatically closes the path\n}\n\nCurvePath.prototype = _Object$assign(_Object$create(Curve.prototype), {\n  constructor: CurvePath,\n  add: function (curve) {\n    this.curves.push(curve);\n  },\n  closePath: function () {\n    // Add a line curve if start and end of lines are not connected\n    var startPoint = this.curves[0].getPoint(0);\n    var endPoint = this.curves[this.curves.length - 1].getPoint(1);\n\n    if (!startPoint.equals(endPoint)) {\n      this.curves.push(new Curves['LineCurve'](endPoint, startPoint));\n    }\n  },\n  // To get accurate point with reference to\n  // entire path distance at time t,\n  // following has to be done:\n  // 1. Length of each sub path have to be known\n  // 2. Locate and identify type of curve\n  // 3. Get t for the curve\n  // 4. Return curve.getPointAt(t')\n  getPoint: function (t) {\n    var d = t * this.getLength();\n    var curveLengths = this.getCurveLengths();\n    var i = 0; // To think about boundaries points.\n\n    while (i < curveLengths.length) {\n      if (curveLengths[i] >= d) {\n        var diff = curveLengths[i] - d;\n        var curve = this.curves[i];\n        var segmentLength = curve.getLength();\n        var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n        return curve.getPointAt(u);\n      }\n\n      i++;\n    }\n\n    return null; // loop where sum != 0, sum > d , sum+1 <d\n  },\n  // We cannot use the default THREE.Curve getPoint() with getLength() because in\n  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n  // getPoint() depends on getLength\n  getLength: function () {\n    var lens = this.getCurveLengths();\n    return lens[lens.length - 1];\n  },\n  // cacheLengths must be recalculated.\n  updateArcLengths: function () {\n    this.needsUpdate = true;\n    this.cacheLengths = null;\n    this.getCurveLengths();\n  },\n  // Compute lengths and cache them\n  // We cannot overwrite getLengths() because UtoT mapping uses it.\n  getCurveLengths: function () {\n    // We use cache values if curves and cache array are same length\n    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {\n      return this.cacheLengths;\n    } // Get length of sub-curve\n    // Push sums into cached array\n\n\n    var lengths = [],\n        sums = 0;\n\n    for (var i = 0, l = this.curves.length; i < l; i++) {\n      sums += this.curves[i].getLength();\n      lengths.push(sums);\n    }\n\n    this.cacheLengths = lengths;\n    return lengths;\n  },\n  getSpacedPoints: function (divisions) {\n    if (divisions === undefined) divisions = 40;\n    var points = [];\n\n    for (var i = 0; i <= divisions; i++) {\n      points.push(this.getPoint(i / divisions));\n    }\n\n    if (this.autoClose) {\n      points.push(points[0]);\n    }\n\n    return points;\n  },\n  getPoints: function (divisions) {\n    divisions = divisions || 12;\n    var points = [],\n        last;\n\n    for (var i = 0, curves = this.curves; i < curves.length; i++) {\n      var curve = curves[i];\n      var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;\n      var pts = curve.getPoints(resolution);\n\n      for (var j = 0; j < pts.length; j++) {\n        var point = pts[j];\n        if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates\n\n        points.push(point);\n        last = point;\n      }\n    }\n\n    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {\n      points.push(points[0]);\n    }\n\n    return points;\n  },\n  copy: function (source) {\n    Curve.prototype.copy.call(this, source);\n    this.curves = [];\n\n    for (var i = 0, l = source.curves.length; i < l; i++) {\n      var curve = source.curves[i];\n      this.curves.push(curve.clone());\n    }\n\n    this.autoClose = source.autoClose;\n    return this;\n  },\n  toJSON: function () {\n    var data = Curve.prototype.toJSON.call(this);\n    data.autoClose = this.autoClose;\n    data.curves = [];\n\n    for (var i = 0, l = this.curves.length; i < l; i++) {\n      var curve = this.curves[i];\n      data.curves.push(curve.toJSON());\n    }\n\n    return data;\n  },\n  fromJSON: function (json) {\n    Curve.prototype.fromJSON.call(this, json);\n    this.autoClose = json.autoClose;\n    this.curves = [];\n\n    for (var i = 0, l = json.curves.length; i < l; i++) {\n      var curve = json.curves[i];\n      this.curves.push(new Curves[curve.type]().fromJSON(curve));\n    }\n\n    return this;\n  }\n});\nexport { CurvePath };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/extras/core/CurvePath.js"],"names":["Curve","Curves","CurvePath","call","type","curves","autoClose","prototype","constructor","add","curve","push","closePath","startPoint","getPoint","endPoint","length","equals","t","d","getLength","curveLengths","getCurveLengths","i","diff","segmentLength","u","getPointAt","lens","updateArcLengths","needsUpdate","cacheLengths","lengths","sums","l","getSpacedPoints","divisions","undefined","points","getPoints","last","resolution","isEllipseCurve","isLineCurve","isLineCurve3","isSplineCurve","pts","j","point","copy","source","clone","toJSON","data","fromJSON","json"],"mappings":"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","sourcesContent":["import { Curve } from './Curve.js';\nimport * as Curves from '../curves/Curves.js';\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n **/\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nfunction CurvePath() {\n\n\tCurve.call( this );\n\n\tthis.type = 'CurvePath';\n\n\tthis.curves = [];\n\tthis.autoClose = false; // Automatically closes the path\n\n}\n\nCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\n\n\tconstructor: CurvePath,\n\n\tadd: function ( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t},\n\n\tclosePath: function () {\n\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tthis.curves.push( new Curves[ 'LineCurve' ]( endPoint, startPoint ) );\n\n\t\t}\n\n\t},\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint: function ( t ) {\n\n\t\tvar d = t * this.getLength();\n\t\tvar curveLengths = this.getCurveLengths();\n\t\tvar i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\tvar curve = this.curves[ i ];\n\n\t\t\t\tvar segmentLength = curve.getLength();\n\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\treturn curve.getPointAt( u );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t},\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength: function () {\n\n\t\tvar lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t},\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths: function () {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getCurveLengths();\n\n\t},\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths: function () {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tvar lengths = [], sums = 0;\n\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t},\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( divisions === undefined ) divisions = 40;\n\n\t\tvar points = [];\n\n\t\tfor ( var i = 0; i <= divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\tgetPoints: function ( divisions ) {\n\n\t\tdivisions = divisions || 12;\n\n\t\tvar points = [], last;\n\n\t\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\tvar curve = curves[ i ];\n\t\t\tvar resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2\n\t\t\t\t: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1\n\t\t\t\t\t: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length\n\t\t\t\t\t\t: divisions;\n\n\t\t\tvar pts = curve.getPoints( resolution );\n\n\t\t\tfor ( var j = 0; j < pts.length; j ++ ) {\n\n\t\t\t\tvar point = pts[ j ];\n\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\tpoints.push( point );\n\t\t\t\tlast = point;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tCurve.prototype.copy.call( this, source );\n\n\t\tthis.curves = [];\n\n\t\tfor ( var i = 0, l = source.curves.length; i < l; i ++ ) {\n\n\t\t\tvar curve = source.curves[ i ];\n\n\t\t\tthis.curves.push( curve.clone() );\n\n\t\t}\n\n\t\tthis.autoClose = source.autoClose;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = Curve.prototype.toJSON.call( this );\n\n\t\tdata.autoClose = this.autoClose;\n\t\tdata.curves = [];\n\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tvar curve = this.curves[ i ];\n\t\t\tdata.curves.push( curve.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tfromJSON: function ( json ) {\n\n\t\tCurve.prototype.fromJSON.call( this, json );\n\n\t\tthis.autoClose = json.autoClose;\n\t\tthis.curves = [];\n\n\t\tfor ( var i = 0, l = json.curves.length; i < l; i ++ ) {\n\n\t\t\tvar curve = json.curves[ i ];\n\t\t\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\n\nexport { CurvePath };\n"]},"metadata":{},"sourceType":"module"}