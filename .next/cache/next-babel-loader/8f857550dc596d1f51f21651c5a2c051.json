{"ast":null,"code":"import _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\n\n/**\n * @author zz85 / https://github.com/zz85\n * @author bhouston / http://clara.io\n * @author Mugen87 / https://github.com/Mugen87\n */\nimport { Geometry } from '../core/Geometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { _Math } from '../math/Math.js'; // LatheGeometry\n\nfunction LatheGeometry(points, segments, phiStart, phiLength) {\n  Geometry.call(this);\n  this.type = 'LatheGeometry';\n  this.parameters = {\n    points: points,\n    segments: segments,\n    phiStart: phiStart,\n    phiLength: phiLength\n  };\n  this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));\n  this.mergeVertices();\n}\n\nLatheGeometry.prototype = _Object$create(Geometry.prototype);\nLatheGeometry.prototype.constructor = LatheGeometry; // LatheBufferGeometry\n\nfunction LatheBufferGeometry(points, segments, phiStart, phiLength) {\n  BufferGeometry.call(this);\n  this.type = 'LatheBufferGeometry';\n  this.parameters = {\n    points: points,\n    segments: segments,\n    phiStart: phiStart,\n    phiLength: phiLength\n  };\n  segments = Math.floor(segments) || 12;\n  phiStart = phiStart || 0;\n  phiLength = phiLength || Math.PI * 2; // clamp phiLength so it's in range of [ 0, 2PI ]\n\n  phiLength = _Math.clamp(phiLength, 0, Math.PI * 2); // buffers\n\n  var indices = [];\n  var vertices = [];\n  var uvs = []; // helper variables\n\n  var base;\n  var inverseSegments = 1.0 / segments;\n  var vertex = new Vector3();\n  var uv = new Vector2();\n  var i, j; // generate vertices and uvs\n\n  for (i = 0; i <= segments; i++) {\n    var phi = phiStart + i * inverseSegments * phiLength;\n    var sin = Math.sin(phi);\n    var cos = Math.cos(phi);\n\n    for (j = 0; j <= points.length - 1; j++) {\n      // vertex\n      vertex.x = points[j].x * sin;\n      vertex.y = points[j].y;\n      vertex.z = points[j].x * cos;\n      vertices.push(vertex.x, vertex.y, vertex.z); // uv\n\n      uv.x = i / segments;\n      uv.y = j / (points.length - 1);\n      uvs.push(uv.x, uv.y);\n    }\n  } // indices\n\n\n  for (i = 0; i < segments; i++) {\n    for (j = 0; j < points.length - 1; j++) {\n      base = j + i * points.length;\n      var a = base;\n      var b = base + points.length;\n      var c = base + points.length + 1;\n      var d = base + 1; // faces\n\n      indices.push(a, b, d);\n      indices.push(b, c, d);\n    }\n  } // build geometry\n\n\n  this.setIndex(indices);\n  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals\n\n  this.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.\n  // because the corresponding vertices are identical (but still have different UVs).\n\n  if (phiLength === Math.PI * 2) {\n    var normals = this.attributes.normal.array;\n    var n1 = new Vector3();\n    var n2 = new Vector3();\n    var n = new Vector3(); // this is the buffer offset for the last line of vertices\n\n    base = segments * points.length * 3;\n\n    for (i = 0, j = 0; i < points.length; i++, j += 3) {\n      // select the normal of the vertex in the first line\n      n1.x = normals[j + 0];\n      n1.y = normals[j + 1];\n      n1.z = normals[j + 2]; // select the normal of the vertex in the last line\n\n      n2.x = normals[base + j + 0];\n      n2.y = normals[base + j + 1];\n      n2.z = normals[base + j + 2]; // average normals\n\n      n.addVectors(n1, n2).normalize(); // assign the new values to both normals\n\n      normals[j + 0] = normals[base + j + 0] = n.x;\n      normals[j + 1] = normals[base + j + 1] = n.y;\n      normals[j + 2] = normals[base + j + 2] = n.z;\n    }\n  }\n}\n\nLatheBufferGeometry.prototype = _Object$create(BufferGeometry.prototype);\nLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\nexport { LatheGeometry, LatheBufferGeometry };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/geometries/LatheGeometry.js"],"names":["Geometry","Float32BufferAttribute","BufferGeometry","Vector3","Vector2","_Math","LatheGeometry","points","segments","phiStart","phiLength","call","type","parameters","fromBufferGeometry","LatheBufferGeometry","mergeVertices","prototype","constructor","Math","floor","PI","clamp","indices","vertices","uvs","base","inverseSegments","vertex","uv","i","j","phi","sin","cos","length","x","y","z","push","a","b","c","d","setIndex","setAttribute","computeVertexNormals","normals","attributes","normal","array","n1","n2","n","addVectors","normalize"],"mappings":"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","sourcesContent":["/**\n * @author zz85 / https://github.com/zz85\n * @author bhouston / http://clara.io\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nimport { Geometry } from '../core/Geometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { _Math } from '../math/Math.js';\n\n// LatheGeometry\n\nfunction LatheGeometry( points, segments, phiStart, phiLength ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'LatheGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\tthis.mergeVertices();\n\n}\n\nLatheGeometry.prototype = Object.create( Geometry.prototype );\nLatheGeometry.prototype.constructor = LatheGeometry;\n\n// LatheBufferGeometry\n\nfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'LatheBufferGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tsegments = Math.floor( segments ) || 12;\n\tphiStart = phiStart || 0;\n\tphiLength = phiLength || Math.PI * 2;\n\n\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\n\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\n\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar base;\n\tvar inverseSegments = 1.0 / segments;\n\tvar vertex = new Vector3();\n\tvar uv = new Vector2();\n\tvar i, j;\n\n\t// generate vertices and uvs\n\n\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\tvar sin = Math.sin( phi );\n\t\tvar cos = Math.cos( phi );\n\n\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\tvertex.y = points[ j ].y;\n\t\t\tvertex.z = points[ j ].x * cos;\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// uv\n\n\t\t\tuv.x = i / segments;\n\t\t\tuv.y = j / ( points.length - 1 );\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\tbase = j + i * points.length;\n\n\t\t\tvar a = base;\n\t\t\tvar b = base + points.length;\n\t\t\tvar c = base + points.length + 1;\n\t\t\tvar d = base + 1;\n\n\t\t\t// faces\n\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t// generate normals\n\n\tthis.computeVertexNormals();\n\n\t// if the geometry is closed, we need to average the normals along the seam.\n\t// because the corresponding vertices are identical (but still have different UVs).\n\n\tif ( phiLength === Math.PI * 2 ) {\n\n\t\tvar normals = this.attributes.normal.array;\n\t\tvar n1 = new Vector3();\n\t\tvar n2 = new Vector3();\n\t\tvar n = new Vector3();\n\n\t\t// this is the buffer offset for the last line of vertices\n\n\t\tbase = segments * points.length * 3;\n\n\t\tfor ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t// select the normal of the vertex in the first line\n\n\t\t\tn1.x = normals[ j + 0 ];\n\t\t\tn1.y = normals[ j + 1 ];\n\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t// select the normal of the vertex in the last line\n\n\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t// average normals\n\n\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t// assign the new values to both normals\n\n\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t}\n\n\t}\n\n}\n\nLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\n\n\nexport { LatheGeometry, LatheBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}