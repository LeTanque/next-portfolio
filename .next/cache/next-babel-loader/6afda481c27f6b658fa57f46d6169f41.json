{"ast":null,"code":"/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\nimport { Geometry } from '../core/Geometry.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js'; // BoxGeometry\n\nclass BoxGeometry extends Geometry {\n  constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {\n    super();\n    this.type = 'BoxGeometry';\n    this.parameters = {\n      width: width,\n      height: height,\n      depth: depth,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      depthSegments: depthSegments\n    };\n    this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));\n    this.mergeVertices();\n  }\n\n} // BoxBufferGeometry\n\n\nclass BoxBufferGeometry extends BufferGeometry {\n  constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {\n    super();\n    this.type = 'BoxBufferGeometry';\n    this.parameters = {\n      width: width,\n      height: height,\n      depth: depth,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      depthSegments: depthSegments\n    };\n    var scope = this;\n    width = width || 1;\n    height = height || 1;\n    depth = depth || 1; // segments\n\n    widthSegments = Math.floor(widthSegments) || 1;\n    heightSegments = Math.floor(heightSegments) || 1;\n    depthSegments = Math.floor(depthSegments) || 1; // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // helper variables\n\n    var numberOfVertices = 0;\n    var groupStart = 0; // build each side of the box geometry\n\n    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px\n\n    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx\n\n    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py\n\n    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny\n\n    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz\n\n    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {\n      var segmentWidth = width / gridX;\n      var segmentHeight = height / gridY;\n      var widthHalf = width / 2;\n      var heightHalf = height / 2;\n      var depthHalf = depth / 2;\n      var gridX1 = gridX + 1;\n      var gridY1 = gridY + 1;\n      var vertexCounter = 0;\n      var groupCount = 0;\n      var ix, iy;\n      var vector = new Vector3(); // generate vertices, normals and uvs\n\n      for (iy = 0; iy < gridY1; iy++) {\n        var y = iy * segmentHeight - heightHalf;\n\n        for (ix = 0; ix < gridX1; ix++) {\n          var x = ix * segmentWidth - widthHalf; // set values to correct vector component\n\n          vector[u] = x * udir;\n          vector[v] = y * vdir;\n          vector[w] = depthHalf; // now apply vector to vertex buffer\n\n          vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component\n\n          vector[u] = 0;\n          vector[v] = 0;\n          vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer\n\n          normals.push(vector.x, vector.y, vector.z); // uvs\n\n          uvs.push(ix / gridX);\n          uvs.push(1 - iy / gridY); // counters\n\n          vertexCounter += 1;\n        }\n      } // indices\n      // 1. you need three indices to draw a single face\n      // 2. a single segment consists of two faces\n      // 3. so we need to generate six (2*3) indices per segment\n\n\n      for (iy = 0; iy < gridY; iy++) {\n        for (ix = 0; ix < gridX; ix++) {\n          var a = numberOfVertices + ix + gridX1 * iy;\n          var b = numberOfVertices + ix + gridX1 * (iy + 1);\n          var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);\n          var d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d); // increase counter\n\n          groupCount += 6;\n        }\n      } // add a group to the geometry. this will ensure multi material support\n\n\n      scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups\n\n      groupStart += groupCount; // update total number of vertices\n\n      numberOfVertices += vertexCounter;\n    }\n  }\n\n}\n\nexport { BoxGeometry, BoxBufferGeometry };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/geometries/BoxGeometry.js"],"names":["Geometry","BufferGeometry","Float32BufferAttribute","Vector3","BoxGeometry","constructor","width","height","depth","widthSegments","heightSegments","depthSegments","type","parameters","fromBufferGeometry","BoxBufferGeometry","mergeVertices","scope","Math","floor","indices","vertices","normals","uvs","numberOfVertices","groupStart","buildPlane","setIndex","setAttribute","u","v","w","udir","vdir","gridX","gridY","materialIndex","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","groupCount","ix","iy","vector","y","x","push","z","a","b","c","d","addGroup"],"mappings":"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","sourcesContent":["/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nimport { Geometry } from '../core/Geometry.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\n// BoxGeometry\n\nclass BoxGeometry extends Geometry {\n\n\tconstructor( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'BoxGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n}\n\n// BoxBufferGeometry\n\nclass BoxBufferGeometry extends BufferGeometry {\n\n\tconstructor( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'BoxBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tvar scope = this;\n\n\t\twidth = width || 1;\n\t\theight = height || 1;\n\t\tdepth = depth || 1;\n\n\t\t// segments\n\n\t\twidthSegments = Math.floor( widthSegments ) || 1;\n\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\tdepthSegments = Math.floor( depthSegments ) || 1;\n\n\t\t// buffers\n\n\t\tvar indices = [];\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\t// helper variables\n\n\t\tvar numberOfVertices = 0;\n\t\tvar groupStart = 0;\n\n\t\t// build each side of the box geometry\n\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tvar segmentWidth = width / gridX;\n\t\t\tvar segmentHeight = height / gridY;\n\n\t\t\tvar widthHalf = width / 2;\n\t\t\tvar heightHalf = height / 2;\n\t\t\tvar depthHalf = depth / 2;\n\n\t\t\tvar gridX1 = gridX + 1;\n\t\t\tvar gridY1 = gridY + 1;\n\n\t\t\tvar vertexCounter = 0;\n\t\t\tvar groupCount = 0;\n\n\t\t\tvar ix, iy;\n\n\t\t\tvar vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tvar y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\n\t\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\n\t\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t\t\t// counters\n\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// increase counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n}\n\nexport { BoxGeometry, BoxBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}