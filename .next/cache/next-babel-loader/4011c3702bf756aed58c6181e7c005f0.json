{"ast":null,"code":"import _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\n\n/**\n * @author clockworkgeek / https://github.com/clockworkgeek\n * @author timothypratley / https://github.com/timothypratley\n * @author WestLangley / http://github.com/WestLangley\n * @author Mugen87 / https://github.com/Mugen87\n */\nimport { Geometry } from '../core/Geometry.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js'; // PolyhedronGeometry\n\nfunction PolyhedronGeometry(vertices, indices, radius, detail) {\n  Geometry.call(this);\n  this.type = 'PolyhedronGeometry';\n  this.parameters = {\n    vertices: vertices,\n    indices: indices,\n    radius: radius,\n    detail: detail\n  };\n  this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));\n  this.mergeVertices();\n}\n\nPolyhedronGeometry.prototype = _Object$create(Geometry.prototype);\nPolyhedronGeometry.prototype.constructor = PolyhedronGeometry; // PolyhedronBufferGeometry\n\nfunction PolyhedronBufferGeometry(vertices, indices, radius, detail) {\n  BufferGeometry.call(this);\n  this.type = 'PolyhedronBufferGeometry';\n  this.parameters = {\n    vertices: vertices,\n    indices: indices,\n    radius: radius,\n    detail: detail\n  };\n  radius = radius || 1;\n  detail = detail || 0; // default buffer data\n\n  var vertexBuffer = [];\n  var uvBuffer = []; // the subdivision creates the vertex buffer data\n\n  subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius\n\n  applyRadius(radius); // finally, create the uv data\n\n  generateUVs(); // build non-indexed geometry\n\n  this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));\n  this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));\n  this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));\n\n  if (detail === 0) {\n    this.computeVertexNormals(); // flat normals\n  } else {\n    this.normalizeNormals(); // smooth normals\n  } // helper functions\n\n\n  function subdivide(detail) {\n    var a = new Vector3();\n    var b = new Vector3();\n    var c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value\n\n    for (var i = 0; i < indices.length; i += 3) {\n      // get the vertices of the face\n      getVertexByIndex(indices[i + 0], a);\n      getVertexByIndex(indices[i + 1], b);\n      getVertexByIndex(indices[i + 2], c); // perform subdivision\n\n      subdivideFace(a, b, c, detail);\n    }\n  }\n\n  function subdivideFace(a, b, c, detail) {\n    var cols = Math.pow(2, detail); // we use this multidimensional array as a data structure for creating the subdivision\n\n    var v = [];\n    var i, j; // construct all of the vertices for this subdivision\n\n    for (i = 0; i <= cols; i++) {\n      v[i] = [];\n      var aj = a.clone().lerp(c, i / cols);\n      var bj = b.clone().lerp(c, i / cols);\n      var rows = cols - i;\n\n      for (j = 0; j <= rows; j++) {\n        if (j === 0 && i === cols) {\n          v[i][j] = aj;\n        } else {\n          v[i][j] = aj.clone().lerp(bj, j / rows);\n        }\n      }\n    } // construct all of the faces\n\n\n    for (i = 0; i < cols; i++) {\n      for (j = 0; j < 2 * (cols - i) - 1; j++) {\n        var k = Math.floor(j / 2);\n\n        if (j % 2 === 0) {\n          pushVertex(v[i][k + 1]);\n          pushVertex(v[i + 1][k]);\n          pushVertex(v[i][k]);\n        } else {\n          pushVertex(v[i][k + 1]);\n          pushVertex(v[i + 1][k + 1]);\n          pushVertex(v[i + 1][k]);\n        }\n      }\n    }\n  }\n\n  function applyRadius(radius) {\n    var vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex\n\n    for (var i = 0; i < vertexBuffer.length; i += 3) {\n      vertex.x = vertexBuffer[i + 0];\n      vertex.y = vertexBuffer[i + 1];\n      vertex.z = vertexBuffer[i + 2];\n      vertex.normalize().multiplyScalar(radius);\n      vertexBuffer[i + 0] = vertex.x;\n      vertexBuffer[i + 1] = vertex.y;\n      vertexBuffer[i + 2] = vertex.z;\n    }\n  }\n\n  function generateUVs() {\n    var vertex = new Vector3();\n\n    for (var i = 0; i < vertexBuffer.length; i += 3) {\n      vertex.x = vertexBuffer[i + 0];\n      vertex.y = vertexBuffer[i + 1];\n      vertex.z = vertexBuffer[i + 2];\n      var u = azimuth(vertex) / 2 / Math.PI + 0.5;\n      var v = inclination(vertex) / Math.PI + 0.5;\n      uvBuffer.push(u, 1 - v);\n    }\n\n    correctUVs();\n    correctSeam();\n  }\n\n  function correctSeam() {\n    // handle case when face straddles the seam, see #3269\n    for (var i = 0; i < uvBuffer.length; i += 6) {\n      // uv data of a single face\n      var x0 = uvBuffer[i + 0];\n      var x1 = uvBuffer[i + 2];\n      var x2 = uvBuffer[i + 4];\n      var max = Math.max(x0, x1, x2);\n      var min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary\n\n      if (max > 0.9 && min < 0.1) {\n        if (x0 < 0.2) uvBuffer[i + 0] += 1;\n        if (x1 < 0.2) uvBuffer[i + 2] += 1;\n        if (x2 < 0.2) uvBuffer[i + 4] += 1;\n      }\n    }\n  }\n\n  function pushVertex(vertex) {\n    vertexBuffer.push(vertex.x, vertex.y, vertex.z);\n  }\n\n  function getVertexByIndex(index, vertex) {\n    var stride = index * 3;\n    vertex.x = vertices[stride + 0];\n    vertex.y = vertices[stride + 1];\n    vertex.z = vertices[stride + 2];\n  }\n\n  function correctUVs() {\n    var a = new Vector3();\n    var b = new Vector3();\n    var c = new Vector3();\n    var centroid = new Vector3();\n    var uvA = new Vector2();\n    var uvB = new Vector2();\n    var uvC = new Vector2();\n\n    for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {\n      a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);\n      b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);\n      c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);\n      uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);\n      uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);\n      uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);\n      centroid.copy(a).add(b).add(c).divideScalar(3);\n      var azi = azimuth(centroid);\n      correctUV(uvA, j + 0, a, azi);\n      correctUV(uvB, j + 2, b, azi);\n      correctUV(uvC, j + 4, c, azi);\n    }\n  }\n\n  function correctUV(uv, stride, vector, azimuth) {\n    if (azimuth < 0 && uv.x === 1) {\n      uvBuffer[stride] = uv.x - 1;\n    }\n\n    if (vector.x === 0 && vector.z === 0) {\n      uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;\n    }\n  } // Angle around the Y axis, counter-clockwise when looking from above.\n\n\n  function azimuth(vector) {\n    return Math.atan2(vector.z, -vector.x);\n  } // Angle above the XZ plane.\n\n\n  function inclination(vector) {\n    return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));\n  }\n}\n\nPolyhedronBufferGeometry.prototype = _Object$create(BufferGeometry.prototype);\nPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\nexport { PolyhedronGeometry, PolyhedronBufferGeometry };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/geometries/PolyhedronGeometry.js"],"names":["Geometry","BufferGeometry","Float32BufferAttribute","Vector3","Vector2","PolyhedronGeometry","vertices","indices","radius","detail","call","type","parameters","fromBufferGeometry","PolyhedronBufferGeometry","mergeVertices","prototype","constructor","vertexBuffer","uvBuffer","subdivide","applyRadius","generateUVs","setAttribute","slice","computeVertexNormals","normalizeNormals","a","b","c","i","length","getVertexByIndex","subdivideFace","cols","Math","pow","v","j","aj","clone","lerp","bj","rows","k","floor","pushVertex","vertex","x","y","z","normalize","multiplyScalar","u","azimuth","PI","inclination","push","correctUVs","correctSeam","x0","x1","x2","max","min","index","stride","centroid","uvA","uvB","uvC","set","copy","add","divideScalar","azi","correctUV","uv","vector","atan2","sqrt"],"mappings":"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","sourcesContent":["/**\n * @author clockworkgeek / https://github.com/clockworkgeek\n * @author timothypratley / https://github.com/timothypratley\n * @author WestLangley / http://github.com/WestLangley\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nimport { Geometry } from '../core/Geometry.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\n\n// PolyhedronGeometry\n\nfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'PolyhedronGeometry';\n\n\tthis.parameters = {\n\t\tvertices: vertices,\n\t\tindices: indices,\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\n\tthis.mergeVertices();\n\n}\n\nPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\nPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\n\n// PolyhedronBufferGeometry\n\nfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'PolyhedronBufferGeometry';\n\n\tthis.parameters = {\n\t\tvertices: vertices,\n\t\tindices: indices,\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tradius = radius || 1;\n\tdetail = detail || 0;\n\n\t// default buffer data\n\n\tvar vertexBuffer = [];\n\tvar uvBuffer = [];\n\n\t// the subdivision creates the vertex buffer data\n\n\tsubdivide( detail );\n\n\t// all vertices should lie on a conceptual sphere with a given radius\n\n\tapplyRadius( radius );\n\n\t// finally, create the uv data\n\n\tgenerateUVs();\n\n\t// build non-indexed geometry\n\n\tthis.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\n\tthis.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\n\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\n\n\tif ( detail === 0 ) {\n\n\t\tthis.computeVertexNormals(); // flat normals\n\n\t} else {\n\n\t\tthis.normalizeNormals(); // smooth normals\n\n\t}\n\n\t// helper functions\n\n\tfunction subdivide( detail ) {\n\n\t\tvar a = new Vector3();\n\t\tvar b = new Vector3();\n\t\tvar c = new Vector3();\n\n\t\t// iterate over all faces and apply a subdivison with the given detail value\n\n\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t// get the vertices of the face\n\n\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t// perform subdivision\n\n\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t}\n\n\t}\n\n\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\tvar cols = Math.pow( 2, detail );\n\n\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\tvar v = [];\n\n\t\tvar i, j;\n\n\t\t// construct all of the vertices for this subdivision\n\n\t\tfor ( i = 0; i <= cols; i ++ ) {\n\n\t\t\tv[ i ] = [];\n\n\t\t\tvar aj = a.clone().lerp( c, i / cols );\n\t\t\tvar bj = b.clone().lerp( c, i / cols );\n\n\t\t\tvar rows = cols - i;\n\n\t\t\tfor ( j = 0; j <= rows; j ++ ) {\n\n\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// construct all of the faces\n\n\t\tfor ( i = 0; i < cols; i ++ ) {\n\n\t\t\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\tvar k = Math.floor( j / 2 );\n\n\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction applyRadius( radius ) {\n\n\t\tvar vertex = new Vector3();\n\n\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t}\n\n\t}\n\n\tfunction generateUVs() {\n\n\t\tvar vertex = new Vector3();\n\n\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\tvar v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t}\n\n\t\tcorrectUVs();\n\n\t\tcorrectSeam();\n\n\t}\n\n\tfunction correctSeam() {\n\n\t\t// handle case when face straddles the seam, see #3269\n\n\t\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t// uv data of a single face\n\n\t\t\tvar x0 = uvBuffer[ i + 0 ];\n\t\t\tvar x1 = uvBuffer[ i + 2 ];\n\t\t\tvar x2 = uvBuffer[ i + 4 ];\n\n\t\t\tvar max = Math.max( x0, x1, x2 );\n\t\t\tvar min = Math.min( x0, x1, x2 );\n\n\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction pushVertex( vertex ) {\n\n\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t}\n\n\tfunction getVertexByIndex( index, vertex ) {\n\n\t\tvar stride = index * 3;\n\n\t\tvertex.x = vertices[ stride + 0 ];\n\t\tvertex.y = vertices[ stride + 1 ];\n\t\tvertex.z = vertices[ stride + 2 ];\n\n\t}\n\n\tfunction correctUVs() {\n\n\t\tvar a = new Vector3();\n\t\tvar b = new Vector3();\n\t\tvar c = new Vector3();\n\n\t\tvar centroid = new Vector3();\n\n\t\tvar uvA = new Vector2();\n\t\tvar uvB = new Vector2();\n\t\tvar uvC = new Vector2();\n\n\t\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\tvar azi = azimuth( centroid );\n\n\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t}\n\n\t}\n\n\tfunction correctUV( uv, stride, vector, azimuth ) {\n\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\tuvBuffer[ stride ] = uv.x - 1;\n\n\t\t}\n\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t}\n\n\t}\n\n\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\tfunction azimuth( vector ) {\n\n\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t}\n\n\n\t// Angle above the XZ plane.\n\n\tfunction inclination( vector ) {\n\n\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t}\n\n}\n\nPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\n\n\nexport { PolyhedronGeometry, PolyhedronBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}