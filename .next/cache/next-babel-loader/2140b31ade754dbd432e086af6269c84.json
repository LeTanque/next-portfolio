{"ast":null,"code":"/**\n * @author mrdoob / http://mrdoob.com/\n */\nfunction absNumericalSort(a, b) {\n  return Math.abs(b[1]) - Math.abs(a[1]);\n}\n\nfunction WebGLMorphtargets(gl) {\n  var influencesList = {};\n  var morphInfluences = new Float32Array(8);\n\n  function update(object, geometry, material, program) {\n    var objectInfluences = object.morphTargetInfluences; // When object doesn't have morph target influences defined, we treat it as a 0-length array\n    // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n\n    var length = objectInfluences === undefined ? 0 : objectInfluences.length;\n    var influences = influencesList[geometry.id];\n\n    if (influences === undefined) {\n      // initialise list\n      influences = [];\n\n      for (var i = 0; i < length; i++) {\n        influences[i] = [i, 0];\n      }\n\n      influencesList[geometry.id] = influences;\n    }\n\n    var morphTargets = material.morphTargets && geometry.morphAttributes.position;\n    var morphNormals = material.morphNormals && geometry.morphAttributes.normal; // Remove current morphAttributes\n\n    for (var i = 0; i < length; i++) {\n      var influence = influences[i];\n\n      if (influence[1] !== 0) {\n        if (morphTargets) geometry.deleteAttribute('morphTarget' + i);\n        if (morphNormals) geometry.deleteAttribute('morphNormal' + i);\n      }\n    } // Collect influences\n\n\n    for (var i = 0; i < length; i++) {\n      var influence = influences[i];\n      influence[0] = i;\n      influence[1] = objectInfluences[i];\n    }\n\n    influences.sort(absNumericalSort); // Add morphAttributes\n\n    var morphInfluencesSum = 0;\n\n    for (var i = 0; i < 8; i++) {\n      var influence = influences[i];\n\n      if (influence) {\n        var index = influence[0];\n        var value = influence[1];\n\n        if (value) {\n          if (morphTargets) geometry.setAttribute('morphTarget' + i, morphTargets[index]);\n          if (morphNormals) geometry.setAttribute('morphNormal' + i, morphNormals[index]);\n          morphInfluences[i] = value;\n          morphInfluencesSum += value;\n          continue;\n        }\n      }\n\n      morphInfluences[i] = 0;\n    } // GLSL shader uses formula baseinfluence * base + sum(target * influence)\n    // This allows us to switch between absolute morphs and relative morphs without changing shader code\n    // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n\n\n    var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n    program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n    program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);\n  }\n\n  return {\n    update: update\n  };\n}\n\nexport { WebGLMorphtargets };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/renderers/webgl/WebGLMorphtargets.js"],"names":["absNumericalSort","a","b","Math","abs","WebGLMorphtargets","gl","influencesList","morphInfluences","Float32Array","update","object","geometry","material","program","objectInfluences","morphTargetInfluences","length","undefined","influences","id","i","morphTargets","morphAttributes","position","morphNormals","normal","influence","deleteAttribute","sort","morphInfluencesSum","index","value","setAttribute","morphBaseInfluence","morphTargetsRelative","getUniforms","setValue"],"mappings":"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","sourcesContent":["/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction absNumericalSort( a, b ) {\n\n\treturn Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );\n\n}\n\nfunction WebGLMorphtargets( gl ) {\n\n\tvar influencesList = {};\n\tvar morphInfluences = new Float32Array( 8 );\n\n\tfunction update( object, geometry, material, program ) {\n\n\t\tvar objectInfluences = object.morphTargetInfluences;\n\n\t\t// When object doesn't have morph target influences defined, we treat it as a 0-length array\n\t\t// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n\n\t\tvar length = objectInfluences === undefined ? 0 : objectInfluences.length;\n\n\t\tvar influences = influencesList[ geometry.id ];\n\n\t\tif ( influences === undefined ) {\n\n\t\t\t// initialise list\n\n\t\t\tinfluences = [];\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\tinfluences[ i ] = [ i, 0 ];\n\n\t\t\t}\n\n\t\t\tinfluencesList[ geometry.id ] = influences;\n\n\t\t}\n\n\t\tvar morphTargets = material.morphTargets && geometry.morphAttributes.position;\n\t\tvar morphNormals = material.morphNormals && geometry.morphAttributes.normal;\n\n\t\t// Remove current morphAttributes\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tvar influence = influences[ i ];\n\n\t\t\tif ( influence[ 1 ] !== 0 ) {\n\n\t\t\t\tif ( morphTargets ) geometry.deleteAttribute( 'morphTarget' + i );\n\t\t\t\tif ( morphNormals ) geometry.deleteAttribute( 'morphNormal' + i );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Collect influences\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tvar influence = influences[ i ];\n\n\t\t\tinfluence[ 0 ] = i;\n\t\t\tinfluence[ 1 ] = objectInfluences[ i ];\n\n\t\t}\n\n\t\tinfluences.sort( absNumericalSort );\n\n\t\t// Add morphAttributes\n\n\t\tvar morphInfluencesSum = 0;\n\n\t\tfor ( var i = 0; i < 8; i ++ ) {\n\n\t\t\tvar influence = influences[ i ];\n\n\t\t\tif ( influence ) {\n\n\t\t\t\tvar index = influence[ 0 ];\n\t\t\t\tvar value = influence[ 1 ];\n\n\t\t\t\tif ( value ) {\n\n\t\t\t\t\tif ( morphTargets ) geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );\n\t\t\t\t\tif ( morphNormals ) geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );\n\n\t\t\t\t\tmorphInfluences[ i ] = value;\n\t\t\t\t\tmorphInfluencesSum += value;\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmorphInfluences[ i ] = 0;\n\n\t\t}\n\n\t\t// GLSL shader uses formula baseinfluence * base + sum(target * influence)\n\t\t// This allows us to switch between absolute morphs and relative morphs without changing shader code\n\t\t// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n\t\tvar morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\n\t\tprogram.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );\n\t\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );\n\n\t}\n\n\treturn {\n\n\t\tupdate: update\n\n\t};\n\n}\n\n\nexport { WebGLMorphtargets };\n"]},"metadata":{},"sourceType":"module"}