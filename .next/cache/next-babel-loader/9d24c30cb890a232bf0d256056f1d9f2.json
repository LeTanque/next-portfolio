{"ast":null,"code":"import _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport { DataTexture, FloatType, Math as _Math, Mesh, OrthographicCamera, PlaneBufferGeometry, RGBFormat, Scene, ShaderMaterial, UniformsUtils, Vector2 } from \"three/src/Three\";\nimport { WaterShader } from \"../shaders/WaterShader.js\";\nimport { Pass } from \"./Pass.js\";\n\nvar WaterPass = function (dt_size) {\n  Pass.call(this);\n  if (WaterShader === undefined) console.error(\"THREE.WaterPass relies on THREE.WaterShader\");\n  var shader = WaterShader;\n  this.uniforms = UniformsUtils.clone(shader.uniforms);\n  if (dt_size === undefined) dt_size = 64;\n  this.uniforms[\"resolution\"].value = new Vector2(dt_size, dt_size);\n  this.material = new ShaderMaterial({\n    uniforms: this.uniforms,\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader\n  });\n  this.camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n  this.scene = new Scene();\n  this.quad = new Mesh(new PlaneBufferGeometry(2, 2), null);\n  this.quad.frustumCulled = false; // Avoid getting clipped\n\n  this.scene.add(this.quad);\n  this.factor = 0;\n  this.time = 0;\n};\n\nWaterPass.prototype = _Object$assign(_Object$create(Pass.prototype), {\n  constructor: WaterPass,\n  render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    const factor = Math.max(0, this.factor);\n    this.uniforms[\"byp\"].value = factor ? 0 : 1;\n    this.uniforms[\"texture\"].value = readBuffer.texture;\n    this.uniforms[\"time\"].value = this.time;\n    this.uniforms[\"factor\"].value = this.factor;\n    this.time += 0.05;\n    this.quad.material = this.material;\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      renderer.render(this.scene, this.camera);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n      renderer.render(this.scene, this.camera);\n    }\n  }\n});\nexport { WaterPass };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/components/threejs-render/resources/postprocessing/WaterPass.js"],"names":["Math","WaterPass","Pass","WaterShader","console","shader","UniformsUtils","dt_size","uniforms","vertexShader","fragmentShader","constructor","render","factor","readBuffer","renderer"],"mappings":"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","sourcesContent":["import {\n    DataTexture,\n    FloatType,\n    Math as _Math,\n    Mesh,\n    OrthographicCamera,\n    PlaneBufferGeometry,\n    RGBFormat,\n    Scene,\n    ShaderMaterial,\n    UniformsUtils,\n    Vector2\n} from \"three/src/Three\";\nimport { WaterShader } from \"../shaders/WaterShader.js\";\nimport { Pass } from \"./Pass.js\";\n\nvar WaterPass = function(dt_size) {\n    Pass.call(this);\n    if (WaterShader === undefined)\n        console.error(\"THREE.WaterPass relies on THREE.WaterShader\");\n    var shader = WaterShader;\n    this.uniforms = UniformsUtils.clone(shader.uniforms);\n    if (dt_size === undefined) dt_size = 64;\n    this.uniforms[\"resolution\"].value = new Vector2(dt_size, dt_size);\n    this.material = new ShaderMaterial({\n        uniforms: this.uniforms,\n        vertexShader: shader.vertexShader,\n        fragmentShader: shader.fragmentShader\n    });\n    this.camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    this.scene = new Scene();\n    this.quad = new Mesh(new PlaneBufferGeometry(2, 2), null);\n    this.quad.frustumCulled = false; // Avoid getting clipped\n    this.scene.add(this.quad);\n    this.factor = 0;\n    this.time = 0;\n};\n\nWaterPass.prototype = Object.assign(Object.create(Pass.prototype), {\n    constructor: WaterPass,\n\n    render: function(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n        const factor = Math.max(0, this.factor);\n        this.uniforms[\"byp\"].value = factor ? 0 : 1;\n        this.uniforms[\"texture\"].value = readBuffer.texture;\n        this.uniforms[\"time\"].value = this.time;\n        this.uniforms[\"factor\"].value = this.factor;\n        this.time += 0.05;\n        this.quad.material = this.material;\n        if (this.renderToScreen) {\n            renderer.setRenderTarget(null);\n            renderer.render(this.scene, this.camera);\n        } else {\n            renderer.setRenderTarget(writeBuffer);\n            if (this.clear) renderer.clear();\n            renderer.render(this.scene, this.camera);\n        }\n    }\n});\n\nexport { WaterPass };\n"]},"metadata":{},"sourceType":"module"}