{"ast":null,"code":"import _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\n\n/**\n * @author zz85 / https://github.com/zz85\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n */\nimport { Geometry } from '../core/Geometry.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js'; // ParametricGeometry\n\nfunction ParametricGeometry(func, slices, stacks) {\n  Geometry.call(this);\n  this.type = 'ParametricGeometry';\n  this.parameters = {\n    func: func,\n    slices: slices,\n    stacks: stacks\n  };\n  this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));\n  this.mergeVertices();\n}\n\nParametricGeometry.prototype = _Object$create(Geometry.prototype);\nParametricGeometry.prototype.constructor = ParametricGeometry; // ParametricBufferGeometry\n\nfunction ParametricBufferGeometry(func, slices, stacks) {\n  BufferGeometry.call(this);\n  this.type = 'ParametricBufferGeometry';\n  this.parameters = {\n    func: func,\n    slices: slices,\n    stacks: stacks\n  }; // buffers\n\n  var indices = [];\n  var vertices = [];\n  var normals = [];\n  var uvs = [];\n  var EPS = 0.00001;\n  var normal = new Vector3();\n  var p0 = new Vector3(),\n      p1 = new Vector3();\n  var pu = new Vector3(),\n      pv = new Vector3();\n  var i, j;\n\n  if (func.length < 3) {\n    console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');\n  } // generate vertices, normals and uvs\n\n\n  var sliceCount = slices + 1;\n\n  for (i = 0; i <= stacks; i++) {\n    var v = i / stacks;\n\n    for (j = 0; j <= slices; j++) {\n      var u = j / slices; // vertex\n\n      func(u, v, p0);\n      vertices.push(p0.x, p0.y, p0.z); // normal\n      // approximate tangent vectors via finite differences\n\n      if (u - EPS >= 0) {\n        func(u - EPS, v, p1);\n        pu.subVectors(p0, p1);\n      } else {\n        func(u + EPS, v, p1);\n        pu.subVectors(p1, p0);\n      }\n\n      if (v - EPS >= 0) {\n        func(u, v - EPS, p1);\n        pv.subVectors(p0, p1);\n      } else {\n        func(u, v + EPS, p1);\n        pv.subVectors(p1, p0);\n      } // cross product of tangent vectors returns surface normal\n\n\n      normal.crossVectors(pu, pv).normalize();\n      normals.push(normal.x, normal.y, normal.z); // uv\n\n      uvs.push(u, v);\n    }\n  } // generate indices\n\n\n  for (i = 0; i < stacks; i++) {\n    for (j = 0; j < slices; j++) {\n      var a = i * sliceCount + j;\n      var b = i * sliceCount + j + 1;\n      var c = (i + 1) * sliceCount + j + 1;\n      var d = (i + 1) * sliceCount + j; // faces one and two\n\n      indices.push(a, b, d);\n      indices.push(b, c, d);\n    }\n  } // build geometry\n\n\n  this.setIndex(indices);\n  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n  this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n}\n\nParametricBufferGeometry.prototype = _Object$create(BufferGeometry.prototype);\nParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\nexport { ParametricGeometry, ParametricBufferGeometry };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/geometries/ParametricGeometry.js"],"names":["Geometry","BufferGeometry","Float32BufferAttribute","Vector3","ParametricGeometry","func","slices","stacks","call","type","parameters","fromBufferGeometry","ParametricBufferGeometry","mergeVertices","prototype","constructor","indices","vertices","normals","uvs","EPS","normal","p0","p1","pu","pv","i","j","length","console","error","sliceCount","v","u","push","x","y","z","subVectors","crossVectors","normalize","a","b","c","d","setIndex","setAttribute"],"mappings":"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","sourcesContent":["/**\n * @author zz85 / https://github.com/zz85\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n */\n\nimport { Geometry } from '../core/Geometry.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\n// ParametricGeometry\n\nfunction ParametricGeometry( func, slices, stacks ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'ParametricGeometry';\n\n\tthis.parameters = {\n\t\tfunc: func,\n\t\tslices: slices,\n\t\tstacks: stacks\n\t};\n\n\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\n\tthis.mergeVertices();\n\n}\n\nParametricGeometry.prototype = Object.create( Geometry.prototype );\nParametricGeometry.prototype.constructor = ParametricGeometry;\n\n// ParametricBufferGeometry\n\nfunction ParametricBufferGeometry( func, slices, stacks ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'ParametricBufferGeometry';\n\n\tthis.parameters = {\n\t\tfunc: func,\n\t\tslices: slices,\n\t\tstacks: stacks\n\t};\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\tvar EPS = 0.00001;\n\n\tvar normal = new Vector3();\n\n\tvar p0 = new Vector3(), p1 = new Vector3();\n\tvar pu = new Vector3(), pv = new Vector3();\n\n\tvar i, j;\n\n\tif ( func.length < 3 ) {\n\n\t\tconsole.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );\n\n\t}\n\n\t// generate vertices, normals and uvs\n\n\tvar sliceCount = slices + 1;\n\n\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\tvar v = i / stacks;\n\n\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\tvar u = j / slices;\n\n\t\t\t// vertex\n\n\t\t\tfunc( u, v, p0 );\n\t\t\tvertices.push( p0.x, p0.y, p0.z );\n\n\t\t\t// normal\n\n\t\t\t// approximate tangent vectors via finite differences\n\n\t\t\tif ( u - EPS >= 0 ) {\n\n\t\t\t\tfunc( u - EPS, v, p1 );\n\t\t\t\tpu.subVectors( p0, p1 );\n\n\t\t\t} else {\n\n\t\t\t\tfunc( u + EPS, v, p1 );\n\t\t\t\tpu.subVectors( p1, p0 );\n\n\t\t\t}\n\n\t\t\tif ( v - EPS >= 0 ) {\n\n\t\t\t\tfunc( u, v - EPS, p1 );\n\t\t\t\tpv.subVectors( p0, p1 );\n\n\t\t\t} else {\n\n\t\t\t\tfunc( u, v + EPS, p1 );\n\t\t\t\tpv.subVectors( p1, p0 );\n\n\t\t\t}\n\n\t\t\t// cross product of tangent vectors returns surface normal\n\n\t\t\tnormal.crossVectors( pu, pv ).normalize();\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t// uv\n\n\t\t\tuvs.push( u, v );\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\tvar a = i * sliceCount + j;\n\t\t\tvar b = i * sliceCount + j + 1;\n\t\t\tvar c = ( i + 1 ) * sliceCount + j + 1;\n\t\t\tvar d = ( i + 1 ) * sliceCount + j;\n\n\t\t\t// faces one and two\n\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n}\n\nParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\n\n\nexport { ParametricGeometry, ParametricBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}