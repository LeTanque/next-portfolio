{"ast":null,"code":"import _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport { Quaternion } from '../math/Quaternion.js';\n/**\n *\n * Buffered scene graph property that allows weighted accumulation.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction PropertyMixer(binding, typeName, valueSize) {\n  this.binding = binding;\n  this.valueSize = valueSize;\n  var bufferType = Float64Array,\n      mixFunction;\n\n  switch (typeName) {\n    case 'quaternion':\n      mixFunction = this._slerp;\n      break;\n\n    case 'string':\n    case 'bool':\n      bufferType = Array;\n      mixFunction = this._select;\n      break;\n\n    default:\n      mixFunction = this._lerp;\n  }\n\n  this.buffer = new bufferType(valueSize * 4); // layout: [ incoming | accu0 | accu1 | orig ]\n  //\n  // interpolators can use .buffer as their .result\n  // the data then goes to 'incoming'\n  //\n  // 'accu0' and 'accu1' are used frame-interleaved for\n  // the cumulative result and are compared to detect\n  // changes\n  //\n  // 'orig' stores the original state of the property\n\n  this._mixBufferRegion = mixFunction;\n  this.cumulativeWeight = 0;\n  this.useCount = 0;\n  this.referenceCount = 0;\n}\n\n_Object$assign(PropertyMixer.prototype, {\n  // accumulate data in the 'incoming' region into 'accu<i>'\n  accumulate: function accumulate(accuIndex, weight) {\n    // note: happily accumulating nothing when weight = 0, the caller knows\n    // the weight and shouldn't have made the call in the first place\n    var buffer = this.buffer,\n        stride = this.valueSize,\n        offset = accuIndex * stride + stride,\n        currentWeight = this.cumulativeWeight;\n\n    if (currentWeight === 0) {\n      // accuN := incoming * weight\n      for (var i = 0; i !== stride; ++i) {\n        buffer[offset + i] = buffer[i];\n      }\n\n      currentWeight = weight;\n    } else {\n      // accuN := accuN + incoming * weight\n      currentWeight += weight;\n      var mix = weight / currentWeight;\n\n      this._mixBufferRegion(buffer, offset, 0, mix, stride);\n    }\n\n    this.cumulativeWeight = currentWeight;\n  },\n  // apply the state of 'accu<i>' to the binding when accus differ\n  apply: function apply(accuIndex) {\n    var stride = this.valueSize,\n        buffer = this.buffer,\n        offset = accuIndex * stride + stride,\n        weight = this.cumulativeWeight,\n        binding = this.binding;\n    this.cumulativeWeight = 0;\n\n    if (weight < 1) {\n      // accuN := accuN + original * ( 1 - cumulativeWeight )\n      var originalValueOffset = stride * 3;\n\n      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);\n    }\n\n    for (var i = stride, e = stride + stride; i !== e; ++i) {\n      if (buffer[i] !== buffer[i + stride]) {\n        // value has changed -> update scene graph\n        binding.setValue(buffer, offset);\n        break;\n      }\n    }\n  },\n  // remember the state of the bound property and copy it to both accus\n  saveOriginalState: function saveOriginalState() {\n    var binding = this.binding;\n    var buffer = this.buffer,\n        stride = this.valueSize,\n        originalValueOffset = stride * 3;\n    binding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original\n\n    for (var i = stride, e = originalValueOffset; i !== e; ++i) {\n      buffer[i] = buffer[originalValueOffset + i % stride];\n    }\n\n    this.cumulativeWeight = 0;\n  },\n  // apply the state previously taken via 'saveOriginalState' to the binding\n  restoreOriginalState: function restoreOriginalState() {\n    var originalValueOffset = this.valueSize * 3;\n    this.binding.setValue(this.buffer, originalValueOffset);\n  },\n  // mix functions\n  _select: function _select(buffer, dstOffset, srcOffset, t, stride) {\n    if (t >= 0.5) {\n      for (var i = 0; i !== stride; ++i) {\n        buffer[dstOffset + i] = buffer[srcOffset + i];\n      }\n    }\n  },\n  _slerp: function _slerp(buffer, dstOffset, srcOffset, t) {\n    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);\n  },\n  _lerp: function _lerp(buffer, dstOffset, srcOffset, t, stride) {\n    var s = 1 - t;\n\n    for (var i = 0; i !== stride; ++i) {\n      var j = dstOffset + i;\n      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;\n    }\n  }\n});\n\nexport { PropertyMixer };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/animation/PropertyMixer.js"],"names":["Quaternion","PropertyMixer","binding","typeName","valueSize","bufferType","Float64Array","mixFunction","_slerp","Array","_select","_lerp","buffer","_mixBufferRegion","cumulativeWeight","useCount","referenceCount","prototype","accumulate","accuIndex","weight","stride","offset","currentWeight","i","mix","apply","originalValueOffset","e","setValue","saveOriginalState","getValue","restoreOriginalState","dstOffset","srcOffset","t","slerpFlat","s","j"],"mappings":"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","sourcesContent":["import { Quaternion } from '../math/Quaternion.js';\n\n/**\n *\n * Buffered scene graph property that allows weighted accumulation.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction PropertyMixer( binding, typeName, valueSize ) {\n\n\tthis.binding = binding;\n\tthis.valueSize = valueSize;\n\n\tvar bufferType = Float64Array,\n\t\tmixFunction;\n\n\tswitch ( typeName ) {\n\n\t\tcase 'quaternion':\n\t\t\tmixFunction = this._slerp;\n\t\t\tbreak;\n\n\t\tcase 'string':\n\t\tcase 'bool':\n\t\t\tbufferType = Array;\n\t\t\tmixFunction = this._select;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tmixFunction = this._lerp;\n\n\t}\n\n\tthis.buffer = new bufferType( valueSize * 4 );\n\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t//\n\t// interpolators can use .buffer as their .result\n\t// the data then goes to 'incoming'\n\t//\n\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t// the cumulative result and are compared to detect\n\t// changes\n\t//\n\t// 'orig' stores the original state of the property\n\n\tthis._mixBufferRegion = mixFunction;\n\n\tthis.cumulativeWeight = 0;\n\n\tthis.useCount = 0;\n\tthis.referenceCount = 0;\n\n}\n\nObject.assign( PropertyMixer.prototype, {\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate: function ( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tcurrentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tvar mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t},\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply: function ( accuIndex ) {\n\n\t\tvar stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tvar originalValueOffset = stride * 3;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState: function () {\n\n\t\tvar binding = this.binding;\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * 3;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\tthis.cumulativeWeight = 0;\n\n\t},\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState: function () {\n\n\t\tvar originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t},\n\n\n\t// mix functions\n\n\t_select: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_slerp: function ( buffer, dstOffset, srcOffset, t ) {\n\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n\t},\n\n\t_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tvar s = 1 - t;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tvar j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n} );\n\n\nexport { PropertyMixer };\n"]},"metadata":{},"sourceType":"module"}