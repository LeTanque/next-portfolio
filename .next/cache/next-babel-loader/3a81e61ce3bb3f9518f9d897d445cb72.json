{"ast":null,"code":"import _Number$EPSILON from \"@babel/runtime-corejs2/core-js/number/epsilon\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport { _Math } from '../../math/Math.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Extensible curve object\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\n/**************************************************************\n *\tAbstract Curve base class\n **************************************************************/\n\nfunction Curve() {\n  this.type = 'Curve';\n  this.arcLengthDivisions = 200;\n}\n\n_Object$assign(Curve.prototype, {\n  // Virtual base class method to overwrite and implement in subclasses\n  //\t- t [0 .. 1]\n  getPoint: function ()\n  /* t, optionalTarget */\n  {\n    console.warn('THREE.Curve: .getPoint() not implemented.');\n    return null;\n  },\n  // Get point at relative position in curve according to arc length\n  // - u [0 .. 1]\n  getPointAt: function (u, optionalTarget) {\n    var t = this.getUtoTmapping(u);\n    return this.getPoint(t, optionalTarget);\n  },\n  // Get sequence of points using getPoint( t )\n  getPoints: function (divisions) {\n    if (divisions === undefined) divisions = 5;\n    var points = [];\n\n    for (var d = 0; d <= divisions; d++) {\n      points.push(this.getPoint(d / divisions));\n    }\n\n    return points;\n  },\n  // Get sequence of points using getPointAt( u )\n  getSpacedPoints: function (divisions) {\n    if (divisions === undefined) divisions = 5;\n    var points = [];\n\n    for (var d = 0; d <= divisions; d++) {\n      points.push(this.getPointAt(d / divisions));\n    }\n\n    return points;\n  },\n  // Get total curve arc length\n  getLength: function () {\n    var lengths = this.getLengths();\n    return lengths[lengths.length - 1];\n  },\n  // Get list of cumulative segment lengths\n  getLengths: function (divisions) {\n    if (divisions === undefined) divisions = this.arcLengthDivisions;\n\n    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {\n      return this.cacheArcLengths;\n    }\n\n    this.needsUpdate = false;\n    var cache = [];\n    var current,\n        last = this.getPoint(0);\n    var p,\n        sum = 0;\n    cache.push(0);\n\n    for (p = 1; p <= divisions; p++) {\n      current = this.getPoint(p / divisions);\n      sum += current.distanceTo(last);\n      cache.push(sum);\n      last = current;\n    }\n\n    this.cacheArcLengths = cache;\n    return cache; // { sums: cache, sum: sum }; Sum is in the last element.\n  },\n  updateArcLengths: function () {\n    this.needsUpdate = true;\n    this.getLengths();\n  },\n  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n  getUtoTmapping: function (u, distance) {\n    var arcLengths = this.getLengths();\n    var i = 0,\n        il = arcLengths.length;\n    var targetArcLength; // The targeted u distance value to get\n\n    if (distance) {\n      targetArcLength = distance;\n    } else {\n      targetArcLength = u * arcLengths[il - 1];\n    } // binary search for the index with largest value smaller than target u distance\n\n\n    var low = 0,\n        high = il - 1,\n        comparison;\n\n    while (low <= high) {\n      i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n      comparison = arcLengths[i] - targetArcLength;\n\n      if (comparison < 0) {\n        low = i + 1;\n      } else if (comparison > 0) {\n        high = i - 1;\n      } else {\n        high = i;\n        break; // DONE\n      }\n    }\n\n    i = high;\n\n    if (arcLengths[i] === targetArcLength) {\n      return i / (il - 1);\n    } // we could get finer grain at lengths, or use simple interpolation between two points\n\n\n    var lengthBefore = arcLengths[i];\n    var lengthAfter = arcLengths[i + 1];\n    var segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points\n\n    var segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t\n\n    var t = (i + segmentFraction) / (il - 1);\n    return t;\n  },\n  // Returns a unit vector tangent at t\n  // In case any sub curve does not implement its tangent derivation,\n  // 2 points a small delta apart will be used to find its gradient\n  // which seems to give a reasonable approximation\n  getTangent: function (t) {\n    var delta = 0.0001;\n    var t1 = t - delta;\n    var t2 = t + delta; // Capping in case of danger\n\n    if (t1 < 0) t1 = 0;\n    if (t2 > 1) t2 = 1;\n    var pt1 = this.getPoint(t1);\n    var pt2 = this.getPoint(t2);\n    var vec = pt2.clone().sub(pt1);\n    return vec.normalize();\n  },\n  getTangentAt: function (u) {\n    var t = this.getUtoTmapping(u);\n    return this.getTangent(t);\n  },\n  computeFrenetFrames: function (segments, closed) {\n    // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n    var normal = new Vector3();\n    var tangents = [];\n    var normals = [];\n    var binormals = [];\n    var vec = new Vector3();\n    var mat = new Matrix4();\n    var i, u, theta; // compute the tangent vectors for each segment on the curve\n\n    for (i = 0; i <= segments; i++) {\n      u = i / segments;\n      tangents[i] = this.getTangentAt(u);\n      tangents[i].normalize();\n    } // select an initial normal vector perpendicular to the first tangent vector,\n    // and in the direction of the minimum tangent xyz component\n\n\n    normals[0] = new Vector3();\n    binormals[0] = new Vector3();\n    var min = Number.MAX_VALUE;\n    var tx = Math.abs(tangents[0].x);\n    var ty = Math.abs(tangents[0].y);\n    var tz = Math.abs(tangents[0].z);\n\n    if (tx <= min) {\n      min = tx;\n      normal.set(1, 0, 0);\n    }\n\n    if (ty <= min) {\n      min = ty;\n      normal.set(0, 1, 0);\n    }\n\n    if (tz <= min) {\n      normal.set(0, 0, 1);\n    }\n\n    vec.crossVectors(tangents[0], normal).normalize();\n    normals[0].crossVectors(tangents[0], vec);\n    binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n    for (i = 1; i <= segments; i++) {\n      normals[i] = normals[i - 1].clone();\n      binormals[i] = binormals[i - 1].clone();\n      vec.crossVectors(tangents[i - 1], tangents[i]);\n\n      if (vec.length() > _Number$EPSILON) {\n        vec.normalize();\n        theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors\n\n        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));\n      }\n\n      binormals[i].crossVectors(tangents[i], normals[i]);\n    } // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\n    if (closed === true) {\n      theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));\n      theta /= segments;\n\n      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {\n        theta = -theta;\n      }\n\n      for (i = 1; i <= segments; i++) {\n        // twist a little...\n        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));\n        binormals[i].crossVectors(tangents[i], normals[i]);\n      }\n    }\n\n    return {\n      tangents: tangents,\n      normals: normals,\n      binormals: binormals\n    };\n  },\n  clone: function () {\n    return new this.constructor().copy(this);\n  },\n  copy: function (source) {\n    this.arcLengthDivisions = source.arcLengthDivisions;\n    return this;\n  },\n  toJSON: function () {\n    var data = {\n      metadata: {\n        version: 4.5,\n        type: 'Curve',\n        generator: 'Curve.toJSON'\n      }\n    };\n    data.arcLengthDivisions = this.arcLengthDivisions;\n    data.type = this.type;\n    return data;\n  },\n  fromJSON: function (json) {\n    this.arcLengthDivisions = json.arcLengthDivisions;\n    return this;\n  }\n});\n\nexport { Curve };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/extras/core/Curve.js"],"names":["_Math","Vector3","Matrix4","Curve","type","arcLengthDivisions","prototype","getPoint","console","warn","getPointAt","u","optionalTarget","t","getUtoTmapping","getPoints","divisions","undefined","points","d","push","getSpacedPoints","getLength","lengths","getLengths","length","cacheArcLengths","needsUpdate","cache","current","last","p","sum","distanceTo","updateArcLengths","distance","arcLengths","i","il","targetArcLength","low","high","comparison","Math","floor","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","delta","t1","t2","pt1","pt2","vec","clone","sub","normalize","getTangentAt","computeFrenetFrames","segments","closed","normal","tangents","normals","binormals","mat","theta","min","Number","MAX_VALUE","tx","abs","x","ty","y","tz","z","set","crossVectors","acos","clamp","dot","applyMatrix4","makeRotationAxis","constructor","copy","source","toJSON","data","metadata","version","generator","fromJSON","json"],"mappings":"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","sourcesContent":["import { _Math } from '../../math/Math.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Extensible curve object\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\n/**************************************************************\n *\tAbstract Curve base class\n **************************************************************/\n\nfunction Curve() {\n\n\tthis.type = 'Curve';\n\n\tthis.arcLengthDivisions = 200;\n\n}\n\nObject.assign( Curve.prototype, {\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint: function ( /* t, optionalTarget */ ) {\n\n\t\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\n\t\treturn null;\n\n\t},\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt: function ( u, optionalTarget ) {\n\n\t\tvar t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t, optionalTarget );\n\n\t},\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints: function ( divisions ) {\n\n\t\tif ( divisions === undefined ) divisions = 5;\n\n\t\tvar points = [];\n\n\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( divisions === undefined ) divisions = 5;\n\n\t\tvar points = [];\n\n\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\t// Get total curve arc length\n\n\tgetLength: function () {\n\n\t\tvar lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t},\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths: function ( divisions ) {\n\n\t\tif ( divisions === undefined ) divisions = this.arcLengthDivisions;\n\n\t\tif ( this.cacheArcLengths &&\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\n\t\t\t! this.needsUpdate ) {\n\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tvar cache = [];\n\t\tvar current, last = this.getPoint( 0 );\n\t\tvar p, sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\n\t},\n\n\tupdateArcLengths: function () {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t},\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping: function ( u, distance ) {\n\n\t\tvar arcLengths = this.getLengths();\n\n\t\tvar i = 0, il = arcLengths.length;\n\n\t\tvar targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tvar low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\treturn i / ( il - 1 );\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tvar lengthBefore = arcLengths[ i ];\n\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\n\t\tvar segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t},\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent: function ( t ) {\n\n\t\tvar delta = 0.0001;\n\t\tvar t1 = t - delta;\n\t\tvar t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tvar pt1 = this.getPoint( t1 );\n\t\tvar pt2 = this.getPoint( t2 );\n\n\t\tvar vec = pt2.clone().sub( pt1 );\n\t\treturn vec.normalize();\n\n\t},\n\n\tgetTangentAt: function ( u ) {\n\n\t\tvar t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t );\n\n\t},\n\n\tcomputeFrenetFrames: function ( segments, closed ) {\n\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\tvar normal = new Vector3();\n\n\t\tvar tangents = [];\n\t\tvar normals = [];\n\t\tvar binormals = [];\n\n\t\tvar vec = new Vector3();\n\t\tvar mat = new Matrix4();\n\n\t\tvar i, u, theta;\n\n\t\t// compute the tangent vectors for each segment on the curve\n\n\t\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\t\tu = i / segments;\n\n\t\t\ttangents[ i ] = this.getTangentAt( u );\n\t\t\ttangents[ i ].normalize();\n\n\t\t}\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the minimum tangent xyz component\n\n\t\tnormals[ 0 ] = new Vector3();\n\t\tbinormals[ 0 ] = new Vector3();\n\t\tvar min = Number.MAX_VALUE;\n\t\tvar tx = Math.abs( tangents[ 0 ].x );\n\t\tvar ty = Math.abs( tangents[ 0 ].y );\n\t\tvar tz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= min ) {\n\n\t\t\tmin = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= min ) {\n\n\t\t\tmin = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= min ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\tvec.normalize();\n\n\t\t\t\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t}\n\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\tif ( closed === true ) {\n\n\t\t\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\ttheta /= segments;\n\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\ttheta = - theta;\n\n\t\t\t}\n\n\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t// twist a little...\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\ttangents: tangents,\n\t\t\tnormals: normals,\n\t\t\tbinormals: binormals\n\t\t};\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Curve',\n\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t}\n\t\t};\n\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\tdata.type = this.type;\n\n\t\treturn data;\n\n\t},\n\n\tfromJSON: function ( json ) {\n\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n\nexport { Curve };\n"]},"metadata":{},"sourceType":"module"}