{"ast":null,"code":"import _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { PointsMaterial } from '../materials/PointsMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar _inverseMatrix = new Matrix4();\n\nvar _ray = new Ray();\n\nvar _sphere = new Sphere();\n\nvar _position = new Vector3();\n\nfunction Points(geometry, material) {\n  Object3D.call(this);\n  this.type = 'Points';\n  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n  this.material = material !== undefined ? material : new PointsMaterial({\n    color: Math.random() * 0xffffff\n  });\n  this.updateMorphTargets();\n}\n\nPoints.prototype = _Object$assign(_Object$create(Object3D.prototype), {\n  constructor: Points,\n  isPoints: true,\n  raycast: function (raycaster, intersects) {\n    var geometry = this.geometry;\n    var matrixWorld = this.matrixWorld;\n    var threshold = raycaster.params.Points.threshold; // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere.copy(geometry.boundingSphere);\n\n    _sphere.applyMatrix4(matrixWorld);\n\n    _sphere.radius += threshold;\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return; //\n\n    _inverseMatrix.getInverse(matrixWorld);\n\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n\n    var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    var localThresholdSq = localThreshold * localThreshold;\n\n    if (geometry.isBufferGeometry) {\n      var index = geometry.index;\n      var attributes = geometry.attributes;\n      var positions = attributes.position.array;\n\n      if (index !== null) {\n        var indices = index.array;\n\n        for (var i = 0, il = indices.length; i < il; i++) {\n          var a = indices[i];\n\n          _position.fromArray(positions, a * 3);\n\n          testPoint(_position, a, localThresholdSq, matrixWorld, raycaster, intersects, this);\n        }\n      } else {\n        for (var i = 0, l = positions.length / 3; i < l; i++) {\n          _position.fromArray(positions, i * 3);\n\n          testPoint(_position, i, localThresholdSq, matrixWorld, raycaster, intersects, this);\n        }\n      }\n    } else {\n      var vertices = geometry.vertices;\n\n      for (var i = 0, l = vertices.length; i < l; i++) {\n        testPoint(vertices[i], i, localThresholdSq, matrixWorld, raycaster, intersects, this);\n      }\n    }\n  },\n  updateMorphTargets: function () {\n    var geometry = this.geometry;\n    var m, ml, name;\n\n    if (geometry.isBufferGeometry) {\n      var morphAttributes = geometry.morphAttributes;\n\n      var keys = _Object$keys(morphAttributes);\n\n      if (keys.length > 0) {\n        var morphAttribute = morphAttributes[keys[0]];\n\n        if (morphAttribute !== undefined) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n\n          for (m = 0, ml = morphAttribute.length; m < ml; m++) {\n            name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    } else {\n      var morphTargets = geometry.morphTargets;\n\n      if (morphTargets !== undefined && morphTargets.length > 0) {\n        console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');\n      }\n    }\n  },\n  clone: function () {\n    return new this.constructor(this.geometry, this.material).copy(this);\n  }\n});\n\nfunction testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {\n  var rayPointDistanceSq = _ray.distanceSqToPoint(point);\n\n  if (rayPointDistanceSq < localThresholdSq) {\n    var intersectPoint = new Vector3();\n\n    _ray.closestPointToPoint(point, intersectPoint);\n\n    intersectPoint.applyMatrix4(matrixWorld);\n    var distance = raycaster.ray.origin.distanceTo(intersectPoint);\n    if (distance < raycaster.near || distance > raycaster.far) return;\n    intersects.push({\n      distance: distance,\n      distanceToRay: Math.sqrt(rayPointDistanceSq),\n      point: intersectPoint,\n      index: index,\n      face: null,\n      object: object\n    });\n  }\n}\n\nexport { Points };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/objects/Points.js"],"names":["Sphere","Ray","Matrix4","Object3D","Vector3","PointsMaterial","BufferGeometry","_inverseMatrix","_ray","_sphere","_position","Points","geometry","material","call","type","undefined","color","Math","random","updateMorphTargets","prototype","constructor","isPoints","raycast","raycaster","intersects","matrixWorld","threshold","params","boundingSphere","computeBoundingSphere","copy","applyMatrix4","radius","ray","intersectsSphere","getInverse","localThreshold","scale","x","y","z","localThresholdSq","isBufferGeometry","index","attributes","positions","position","array","indices","i","il","length","a","fromArray","testPoint","l","vertices","m","ml","name","morphAttributes","keys","morphAttribute","morphTargetInfluences","morphTargetDictionary","String","push","morphTargets","console","error","clone","point","object","rayPointDistanceSq","distanceSqToPoint","intersectPoint","closestPointToPoint","distance","origin","distanceTo","near","far","distanceToRay","sqrt","face"],"mappings":"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","sourcesContent":["import { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { PointsMaterial } from '../materials/PointsMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar _inverseMatrix = new Matrix4();\nvar _ray = new Ray();\nvar _sphere = new Sphere();\nvar _position = new Vector3();\n\nfunction Points( geometry, material ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Points';\n\n\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\tthis.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\n\n\tthis.updateMorphTargets();\n\n}\n\nPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Points,\n\n\tisPoints: true,\n\n\traycast: function ( raycaster, intersects ) {\n\n\t\tvar geometry = this.geometry;\n\t\tvar matrixWorld = this.matrixWorld;\n\t\tvar threshold = raycaster.params.Points.threshold;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\t\t_sphere.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.getInverse( matrixWorld );\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tvar localThresholdSq = localThreshold * localThreshold;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar attributes = geometry.attributes;\n\t\t\tvar positions = attributes.position.array;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tvar indices = index.array;\n\n\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar a = indices[ i ];\n\n\t\t\t\t\t_position.fromArray( positions, a * 3 );\n\n\t\t\t\t\ttestPoint( _position, a, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\n\t\t\t\t\t_position.fromArray( positions, i * 3 );\n\n\t\t\t\t\ttestPoint( _position, i, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar vertices = geometry.vertices;\n\n\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\ttestPoint( vertices[ i ], i, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t\tvar geometry = this.geometry;\n\t\tvar m, ml, name;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tvar morphAttributes = geometry.morphAttributes;\n\t\t\tvar keys = Object.keys( morphAttributes );\n\n\t\t\tif ( keys.length > 0 ) {\n\n\t\t\t\tvar morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\tfor ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\tname = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar morphTargets = geometry.morphTargets;\n\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\nfunction testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {\n\n\tvar rayPointDistanceSq = _ray.distanceSqToPoint( point );\n\n\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\tvar intersectPoint = new Vector3();\n\n\t\t_ray.closestPointToPoint( point, intersectPoint );\n\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\tpoint: intersectPoint,\n\t\t\tindex: index,\n\t\t\tface: null,\n\t\t\tobject: object\n\n\t\t} );\n\n\t}\n\n}\n\nexport { Points };\n"]},"metadata":{},"sourceType":"module"}