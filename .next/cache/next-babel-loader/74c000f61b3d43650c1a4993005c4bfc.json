{"ast":null,"code":"import _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\nimport { BufferAttribute } from '../core/BufferAttribute.js';\nimport { Mesh } from './Mesh.js';\nimport { Matrix4 } from '../math/Matrix4.js';\n\nvar _instanceLocalMatrix = new Matrix4();\n\nvar _instanceWorldMatrix = new Matrix4();\n\nvar _instanceIntersects = [];\n\nvar _mesh = new Mesh();\n\nfunction InstancedMesh(geometry, material, count) {\n  Mesh.call(this, geometry, material);\n  this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);\n  this.count = count;\n}\n\nInstancedMesh.prototype = _Object$assign(_Object$create(Mesh.prototype), {\n  constructor: InstancedMesh,\n  isInstancedMesh: true,\n  getMatrixAt: function (index, matrix) {\n    matrix.fromArray(this.instanceMatrix.array, index * 16);\n  },\n  raycast: function (raycaster, intersects) {\n    var matrixWorld = this.matrixWorld;\n    var raycastTimes = this.count;\n    _mesh.geometry = this.geometry;\n    _mesh.material = this.material;\n    if (_mesh.material === undefined) return;\n\n    for (var instanceId = 0; instanceId < raycastTimes; instanceId++) {\n      // calculate the world matrix for each instance\n      this.getMatrixAt(instanceId, _instanceLocalMatrix);\n\n      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance\n\n\n      _mesh.matrixWorld = _instanceWorldMatrix;\n\n      _mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast\n\n\n      if (_instanceIntersects.length > 0) {\n        _instanceIntersects[0].instanceId = instanceId;\n        _instanceIntersects[0].object = this;\n        intersects.push(_instanceIntersects[0]);\n        _instanceIntersects.length = 0;\n      }\n    }\n  },\n  setMatrixAt: function (index, matrix) {\n    matrix.toArray(this.instanceMatrix.array, index * 16);\n  },\n  updateMorphTargets: function () {}\n});\nexport { InstancedMesh };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/objects/InstancedMesh.js"],"names":["BufferAttribute","Mesh","Matrix4","_instanceLocalMatrix","_instanceWorldMatrix","_instanceIntersects","_mesh","InstancedMesh","geometry","material","count","call","instanceMatrix","Float32Array","prototype","constructor","isInstancedMesh","getMatrixAt","index","matrix","fromArray","array","raycast","raycaster","intersects","matrixWorld","raycastTimes","undefined","instanceId","multiplyMatrices","length","object","push","setMatrixAt","toArray","updateMorphTargets"],"mappings":";;;AAAA;;;AAGA,SAASA,eAAT,QAAgC,4BAAhC;AACA,SAASC,IAAT,QAAqB,WAArB;AACA,SAASC,OAAT,QAAwB,oBAAxB;;AAEA,IAAIC,oBAAoB,GAAG,IAAID,OAAJ,EAA3B;;AACA,IAAIE,oBAAoB,GAAG,IAAIF,OAAJ,EAA3B;;AAEA,IAAIG,mBAAmB,GAAG,EAA1B;;AAEA,IAAIC,KAAK,GAAG,IAAIL,IAAJ,EAAZ;;AAEA,SAASM,aAAT,CAAwBC,QAAxB,EAAkCC,QAAlC,EAA4CC,KAA5C,EAAoD;AAEnDT,EAAAA,IAAI,CAACU,IAAL,CAAW,IAAX,EAAiBH,QAAjB,EAA2BC,QAA3B;AAEA,OAAKG,cAAL,GAAsB,IAAIZ,eAAJ,CAAqB,IAAIa,YAAJ,CAAkBH,KAAK,GAAG,EAA1B,CAArB,EAAqD,EAArD,CAAtB;AAEA,OAAKA,KAAL,GAAaA,KAAb;AAEA;;AAEDH,aAAa,CAACO,SAAd,GAA0B,eAAe,eAAeb,IAAI,CAACa,SAApB,CAAf,EAAgD;AAEzEC,EAAAA,WAAW,EAAER,aAF4D;AAIzES,EAAAA,eAAe,EAAE,IAJwD;AAMzEC,EAAAA,WAAW,EAAE,UAAWC,KAAX,EAAkBC,MAAlB,EAA2B;AAEvCA,IAAAA,MAAM,CAACC,SAAP,CAAkB,KAAKR,cAAL,CAAoBS,KAAtC,EAA6CH,KAAK,GAAG,EAArD;AAEA,GAVwE;AAYzEI,EAAAA,OAAO,EAAE,UAAWC,SAAX,EAAsBC,UAAtB,EAAmC;AAE3C,QAAIC,WAAW,GAAG,KAAKA,WAAvB;AACA,QAAIC,YAAY,GAAG,KAAKhB,KAAxB;AAEAJ,IAAAA,KAAK,CAACE,QAAN,GAAiB,KAAKA,QAAtB;AACAF,IAAAA,KAAK,CAACG,QAAN,GAAiB,KAAKA,QAAtB;AAEA,QAAKH,KAAK,CAACG,QAAN,KAAmBkB,SAAxB,EAAoC;;AAEpC,SAAM,IAAIC,UAAU,GAAG,CAAvB,EAA0BA,UAAU,GAAGF,YAAvC,EAAqDE,UAAU,EAA/D,EAAqE;AAEpE;AAEA,WAAKX,WAAL,CAAkBW,UAAlB,EAA8BzB,oBAA9B;;AAEAC,MAAAA,oBAAoB,CAACyB,gBAArB,CAAuCJ,WAAvC,EAAoDtB,oBAApD,EANoE,CAQpE;;;AAEAG,MAAAA,KAAK,CAACmB,WAAN,GAAoBrB,oBAApB;;AAEAE,MAAAA,KAAK,CAACgB,OAAN,CAAeC,SAAf,EAA0BlB,mBAA1B,EAZoE,CAcpE;;;AAEA,UAAKA,mBAAmB,CAACyB,MAApB,GAA6B,CAAlC,EAAsC;AAErCzB,QAAAA,mBAAmB,CAAE,CAAF,CAAnB,CAAyBuB,UAAzB,GAAsCA,UAAtC;AACAvB,QAAAA,mBAAmB,CAAE,CAAF,CAAnB,CAAyB0B,MAAzB,GAAkC,IAAlC;AAEAP,QAAAA,UAAU,CAACQ,IAAX,CAAiB3B,mBAAmB,CAAE,CAAF,CAApC;AAEAA,QAAAA,mBAAmB,CAACyB,MAApB,GAA6B,CAA7B;AAEA;AAED;AAED,GAnDwE;AAqDzEG,EAAAA,WAAW,EAAE,UAAWf,KAAX,EAAkBC,MAAlB,EAA2B;AAEvCA,IAAAA,MAAM,CAACe,OAAP,CAAgB,KAAKtB,cAAL,CAAoBS,KAApC,EAA2CH,KAAK,GAAG,EAAnD;AAEA,GAzDwE;AA2DzEiB,EAAAA,kBAAkB,EAAE,YAAY,CAE/B;AA7DwE,CAAhD,CAA1B;AAiEA,SAAS5B,aAAT","sourcesContent":["/**\n * @author mrdoob / http://mrdoob.com/\n */\nimport { BufferAttribute } from '../core/BufferAttribute.js';\nimport { Mesh } from './Mesh.js';\nimport { Matrix4 } from '../math/Matrix4.js';\n\nvar _instanceLocalMatrix = new Matrix4();\nvar _instanceWorldMatrix = new Matrix4();\n\nvar _instanceIntersects = [];\n\nvar _mesh = new Mesh();\n\nfunction InstancedMesh( geometry, material, count ) {\n\n\tMesh.call( this, geometry, material );\n\n\tthis.instanceMatrix = new BufferAttribute( new Float32Array( count * 16 ), 16 );\n\n\tthis.count = count;\n\n}\n\nInstancedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n\tconstructor: InstancedMesh,\n\n\tisInstancedMesh: true,\n\n\tgetMatrixAt: function ( index, matrix ) {\n\n\t\tmatrix.fromArray( this.instanceMatrix.array, index * 16 );\n\n\t},\n\n\traycast: function ( raycaster, intersects ) {\n\n\t\tvar matrixWorld = this.matrixWorld;\n\t\tvar raycastTimes = this.count;\n\n\t\t_mesh.geometry = this.geometry;\n\t\t_mesh.material = this.material;\n\n\t\tif ( _mesh.material === undefined ) return;\n\n\t\tfor ( var instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {\n\n\t\t\t// calculate the world matrix for each instance\n\n\t\t\tthis.getMatrixAt( instanceId, _instanceLocalMatrix );\n\n\t\t\t_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );\n\n\t\t\t// the mesh represents this single instance\n\n\t\t\t_mesh.matrixWorld = _instanceWorldMatrix;\n\n\t\t\t_mesh.raycast( raycaster, _instanceIntersects );\n\n\t\t\t// process the result of raycast\n\n\t\t\tif ( _instanceIntersects.length > 0 ) {\n\n\t\t\t\t_instanceIntersects[ 0 ].instanceId = instanceId;\n\t\t\t\t_instanceIntersects[ 0 ].object = this;\n\n\t\t\t\tintersects.push( _instanceIntersects[ 0 ] );\n\n\t\t\t\t_instanceIntersects.length = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tsetMatrixAt: function ( index, matrix ) {\n\n\t\tmatrix.toArray( this.instanceMatrix.array, index * 16 );\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t}\n\n} );\n\nexport { InstancedMesh };\n"]},"metadata":{},"sourceType":"module"}