{"ast":null,"code":"import _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n * @author tschw\n */\nfunction Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n  this.parameterPositions = parameterPositions;\n  this._cachedIndex = 0;\n  this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);\n  this.sampleValues = sampleValues;\n  this.valueSize = sampleSize;\n}\n\n_Object$assign(Interpolant.prototype, {\n  evaluate: function evaluate(t) {\n    var pp = this.parameterPositions,\n        i1 = this._cachedIndex,\n        t1 = pp[i1],\n        t0 = pp[i1 - 1];\n\n    validate_interval: {\n      seek: {\n        var right;\n\n        linear_scan: {\n          //- See http://jsperf.com/comparison-to-undefined/3\n          //- slower code:\n          //-\n          //- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n          forward_scan: if (!(t < t1)) {\n            for (var giveUpAt = i1 + 2;;) {\n              if (t1 === undefined) {\n                if (t < t0) break forward_scan; // after end\n\n                i1 = pp.length;\n                this._cachedIndex = i1;\n                return this.afterEnd_(i1 - 1, t, t0);\n              }\n\n              if (i1 === giveUpAt) break; // this loop\n\n              t0 = t1;\n              t1 = pp[++i1];\n\n              if (t < t1) {\n                // we have arrived at the sought interval\n                break seek;\n              }\n            } // prepare binary search on the right side of the index\n\n\n            right = pp.length;\n            break linear_scan;\n          } //- slower code:\n          //-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\n\n          if (!(t >= t0)) {\n            // looping?\n            var t1global = pp[1];\n\n            if (t < t1global) {\n              i1 = 2; // + 1, using the scan for the details\n\n              t0 = t1global;\n            } // linear reverse scan\n\n\n            for (var giveUpAt = i1 - 2;;) {\n              if (t0 === undefined) {\n                // before start\n                this._cachedIndex = 0;\n                return this.beforeStart_(0, t, t1);\n              }\n\n              if (i1 === giveUpAt) break; // this loop\n\n              t1 = t0;\n              t0 = pp[--i1 - 1];\n\n              if (t >= t0) {\n                // we have arrived at the sought interval\n                break seek;\n              }\n            } // prepare binary search on the left side of the index\n\n\n            right = i1;\n            i1 = 0;\n            break linear_scan;\n          } // the interval is valid\n\n\n          break validate_interval;\n        } // linear scan\n        // binary search\n\n\n        while (i1 < right) {\n          var mid = i1 + right >>> 1;\n\n          if (t < pp[mid]) {\n            right = mid;\n          } else {\n            i1 = mid + 1;\n          }\n        }\n\n        t1 = pp[i1];\n        t0 = pp[i1 - 1]; // check boundary cases, again\n\n        if (t0 === undefined) {\n          this._cachedIndex = 0;\n          return this.beforeStart_(0, t, t1);\n        }\n\n        if (t1 === undefined) {\n          i1 = pp.length;\n          this._cachedIndex = i1;\n          return this.afterEnd_(i1 - 1, t0, t);\n        }\n      } // seek\n\n\n      this._cachedIndex = i1;\n      this.intervalChanged_(i1, t0, t1);\n    } // validate_interval\n\n\n    return this.interpolate_(i1, t0, t, t1);\n  },\n  settings: null,\n  // optional, subclass-specific settings structure\n  // Note: The indirection allows central control of many interpolants.\n  // --- Protected interface\n  DefaultSettings_: {},\n  getSettings_: function getSettings_() {\n    return this.settings || this.DefaultSettings_;\n  },\n  copySampleValue_: function copySampleValue_(index) {\n    // copies a sample value to the result buffer\n    var result = this.resultBuffer,\n        values = this.sampleValues,\n        stride = this.valueSize,\n        offset = index * stride;\n\n    for (var i = 0; i !== stride; ++i) {\n      result[i] = values[offset + i];\n    }\n\n    return result;\n  },\n  // Template methods for derived classes:\n  interpolate_: function interpolate_()\n  /* i1, t0, t, t1 */\n  {\n    throw new Error('call to abstract method'); // implementations shall return this.resultBuffer\n  },\n  intervalChanged_: function intervalChanged_()\n  /* i1, t0, t1 */\n  {// empty\n  }\n}); //!\\ DECLARE ALIAS AFTER assign prototype !\n\n\n_Object$assign(Interpolant.prototype, {\n  //( 0, t, t0 ), returns this.resultBuffer\n  beforeStart_: Interpolant.prototype.copySampleValue_,\n  //( N-1, tN-1, t ), returns this.resultBuffer\n  afterEnd_: Interpolant.prototype.copySampleValue_\n});\n\nexport { Interpolant };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/math/Interpolant.js"],"names":["Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","_cachedIndex","undefined","constructor","valueSize","prototype","evaluate","t","pp","i1","t1","t0","validate_interval","seek","right","linear_scan","forward_scan","giveUpAt","length","afterEnd_","t1global","beforeStart_","mid","intervalChanged_","interpolate_","settings","DefaultSettings_","getSettings_","copySampleValue_","index","result","values","stride","offset","i","Error"],"mappings":"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","sourcesContent":["/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n * @author tschw\n */\n\nfunction Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tthis.parameterPositions = parameterPositions;\n\tthis._cachedIndex = 0;\n\n\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\tthis.sampleValues = sampleValues;\n\tthis.valueSize = sampleSize;\n\n}\n\nObject.assign( Interpolant.prototype, {\n\n\tevaluate: function ( t ) {\n\n\t\tvar pp = this.parameterPositions,\n\t\t\ti1 = this._cachedIndex,\n\n\t\t\tt1 = pp[ i1 ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tvar right;\n\n\t\t\t\tlinear_scan: {\n\n\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\n\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[ i1 ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t},\n\n\tsettings: null, // optional, subclass-specific settings structure\n\t// Note: The indirection allows central control of many interpolants.\n\n\t// --- Protected interface\n\n\tDefaultSettings_: {},\n\n\tgetSettings_: function () {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t},\n\n\tcopySampleValue_: function ( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// Template methods for derived classes:\n\n\tinterpolate_: function ( /* i1, t0, t, t1 */ ) {\n\n\t\tthrow new Error( 'call to abstract method' );\n\t\t// implementations shall return this.resultBuffer\n\n\t},\n\n\tintervalChanged_: function ( /* i1, t0, t1 */ ) {\n\n\t\t// empty\n\n\t}\n\n} );\n\n//!\\ DECLARE ALIAS AFTER assign prototype !\nObject.assign( Interpolant.prototype, {\n\n\t//( 0, t, t0 ), returns this.resultBuffer\n\tbeforeStart_: Interpolant.prototype.copySampleValue_,\n\n\t//( N-1, tN-1, t ), returns this.resultBuffer\n\tafterEnd_: Interpolant.prototype.copySampleValue_,\n\n} );\n\n\nexport { Interpolant };\n"]},"metadata":{},"sourceType":"module"}