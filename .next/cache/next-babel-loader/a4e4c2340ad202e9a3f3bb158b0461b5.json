{"ast":null,"code":"import _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport { LinearFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping } from '../constants.js';\nimport { FileLoader } from './FileLoader.js';\nimport { DataTexture } from '../textures/DataTexture.js';\nimport { Loader } from './Loader.js';\n/**\n * @author Nikos M. / https://github.com/foo123/\n *\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nfunction DataTextureLoader(manager) {\n  Loader.call(this, manager);\n}\n\nDataTextureLoader.prototype = _Object$assign(_Object$create(Loader.prototype), {\n  constructor: DataTextureLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var texture = new DataTexture();\n    var loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setPath(this.path);\n    loader.load(url, function (buffer) {\n      var texData = scope.parse(buffer);\n      if (!texData) return;\n\n      if (texData.image !== undefined) {\n        texture.image = texData.image;\n      } else if (texData.data !== undefined) {\n        texture.image.width = texData.width;\n        texture.image.height = texData.height;\n        texture.image.data = texData.data;\n      }\n\n      texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n      texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n      texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n      texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n      texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n      if (texData.format !== undefined) {\n        texture.format = texData.format;\n      }\n\n      if (texData.type !== undefined) {\n        texture.type = texData.type;\n      }\n\n      if (texData.mipmaps !== undefined) {\n        texture.mipmaps = texData.mipmaps;\n        texture.minFilter = LinearMipmapLinearFilter; // presumably...\n      }\n\n      if (texData.mipmapCount === 1) {\n        texture.minFilter = LinearFilter;\n      }\n\n      texture.needsUpdate = true;\n      if (onLoad) onLoad(texture, texData);\n    }, onProgress, onError);\n    return texture;\n  }\n});\nexport { DataTextureLoader };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/loaders/DataTextureLoader.js"],"names":["LinearFilter","LinearMipmapLinearFilter","ClampToEdgeWrapping","FileLoader","DataTexture","Loader","DataTextureLoader","manager","call","prototype","constructor","load","url","onLoad","onProgress","onError","scope","texture","loader","setResponseType","setPath","path","buffer","texData","parse","image","undefined","data","width","height","wrapS","wrapT","magFilter","minFilter","anisotropy","format","type","mipmaps","mipmapCount","needsUpdate"],"mappings":"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","sourcesContent":["import { LinearFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping } from '../constants.js';\nimport { FileLoader } from './FileLoader.js';\nimport { DataTexture } from '../textures/DataTexture.js';\nimport { Loader } from './Loader.js';\n\n/**\n * @author Nikos M. / https://github.com/foo123/\n *\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nfunction DataTextureLoader( manager ) {\n\n\tLoader.call( this, manager );\n\n}\n\nDataTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: DataTextureLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar texture = new DataTexture();\n\n\t\tvar loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setPath( this.path );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tvar texData = scope.parse( buffer );\n\n\t\t\tif ( ! texData ) return;\n\n\t\t\tif ( texData.image !== undefined ) {\n\n\t\t\t\ttexture.image = texData.image;\n\n\t\t\t} else if ( texData.data !== undefined ) {\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t}\n\n\t\t\ttexture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\ttexture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n\n\t\t\ttexture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n\t\t\ttexture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n\n\t\t\ttexture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n\t\t\tif ( texData.format !== undefined ) {\n\n\t\t\t\ttexture.format = texData.format;\n\n\t\t\t}\n\t\t\tif ( texData.type !== undefined ) {\n\n\t\t\t\ttexture.type = texData.type;\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmaps !== undefined ) {\n\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\t\t\ttexture.minFilter = LinearMipmapLinearFilter; // presumably...\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmapCount === 1 ) {\n\n\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}, onProgress, onError );\n\n\n\t\treturn texture;\n\n\t}\n\n} );\n\n\nexport { DataTextureLoader };\n"]},"metadata":{},"sourceType":"module"}