{"ast":null,"code":"import _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\n\nvar _ENCODINGS;\n\n/**\n * @author Emmett Lalish / elalish\n *\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n */\nimport { CubeUVReflectionMapping, GammaEncoding, LinearEncoding, LinearToneMapping, NearestFilter, NoBlending, RGBDEncoding, RGBEEncoding, RGBEFormat, RGBM16Encoding, RGBM7Encoding, UnsignedByteType, sRGBEncoding } from \"../constants.js\";\nimport { BufferAttribute } from \"../core/BufferAttribute.js\";\nimport { BufferGeometry } from \"../core/BufferGeometry.js\";\nimport { Mesh } from \"../objects/Mesh.js\";\nimport { OrthographicCamera } from \"../cameras/OrthographicCamera.js\";\nimport { PerspectiveCamera } from \"../cameras/PerspectiveCamera.js\";\nimport { RawShaderMaterial } from \"../materials/RawShaderMaterial.js\";\nimport { Scene } from \"../scenes/Scene.js\";\nimport { Vector2 } from \"../math/Vector2.js\";\nimport { Vector3 } from \"../math/Vector3.js\";\nimport { WebGLRenderTarget } from \"../renderers/WebGLRenderTarget.js\";\nvar LOD_MIN = 4;\nvar LOD_MAX = 8;\nvar SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\n\nvar EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\nvar TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\n\nvar MAX_SAMPLES = 20;\nvar ENCODINGS = (_ENCODINGS = {}, _defineProperty(_ENCODINGS, LinearEncoding, 0), _defineProperty(_ENCODINGS, sRGBEncoding, 1), _defineProperty(_ENCODINGS, RGBEEncoding, 2), _defineProperty(_ENCODINGS, RGBM7Encoding, 3), _defineProperty(_ENCODINGS, RGBM16Encoding, 4), _defineProperty(_ENCODINGS, RGBDEncoding, 5), _defineProperty(_ENCODINGS, GammaEncoding, 6), _ENCODINGS);\n\nvar _flatCamera = new OrthographicCamera();\n\nvar _blurMaterial = _getBlurShader(MAX_SAMPLES);\n\nvar _equirectShader = null;\nvar _cubemapShader = null;\n\nvar _createPlanes2 = _createPlanes(),\n    _lodPlanes = _createPlanes2._lodPlanes,\n    _sizeLods = _createPlanes2._sizeLods,\n    _sigmas = _createPlanes2._sigmas;\n\nvar _pingPongRenderTarget = null;\nvar _renderer = null; // Golden Ratio\n\nvar PHI = (1 + Math.sqrt(5)) / 2;\nvar INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\n\nvar _axisDirections = [new Vector3(1, 1, 1), new Vector3(-1, 1, 1), new Vector3(1, 1, -1), new Vector3(-1, 1, -1), new Vector3(0, PHI, INV_PHI), new Vector3(0, PHI, -INV_PHI), new Vector3(INV_PHI, 0, PHI), new Vector3(-INV_PHI, 0, PHI), new Vector3(PHI, INV_PHI, 0), new Vector3(-PHI, INV_PHI, 0)];\n\nfunction PMREMGenerator(renderer) {\n  _renderer = renderer;\n\n  _compileMaterial(_blurMaterial);\n}\n\nPMREMGenerator.prototype = {\n  constructor: PMREMGenerator,\n\n  /**\n   * Generates a PMREM from a supplied Scene, which can be faster than using an\n   * image if networking bandwidth is low. Optional sigma specifies a blur radius\n   * in radians to be applied to the scene before PMREM generation. Optional near\n   * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n   * is placed at the origin).\n   */\n  fromScene: function fromScene(scene) {\n    var sigma = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;\n    var far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;\n\n    var cubeUVRenderTarget = _allocateTargets();\n\n    _sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n\n    if (sigma > 0) {\n      _blur(cubeUVRenderTarget, 0, 0, sigma);\n    }\n\n    _applyPMREM(cubeUVRenderTarget);\n\n    _cleanup();\n\n    cubeUVRenderTarget.scissorTest = false;\n    return cubeUVRenderTarget;\n  },\n\n  /**\n   * Generates a PMREM from an equirectangular texture, which can be either LDR\n   * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n  fromEquirectangular: function fromEquirectangular(equirectangular) {\n    equirectangular.magFilter = NearestFilter;\n    equirectangular.minFilter = NearestFilter;\n    equirectangular.generateMipmaps = false;\n    return this.fromCubemap(equirectangular);\n  },\n\n  /**\n   * Generates a PMREM from an cubemap texture, which can be either LDR\n   * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n  fromCubemap: function fromCubemap(cubemap) {\n    var cubeUVRenderTarget = _allocateTargets(cubemap);\n\n    _textureToCubeUV(cubemap, cubeUVRenderTarget);\n\n    _applyPMREM(cubeUVRenderTarget);\n\n    _cleanup();\n\n    cubeUVRenderTarget.scissorTest = false;\n    return cubeUVRenderTarget;\n  },\n\n  /**\n   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n  compileCubemapShader: function compileCubemapShader() {\n    if (_cubemapShader == null) {\n      _cubemapShader = _getCubemapShader();\n\n      _compileMaterial(_cubemapShader);\n    }\n  },\n\n  /**\n   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n  compileEquirectangularShader: function compileEquirectangularShader() {\n    if (_equirectShader == null) {\n      _equirectShader = _getEquirectShader();\n\n      _compileMaterial(_equirectShader);\n    }\n  },\n\n  /**\n   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n   * one of them will cause any others to also become unusable.\n   */\n  dispose: function dispose() {\n    _blurMaterial.dispose();\n\n    if (_cubemapShader != null) _cubemapShader.dispose();\n    if (_equirectShader != null) _equirectShader.dispose();\n\n    for (var i = 0; i < _lodPlanes.length; i++) {\n      _lodPlanes[i].dispose();\n    }\n  }\n};\n\nfunction _createPlanes() {\n  var _lodPlanes = [];\n  var _sizeLods = [];\n  var _sigmas = [];\n  var lod = LOD_MAX;\n\n  for (var i = 0; i < TOTAL_LODS; i++) {\n    var sizeLod = Math.pow(2, lod);\n\n    _sizeLods.push(sizeLod);\n\n    var sigma = 1.0 / sizeLod;\n\n    if (i > LOD_MAX - LOD_MIN) {\n      sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];\n    } else if (i == 0) {\n      sigma = 0;\n    }\n\n    _sigmas.push(sigma);\n\n    var texelSize = 1.0 / (sizeLod - 1);\n    var min = -texelSize / 2;\n    var max = 1 + texelSize / 2;\n    var uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n    var cubeFaces = 6;\n    var vertices = 6;\n    var positionSize = 3;\n    var uvSize = 2;\n    var faceIndexSize = 1;\n    var position = new Float32Array(positionSize * vertices * cubeFaces);\n    var uv = new Float32Array(uvSize * vertices * cubeFaces);\n    var faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n\n    for (var face = 0; face < cubeFaces; face++) {\n      var x = face % 3 * 2 / 3 - 1;\n      var y = face > 2 ? 0 : -1;\n      var coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];\n      position.set(coordinates, positionSize * vertices * face);\n      uv.set(uv1, uvSize * vertices * face);\n      var fill = [face, face, face, face, face, face];\n      faceIndex.set(fill, faceIndexSize * vertices * face);\n    }\n\n    var planes = new BufferGeometry();\n    planes.setAttribute('position', new BufferAttribute(position, positionSize));\n    planes.setAttribute('uv', new BufferAttribute(uv, uvSize));\n    planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));\n\n    _lodPlanes.push(planes);\n\n    if (lod > LOD_MIN) {\n      lod--;\n    }\n  }\n\n  return {\n    _lodPlanes: _lodPlanes,\n    _sizeLods: _sizeLods,\n    _sigmas: _sigmas\n  };\n}\n\nfunction _allocateTargets(equirectangular) {\n  var params = {\n    magFilter: NearestFilter,\n    minFilter: NearestFilter,\n    generateMipmaps: false,\n    type: equirectangular ? equirectangular.type : UnsignedByteType,\n    format: equirectangular ? equirectangular.format : RGBEFormat,\n    encoding: equirectangular ? equirectangular.encoding : RGBEEncoding,\n    depthBuffer: false,\n    stencilBuffer: false\n  };\n\n  var cubeUVRenderTarget = _createRenderTarget(params);\n\n  cubeUVRenderTarget.depthBuffer = equirectangular ? false : true;\n  _pingPongRenderTarget = _createRenderTarget(params);\n  return cubeUVRenderTarget;\n}\n\nfunction _cleanup() {\n  _pingPongRenderTarget.dispose();\n\n  _renderer.setRenderTarget(null);\n\n  var size = _renderer.getSize(new Vector2());\n\n  _renderer.setViewport(0, 0, size.x, size.y);\n}\n\nfunction _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n  var fov = 90;\n  var aspect = 1;\n  var cubeCamera = new PerspectiveCamera(fov, aspect, near, far);\n  var upSign = [1, 1, 1, 1, -1, 1];\n  var forwardSign = [1, 1, -1, -1, -1, 1];\n  var outputEncoding = _renderer.outputEncoding;\n  var toneMapping = _renderer.toneMapping;\n  var toneMappingExposure = _renderer.toneMappingExposure;\n\n  var clearColor = _renderer.getClearColor();\n\n  var clearAlpha = _renderer.getClearAlpha();\n\n  _renderer.toneMapping = LinearToneMapping;\n  _renderer.toneMappingExposure = 1.0;\n  _renderer.outputEncoding = LinearEncoding;\n  scene.scale.z *= -1;\n  var background = scene.background;\n\n  if (background && background.isColor) {\n    background.convertSRGBToLinear(); // Convert linear to RGBE\n\n    var maxComponent = Math.max(background.r, background.g, background.b);\n    var fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128.0), 127.0);\n    background = background.multiplyScalar(Math.pow(2.0, -fExp));\n    var alpha = (fExp + 128.0) / 255.0;\n\n    _renderer.setClearColor(background, alpha);\n\n    scene.background = null;\n  }\n\n  _renderer.setRenderTarget(cubeUVRenderTarget);\n\n  for (var i = 0; i < 6; i++) {\n    var col = i % 3;\n\n    if (col == 0) {\n      cubeCamera.up.set(0, upSign[i], 0);\n      cubeCamera.lookAt(forwardSign[i], 0, 0);\n    } else if (col == 1) {\n      cubeCamera.up.set(0, 0, upSign[i]);\n      cubeCamera.lookAt(0, forwardSign[i], 0);\n    } else {\n      cubeCamera.up.set(0, upSign[i], 0);\n      cubeCamera.lookAt(0, 0, forwardSign[i]);\n    }\n\n    _setViewport(col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);\n\n    _renderer.render(scene, cubeCamera);\n  }\n\n  _renderer.toneMapping = toneMapping;\n  _renderer.toneMappingExposure = toneMappingExposure;\n  _renderer.outputEncoding = outputEncoding;\n\n  _renderer.setClearColor(clearColor, clearAlpha);\n\n  scene.scale.z *= -1;\n}\n\nfunction _textureToCubeUV(texture, cubeUVRenderTarget) {\n  var scene = new Scene();\n\n  if (texture.isCubeTexture) {\n    if (_cubemapShader == null) {\n      _cubemapShader = _getCubemapShader();\n    }\n  } else {\n    if (_equirectShader == null) {\n      _equirectShader = _getEquirectShader();\n    }\n  }\n\n  var material = texture.isCubeTexture ? _cubemapShader : _equirectShader;\n  scene.add(new Mesh(_lodPlanes[0], material));\n  var uniforms = material.uniforms;\n  uniforms['envMap'].value = texture;\n\n  if (!texture.isCubeTexture) {\n    uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);\n  }\n\n  uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];\n  uniforms['outputEncoding'].value = ENCODINGS[texture.encoding];\n\n  _renderer.setRenderTarget(cubeUVRenderTarget);\n\n  _setViewport(0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);\n\n  _renderer.render(scene, _flatCamera);\n}\n\nfunction _compileMaterial(material) {\n  var tmpScene = new Scene();\n  tmpScene.add(new Mesh(_lodPlanes[0], material));\n\n  _renderer.compile(tmpScene, _flatCamera);\n}\n\nfunction _createRenderTarget(params) {\n  var cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);\n  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n  cubeUVRenderTarget.scissorTest = true;\n  return cubeUVRenderTarget;\n}\n\nfunction _setViewport(x, y, width, height) {\n  var invDpr = 1.0 / _renderer.getPixelRatio();\n\n  x *= invDpr;\n  y *= invDpr;\n  width *= invDpr;\n  height *= invDpr;\n\n  _renderer.setViewport(x, y, width, height);\n\n  _renderer.setScissor(x, y, width, height);\n}\n\nfunction _applyPMREM(cubeUVRenderTarget) {\n  var autoClear = _renderer.autoClear;\n  _renderer.autoClear = false;\n\n  for (var i = 1; i < TOTAL_LODS; i++) {\n    var sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);\n    var poleAxis = _axisDirections[(i - 1) % _axisDirections.length];\n\n    _blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n  }\n\n  _renderer.autoClear = autoClear;\n}\n/**\n * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n * vertically and horizontally, but this breaks down on a cube. Here we apply\n * the blur latitudinally (around the poles), and then longitudinally (towards\n * the poles) to approximate the orthogonally-separable blur. It is least\n * accurate at the poles, but still does a decent job.\n */\n\n\nfunction _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n  _halfBlur(cubeUVRenderTarget, _pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);\n\n  _halfBlur(_pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);\n}\n\nfunction _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n  if (direction !== 'latitudinal' && direction !== 'longitudinal') {\n    console.error('blur direction must be either latitudinal or longitudinal!');\n  } // Number of standard deviations at which to cut off the discrete approximation.\n\n\n  var STANDARD_DEVIATIONS = 3;\n  var blurScene = new Scene();\n  blurScene.add(new Mesh(_lodPlanes[lodOut], _blurMaterial));\n  var blurUniforms = _blurMaterial.uniforms;\n  var pixels = _sizeLods[lodIn] - 1;\n  var radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n  var sigmaPixels = sigmaRadians / radiansPerPixel;\n  var samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n\n  if (samples > MAX_SAMPLES) {\n    console.warn(\"sigmaRadians, \".concat(sigmaRadians, \", is too large and will clip, as it requested \").concat(samples, \" samples when the maximum is set to \").concat(MAX_SAMPLES));\n  }\n\n  var weights = [];\n  var sum = 0;\n\n  for (var i = 0; i < MAX_SAMPLES; ++i) {\n    var x = i / sigmaPixels;\n    var weight = Math.exp(-x * x / 2);\n    weights.push(weight);\n\n    if (i == 0) {\n      sum += weight;\n    } else if (i < samples) {\n      sum += 2 * weight;\n    }\n  }\n\n  for (var i = 0; i < weights.length; i++) {\n    weights[i] = weights[i] / sum;\n  }\n\n  blurUniforms['envMap'].value = targetIn.texture;\n  blurUniforms['samples'].value = samples;\n  blurUniforms['weights'].value = weights;\n  blurUniforms['latitudinal'].value = direction === 'latitudinal';\n\n  if (poleAxis) {\n    blurUniforms['poleAxis'].value = poleAxis;\n  }\n\n  blurUniforms['dTheta'].value = radiansPerPixel;\n  blurUniforms['mipInt'].value = LOD_MAX - lodIn;\n  blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];\n  blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];\n  var outputSize = _sizeLods[lodOut];\n  var x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);\n  var y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);\n\n  _renderer.setRenderTarget(targetOut);\n\n  _setViewport(x, y, 3 * outputSize, 2 * outputSize);\n\n  _renderer.render(blurScene, _flatCamera);\n}\n\nfunction _getBlurShader(maxSamples) {\n  var weights = new Float32Array(maxSamples);\n  var poleAxis = new Vector3(0, 1, 0);\n  var shaderMaterial = new RawShaderMaterial({\n    defines: {\n      'n': maxSamples\n    },\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'samples': {\n        value: 1\n      },\n      'weights': {\n        value: weights\n      },\n      'latitudinal': {\n        value: false\n      },\n      'dTheta': {\n        value: 0\n      },\n      'mipInt': {\n        value: 0\n      },\n      'poleAxis': {\n        value: poleAxis\n      },\n      'inputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      },\n      'outputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader: \"\\nprecision mediump float;\\nprecision mediump int;\\nvarying vec3 vOutputDirection;\\nuniform sampler2D envMap;\\nuniform int samples;\\nuniform float weights[n];\\nuniform bool latitudinal;\\nuniform float dTheta;\\nuniform float mipInt;\\nuniform vec3 poleAxis;\\n\\n\".concat(_getEncodings(), \"\\n\\n#define ENVMAP_TYPE_CUBE_UV\\n#include <cube_uv_reflection_fragment>\\n\\nvoid main() {\\n\\tgl_FragColor = vec4(0.0);\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tif (i >= samples)\\n\\t\\t\\tbreak;\\n\\t\\tfor (int dir = -1; dir < 2; dir += 2) {\\n\\t\\t\\tif (i == 0 && dir == 1)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\\n\\t\\t\\tif (all(equal(axis, vec3(0.0))))\\n\\t\\t\\t\\taxis = cross(vec3(0.0, 1.0, 0.0), vOutputDirection);\\n\\t\\t\\taxis = normalize(axis);\\n\\t\\t\\tfloat theta = dTheta * float(dir * i);\\n\\t\\t\\tfloat cosTheta = cos(theta);\\n\\t\\t\\t// Rodrigues' axis-angle rotation\\n\\t\\t\\tvec3 sampleDirection = vOutputDirection * cosTheta\\n\\t\\t\\t\\t\\t+ cross(axis, vOutputDirection) * sin(theta)\\n\\t\\t\\t\\t\\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\\n\\t\\t\\tgl_FragColor.rgb +=\\n\\t\\t\\t\\t\\tweights[i] * bilinearCubeUV(envMap, sampleDirection, mipInt);\\n\\t\\t}\\n\\t}\\n\\tgl_FragColor = linearToOutputTexel(gl_FragColor);\\n}\\n\\t\\t\"),\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  shaderMaterial.type = 'SphericalGaussianBlur';\n  return shaderMaterial;\n}\n\nfunction _getEquirectShader() {\n  var texelSize = new Vector2(1, 1);\n  var shaderMaterial = new RawShaderMaterial({\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'texelSize': {\n        value: texelSize\n      },\n      'inputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      },\n      'outputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader: \"\\nprecision mediump float;\\nprecision mediump int;\\nvarying vec3 vOutputDirection;\\nuniform sampler2D envMap;\\nuniform vec2 texelSize;\\n\\n\".concat(_getEncodings(), \"\\n\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n\\nvoid main() {\\n\\tgl_FragColor = vec4(0.0);\\n\\tvec3 outputDirection = normalize(vOutputDirection);\\n\\tvec2 uv;\\n\\tuv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\\n\\tuv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;\\n\\tvec2 f = fract(uv / texelSize - 0.5);\\n\\tuv -= f * texelSize;\\n\\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\\n\\tuv.x += texelSize.x;\\n\\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\\n\\tuv.y += texelSize.y;\\n\\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\\n\\tuv.x -= texelSize.x;\\n\\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\\n\\tvec3 tm = mix(tl, tr, f.x);\\n\\tvec3 bm = mix(bl, br, f.x);\\n\\tgl_FragColor.rgb = mix(tm, bm, f.y);\\n\\tgl_FragColor = linearToOutputTexel(gl_FragColor);\\n}\\n\\t\\t\"),\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  shaderMaterial.type = 'EquirectangularToCubeUV';\n  return shaderMaterial;\n}\n\nfunction _getCubemapShader() {\n  var shaderMaterial = new RawShaderMaterial({\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'inputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      },\n      'outputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader: \"\\nprecision mediump float;\\nprecision mediump int;\\nvarying vec3 vOutputDirection;\\nuniform samplerCube envMap;\\n\\n\".concat(_getEncodings(), \"\\n\\nvoid main() {\\n\\tgl_FragColor = vec4(0.0);\\n\\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\\n\\tgl_FragColor = linearToOutputTexel(gl_FragColor);\\n}\\n\\t\\t\"),\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  shaderMaterial.type = 'CubemapToCubeUV';\n  return shaderMaterial;\n}\n\nfunction _getCommonVertexShader() {\n  return \"\\nprecision mediump float;\\nprecision mediump int;\\nattribute vec3 position;\\nattribute vec2 uv;\\nattribute float faceIndex;\\nvarying vec3 vOutputDirection;\\nvec3 getDirection(vec2 uv, float face) {\\n\\tuv = 2.0 * uv - 1.0;\\n\\tvec3 direction = vec3(uv, 1.0);\\n\\tif (face == 0.0) {\\n\\t\\tdirection = direction.zyx;\\n\\t\\tdirection.z *= -1.0;\\n\\t} else if (face == 1.0) {\\n\\t\\tdirection = direction.xzy;\\n\\t\\tdirection.z *= -1.0;\\n\\t} else if (face == 3.0) {\\n\\t\\tdirection = direction.zyx;\\n\\t\\tdirection.x *= -1.0;\\n\\t} else if (face == 4.0) {\\n\\t\\tdirection = direction.xzy;\\n\\t\\tdirection.y *= -1.0;\\n\\t} else if (face == 5.0) {\\n\\t\\tdirection.xz *= -1.0;\\n\\t}\\n\\treturn direction;\\n}\\nvoid main() {\\n\\tvOutputDirection = getDirection(uv, faceIndex);\\n\\tgl_Position = vec4( position, 1.0 );\\n}\\n\\t\";\n}\n\nfunction _getEncodings() {\n  return \"\\nuniform int inputEncoding;\\nuniform int outputEncoding;\\n\\n#include <encodings_pars_fragment>\\n\\nvec4 inputTexelToLinear(vec4 value){\\n\\tif(inputEncoding == 0){\\n\\t\\treturn value;\\n\\t}else if(inputEncoding == 1){\\n\\t\\treturn sRGBToLinear(value);\\n\\t}else if(inputEncoding == 2){\\n\\t\\treturn RGBEToLinear(value);\\n\\t}else if(inputEncoding == 3){\\n\\t\\treturn RGBMToLinear(value, 7.0);\\n\\t}else if(inputEncoding == 4){\\n\\t\\treturn RGBMToLinear(value, 16.0);\\n\\t}else if(inputEncoding == 5){\\n\\t\\treturn RGBDToLinear(value, 256.0);\\n\\t}else{\\n\\t\\treturn GammaToLinear(value, 2.2);\\n\\t}\\n}\\n\\nvec4 linearToOutputTexel(vec4 value){\\n\\tif(outputEncoding == 0){\\n\\t\\treturn value;\\n\\t}else if(outputEncoding == 1){\\n\\t\\treturn LinearTosRGB(value);\\n\\t}else if(outputEncoding == 2){\\n\\t\\treturn LinearToRGBE(value);\\n\\t}else if(outputEncoding == 3){\\n\\t\\treturn LinearToRGBM(value, 7.0);\\n\\t}else if(outputEncoding == 4){\\n\\t\\treturn LinearToRGBM(value, 16.0);\\n\\t}else if(outputEncoding == 5){\\n\\t\\treturn LinearToRGBD(value, 256.0);\\n\\t}else{\\n\\t\\treturn LinearToGamma(value, 2.2);\\n\\t}\\n}\\n\\nvec4 envMapTexelToLinear(vec4 color) {\\n\\treturn inputTexelToLinear(color);\\n}\\n\\t\";\n}\n\nexport { PMREMGenerator };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/extras/PMREMGenerator.js"],"names":["CubeUVReflectionMapping","GammaEncoding","LinearEncoding","LinearToneMapping","NearestFilter","NoBlending","RGBDEncoding","RGBEEncoding","RGBEFormat","RGBM16Encoding","RGBM7Encoding","UnsignedByteType","sRGBEncoding","BufferAttribute","BufferGeometry","Mesh","OrthographicCamera","PerspectiveCamera","RawShaderMaterial","Scene","Vector2","Vector3","WebGLRenderTarget","LOD_MIN","LOD_MAX","SIZE_MAX","Math","pow","EXTRA_LOD_SIGMA","TOTAL_LODS","length","MAX_SAMPLES","ENCODINGS","_flatCamera","_blurMaterial","_getBlurShader","_equirectShader","_cubemapShader","_createPlanes","_lodPlanes","_sizeLods","_sigmas","_pingPongRenderTarget","_renderer","PHI","sqrt","INV_PHI","_axisDirections","PMREMGenerator","renderer","_compileMaterial","prototype","constructor","fromScene","scene","sigma","near","far","cubeUVRenderTarget","_allocateTargets","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","scissorTest","fromEquirectangular","equirectangular","magFilter","minFilter","generateMipmaps","fromCubemap","cubemap","_textureToCubeUV","compileCubemapShader","_getCubemapShader","compileEquirectangularShader","_getEquirectShader","dispose","i","lod","sizeLod","push","texelSize","min","max","uv1","cubeFaces","vertices","positionSize","uvSize","faceIndexSize","position","Float32Array","uv","faceIndex","face","x","y","coordinates","set","fill","planes","setAttribute","params","type","format","encoding","depthBuffer","stencilBuffer","_createRenderTarget","setRenderTarget","size","getSize","setViewport","fov","aspect","cubeCamera","upSign","forwardSign","outputEncoding","toneMapping","toneMappingExposure","clearColor","getClearColor","clearAlpha","getClearAlpha","scale","z","background","isColor","convertSRGBToLinear","maxComponent","r","g","b","fExp","ceil","log2","multiplyScalar","alpha","setClearColor","col","up","lookAt","_setViewport","render","texture","isCubeTexture","material","add","uniforms","value","image","width","height","tmpScene","compile","mapping","name","invDpr","getPixelRatio","setScissor","autoClear","poleAxis","lodIn","lodOut","_halfBlur","targetIn","targetOut","sigmaRadians","direction","console","error","STANDARD_DEVIATIONS","blurScene","blurUniforms","pixels","radiansPerPixel","isFinite","PI","sigmaPixels","samples","floor","warn","weights","sum","weight","exp","outputSize","maxSamples","shaderMaterial","defines","vertexShader","_getCommonVertexShader","fragmentShader","_getEncodings","blending","depthTest","depthWrite"],"mappings":"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","sourcesContent":["/**\n * @author Emmett Lalish / elalish\n *\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n */\n\nimport {\n\tCubeUVReflectionMapping,\n\tGammaEncoding,\n\tLinearEncoding,\n\tLinearToneMapping,\n\tNearestFilter,\n\tNoBlending,\n\tRGBDEncoding,\n\tRGBEEncoding,\n\tRGBEFormat,\n\tRGBM16Encoding,\n\tRGBM7Encoding,\n\tUnsignedByteType,\n\tsRGBEncoding\n} from \"../constants.js\";\n\nimport { BufferAttribute } from \"../core/BufferAttribute.js\";\nimport { BufferGeometry } from \"../core/BufferGeometry.js\";\nimport { Mesh } from \"../objects/Mesh.js\";\nimport { OrthographicCamera } from \"../cameras/OrthographicCamera.js\";\nimport { PerspectiveCamera } from \"../cameras/PerspectiveCamera.js\";\nimport { RawShaderMaterial } from \"../materials/RawShaderMaterial.js\";\nimport { Scene } from \"../scenes/Scene.js\";\nimport { Vector2 } from \"../math/Vector2.js\";\nimport { Vector3 } from \"../math/Vector3.js\";\nimport { WebGLRenderTarget } from \"../renderers/WebGLRenderTarget.js\";\n\nvar LOD_MIN = 4;\nvar LOD_MAX = 8;\nvar SIZE_MAX = Math.pow( 2, LOD_MAX );\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nvar EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\nvar TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nvar MAX_SAMPLES = 20;\nvar ENCODINGS = {\n\t[ LinearEncoding ]: 0,\n\t[ sRGBEncoding ]: 1,\n\t[ RGBEEncoding ]: 2,\n\t[ RGBM7Encoding ]: 3,\n\t[ RGBM16Encoding ]: 4,\n\t[ RGBDEncoding ]: 5,\n\t[ GammaEncoding ]: 6\n};\n\nvar _flatCamera = new OrthographicCamera();\nvar _blurMaterial = _getBlurShader( MAX_SAMPLES );\nvar _equirectShader = null;\nvar _cubemapShader = null;\n\nvar { _lodPlanes, _sizeLods, _sigmas } = _createPlanes();\nvar _pingPongRenderTarget = null;\nvar _renderer = null;\n\n// Golden Ratio\nvar PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\nvar INV_PHI = 1 / PHI;\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nvar _axisDirections = [\n\tnew Vector3( 1, 1, 1 ),\n\tnew Vector3( - 1, 1, 1 ),\n\tnew Vector3( 1, 1, - 1 ),\n\tnew Vector3( - 1, 1, - 1 ),\n\tnew Vector3( 0, PHI, INV_PHI ),\n\tnew Vector3( 0, PHI, - INV_PHI ),\n\tnew Vector3( INV_PHI, 0, PHI ),\n\tnew Vector3( - INV_PHI, 0, PHI ),\n\tnew Vector3( PHI, INV_PHI, 0 ),\n\tnew Vector3( - PHI, INV_PHI, 0 ) ];\n\nfunction PMREMGenerator( renderer ) {\n\n\t_renderer = renderer;\n\t_compileMaterial( _blurMaterial );\n\n}\n\nPMREMGenerator.prototype = {\n\n\tconstructor: PMREMGenerator,\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t */\n\tfromScene: function ( scene, sigma = 0, near = 0.1, far = 100 ) {\n\n\t\tvar cubeUVRenderTarget = _allocateTargets();\n\t\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget );\n\t\tif ( sigma > 0 ) {\n\n\t\t\t_blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\t\t_applyPMREM( cubeUVRenderTarget );\n\t\t_cleanup();\n\t\tcubeUVRenderTarget.scissorTest = false;\n\n\t\treturn cubeUVRenderTarget;\n\n\t},\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromEquirectangular: function ( equirectangular ) {\n\n\t\tequirectangular.magFilter = NearestFilter;\n\t\tequirectangular.minFilter = NearestFilter;\n\t\tequirectangular.generateMipmaps = false;\n\n\t\treturn this.fromCubemap( equirectangular );\n\n\t},\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromCubemap: function ( cubemap ) {\n\n\t\tvar cubeUVRenderTarget = _allocateTargets( cubemap );\n\t\t_textureToCubeUV( cubemap, cubeUVRenderTarget );\n\t\t_applyPMREM( cubeUVRenderTarget );\n\t\t_cleanup();\n\t\tcubeUVRenderTarget.scissorTest = false;\n\n\t\treturn cubeUVRenderTarget;\n\n\t},\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileCubemapShader: function () {\n\n\t\tif ( _cubemapShader == null ) {\n\n\t\t\t_cubemapShader = _getCubemapShader();\n\t\t\t_compileMaterial( _cubemapShader );\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileEquirectangularShader: function () {\n\n\t\tif ( _equirectShader == null ) {\n\n\t\t\t_equirectShader = _getEquirectShader();\n\t\t\t_compileMaterial( _equirectShader );\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose: function () {\n\n\t\t_blurMaterial.dispose();\n\n\t\tif ( _cubemapShader != null ) _cubemapShader.dispose();\n\t\tif ( _equirectShader != null ) _equirectShader.dispose();\n\n\t\tfor ( var i = 0; i < _lodPlanes.length; i ++ ) {\n\n\t\t\t_lodPlanes[ i ].dispose();\n\n\t\t}\n\n\t},\n\n};\n\nfunction _createPlanes() {\n\n\tvar _lodPlanes = [];\n\tvar _sizeLods = [];\n\tvar _sigmas = [];\n\n\tvar lod = LOD_MAX;\n\tfor ( var i = 0; i < TOTAL_LODS; i ++ ) {\n\n\t\tvar sizeLod = Math.pow( 2, lod );\n\t\t_sizeLods.push( sizeLod );\n\t\tvar sigma = 1.0 / sizeLod;\n\t\tif ( i > LOD_MAX - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ];\n\n\t\t} else if ( i == 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\t\t_sigmas.push( sigma );\n\n\t\tvar texelSize = 1.0 / ( sizeLod - 1 );\n\t\tvar min = - texelSize / 2;\n\t\tvar max = 1 + texelSize / 2;\n\t\tvar uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tvar cubeFaces = 6;\n\t\tvar vertices = 6;\n\t\tvar positionSize = 3;\n\t\tvar uvSize = 2;\n\t\tvar faceIndexSize = 1;\n\n\t\tvar position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tvar uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tvar faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( var face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tvar x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tvar y = face > 2 ? 0 : - 1;\n\t\t\tvar coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\t\t\tposition.set( coordinates, positionSize * vertices * face );\n\t\t\tuv.set( uv1, uvSize * vertices * face );\n\t\t\tvar fill = [ face, face, face, face, face, face ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * face );\n\n\t\t}\n\t\tvar planes = new BufferGeometry();\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\n\t\t_lodPlanes.push( planes );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\treturn { _lodPlanes, _sizeLods, _sigmas };\n\n}\n\nfunction _allocateTargets( equirectangular ) {\n\n\tvar params = {\n\t\tmagFilter: NearestFilter,\n\t\tminFilter: NearestFilter,\n\t\tgenerateMipmaps: false,\n\t\ttype: equirectangular ? equirectangular.type : UnsignedByteType,\n\t\tformat: equirectangular ? equirectangular.format : RGBEFormat,\n\t\tencoding: equirectangular ? equirectangular.encoding : RGBEEncoding,\n\t\tdepthBuffer: false,\n\t\tstencilBuffer: false\n\t};\n\tvar cubeUVRenderTarget = _createRenderTarget( params );\n\tcubeUVRenderTarget.depthBuffer = equirectangular ? false : true;\n\t_pingPongRenderTarget = _createRenderTarget( params );\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _cleanup() {\n\n\t_pingPongRenderTarget.dispose();\n\t_renderer.setRenderTarget( null );\n\tvar size = _renderer.getSize( new Vector2() );\n\t_renderer.setViewport( 0, 0, size.x, size.y );\n\n}\n\nfunction _sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {\n\n\tvar fov = 90;\n\tvar aspect = 1;\n\tvar cubeCamera = new PerspectiveCamera( fov, aspect, near, far );\n\tvar upSign = [ 1, 1, 1, 1, - 1, 1 ];\n\tvar forwardSign = [ 1, 1, - 1, - 1, - 1, 1 ];\n\n\tvar outputEncoding = _renderer.outputEncoding;\n\tvar toneMapping = _renderer.toneMapping;\n\tvar toneMappingExposure = _renderer.toneMappingExposure;\n\tvar clearColor = _renderer.getClearColor();\n\tvar clearAlpha = _renderer.getClearAlpha();\n\n\t_renderer.toneMapping = LinearToneMapping;\n\t_renderer.toneMappingExposure = 1.0;\n\t_renderer.outputEncoding = LinearEncoding;\n\tscene.scale.z *= - 1;\n\n\tvar background = scene.background;\n\tif ( background && background.isColor ) {\n\n\t\tbackground.convertSRGBToLinear();\n\t\t// Convert linear to RGBE\n\t\tvar maxComponent = Math.max( background.r, background.g, background.b );\n\t\tvar fExp = Math.min( Math.max( Math.ceil( Math.log2( maxComponent ) ), - 128.0 ), 127.0 );\n\t\tbackground = background.multiplyScalar( Math.pow( 2.0, - fExp ) );\n\t\tvar alpha = ( fExp + 128.0 ) / 255.0;\n\t\t_renderer.setClearColor( background, alpha );\n\t\tscene.background = null;\n\n\t}\n\n\t_renderer.setRenderTarget( cubeUVRenderTarget );\n\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\tvar col = i % 3;\n\t\tif ( col == 0 ) {\n\n\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\tcubeCamera.lookAt( forwardSign[ i ], 0, 0 );\n\n\t\t} else if ( col == 1 ) {\n\n\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\tcubeCamera.lookAt( 0, forwardSign[ i ], 0 );\n\n\t\t} else {\n\n\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\tcubeCamera.lookAt( 0, 0, forwardSign[ i ] );\n\n\t\t}\n\t\t_setViewport(\n\t\t\tcol * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX );\n\t\t_renderer.render( scene, cubeCamera );\n\n\t}\n\n\t_renderer.toneMapping = toneMapping;\n\t_renderer.toneMappingExposure = toneMappingExposure;\n\t_renderer.outputEncoding = outputEncoding;\n\t_renderer.setClearColor( clearColor, clearAlpha );\n\tscene.scale.z *= - 1;\n\n}\n\nfunction _textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\tvar scene = new Scene();\n\tif ( texture.isCubeTexture ) {\n\n\t\tif ( _cubemapShader == null ) {\n\n\t\t\t_cubemapShader = _getCubemapShader();\n\n\t\t}\n\n\t} else {\n\n\t\tif ( _equirectShader == null ) {\n\n\t\t\t_equirectShader = _getEquirectShader();\n\n\t\t}\n\n\t}\n\tvar material = texture.isCubeTexture ? _cubemapShader : _equirectShader;\n\tscene.add( new Mesh( _lodPlanes[ 0 ], material ) );\n\tvar uniforms = material.uniforms;\n\n\tuniforms[ 'envMap' ].value = texture;\n\tif ( ! texture.isCubeTexture ) {\n\n\t\tuniforms[ 'texelSize' ].value.set( 1.0 / texture.image.width, 1.0 / texture.image.height );\n\n\t}\n\tuniforms[ 'inputEncoding' ].value = ENCODINGS[ texture.encoding ];\n\tuniforms[ 'outputEncoding' ].value = ENCODINGS[ texture.encoding ];\n\n\t_renderer.setRenderTarget( cubeUVRenderTarget );\n\t_setViewport( 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX );\n\t_renderer.render( scene, _flatCamera );\n\n}\n\nfunction _compileMaterial( material ) {\n\n\tvar tmpScene = new Scene();\n\ttmpScene.add( new Mesh( _lodPlanes[ 0 ], material ) );\n\t_renderer.compile( tmpScene, _flatCamera );\n\n}\n\nfunction _createRenderTarget( params ) {\n\n\tvar cubeUVRenderTarget = new WebGLRenderTarget( 3 * SIZE_MAX, 3 * SIZE_MAX, params );\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( x, y, width, height ) {\n\n\tvar invDpr = 1.0 / _renderer.getPixelRatio();\n\tx *= invDpr;\n\ty *= invDpr;\n\twidth *= invDpr;\n\theight *= invDpr;\n\t_renderer.setViewport( x, y, width, height );\n\t_renderer.setScissor( x, y, width, height );\n\n}\n\nfunction _applyPMREM( cubeUVRenderTarget ) {\n\n\tvar autoClear = _renderer.autoClear;\n\t_renderer.autoClear = false;\n\n\tfor ( var i = 1; i < TOTAL_LODS; i ++ ) {\n\n\t\tvar sigma = Math.sqrt(\n\t\t\t_sigmas[ i ] * _sigmas[ i ] -\n\t\t_sigmas[ i - 1 ] * _sigmas[ i - 1 ] );\n\t\tvar poleAxis =\n\t\t_axisDirections[ ( i - 1 ) % _axisDirections.length ];\n\t\t_blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\n\n\t}\n\n\t_renderer.autoClear = autoClear;\n\n}\n\n/**\n * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n * vertically and horizontally, but this breaks down on a cube. Here we apply\n * the blur latitudinally (around the poles), and then longitudinally (towards\n * the poles) to approximate the orthogonally-separable blur. It is least\n * accurate at the poles, but still does a decent job.\n */\nfunction _blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t_halfBlur(\n\t\tcubeUVRenderTarget,\n\t\t_pingPongRenderTarget,\n\t\tlodIn,\n\t\tlodOut,\n\t\tsigma,\n\t\t'latitudinal',\n\t\tpoleAxis );\n\n\t_halfBlur(\n\t\t_pingPongRenderTarget,\n\t\tcubeUVRenderTarget,\n\t\tlodOut,\n\t\tlodOut,\n\t\tsigma,\n\t\t'longitudinal',\n\t\tpoleAxis );\n\n}\n\nfunction _halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\tconsole.error(\n\t\t\t'blur direction must be either latitudinal or longitudinal!' );\n\n\t}\n\n\t// Number of standard deviations at which to cut off the discrete approximation.\n\tvar STANDARD_DEVIATIONS = 3;\n\n\tvar blurScene = new Scene();\n\tblurScene.add( new Mesh( _lodPlanes[ lodOut ], _blurMaterial ) );\n\tvar blurUniforms = _blurMaterial.uniforms;\n\n\tvar pixels = _sizeLods[ lodIn ] - 1;\n\tvar radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\tvar sigmaPixels = sigmaRadians / radiansPerPixel;\n\tvar samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\tif ( samples > MAX_SAMPLES ) {\n\n\t\tconsole.warn( `sigmaRadians, ${\n\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t}\n\n\tvar weights = [];\n\tvar sum = 0;\n\n\tfor ( var i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\tvar x = i / sigmaPixels;\n\t\tvar weight = Math.exp( - x * x / 2 );\n\t\tweights.push( weight );\n\n\t\tif ( i == 0 ) {\n\n\t\t\tsum += weight;\n\n\t\t} else if ( i < samples ) {\n\n\t\t\tsum += 2 * weight;\n\n\t\t}\n\n\t}\n\n\tfor ( var i = 0; i < weights.length; i ++ ) {\n\n\t\tweights[ i ] = weights[ i ] / sum;\n\n\t}\n\n\tblurUniforms[ 'envMap' ].value = targetIn.texture;\n\tblurUniforms[ 'samples' ].value = samples;\n\tblurUniforms[ 'weights' ].value = weights;\n\tblurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';\n\tif ( poleAxis ) {\n\n\t\tblurUniforms[ 'poleAxis' ].value = poleAxis;\n\n\t}\n\tblurUniforms[ 'dTheta' ].value = radiansPerPixel;\n\tblurUniforms[ 'mipInt' ].value = LOD_MAX - lodIn;\n\tblurUniforms[ 'inputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];\n\tblurUniforms[ 'outputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];\n\n\tvar outputSize = _sizeLods[ lodOut ];\n\tvar x = 3 * Math.max( 0, SIZE_MAX - 2 * outputSize );\n\tvar y = ( lodOut === 0 ? 0 : 2 * SIZE_MAX ) +\n\t2 * outputSize *\n\t\t( lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0 );\n\n\t_renderer.setRenderTarget( targetOut );\n\t_setViewport( x, y, 3 * outputSize, 2 * outputSize );\n\t_renderer.render( blurScene, _flatCamera );\n\n}\n\nfunction _getBlurShader( maxSamples ) {\n\n\tvar weights = new Float32Array( maxSamples );\n\tvar poleAxis = new Vector3( 0, 1, 0 );\n\tvar shaderMaterial = new RawShaderMaterial( {\n\n\t\tdefines: { 'n': maxSamples },\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'samples': { value: 1 },\n\t\t\t'weights': { value: weights },\n\t\t\t'latitudinal': { value: false },\n\t\t\t'dTheta': { value: 0 },\n\t\t\t'mipInt': { value: 0 },\n\t\t\t'poleAxis': { value: poleAxis },\n\t\t\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\n\t\t\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n${_getEncodings()}\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfor (int dir = -1; dir < 2; dir += 2) {\n\t\t\tif (i == 0 && dir == 1)\n\t\t\t\tcontinue;\n\t\t\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\t\t\tif (all(equal(axis, vec3(0.0))))\n\t\t\t\taxis = cross(vec3(0.0, 1.0, 0.0), vOutputDirection);\n\t\t\taxis = normalize(axis);\n\t\t\tfloat theta = dTheta * float(dir * i);\n\t\t\tfloat cosTheta = cos(theta);\n\t\t\t// Rodrigues' axis-angle rotation\n\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t\t\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\t\t\tgl_FragColor.rgb +=\n\t\t\t\t\tweights[i] * bilinearCubeUV(envMap, sampleDirection, mipInt);\n\t\t}\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\tshaderMaterial.type = 'SphericalGaussianBlur';\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getEquirectShader() {\n\n\tvar texelSize = new Vector2( 1, 1 );\n\tvar shaderMaterial = new RawShaderMaterial( {\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'texelSize': { value: texelSize },\n\t\t\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\n\t\t\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n${_getEncodings()}\n\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv;\n\tuv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\n\tuv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\tshaderMaterial.type = 'EquirectangularToCubeUV';\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getCubemapShader() {\n\n\tvar shaderMaterial = new RawShaderMaterial( {\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\n\t\t\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n${_getEncodings()}\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\tshaderMaterial.type = 'CubemapToCubeUV';\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getCommonVertexShader() {\n\n\treturn `\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.x *= -1.0;\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.y *= -1.0;\n\t} else if (face == 5.0) {\n\t\tdirection.xz *= -1.0;\n\t}\n\treturn direction;\n}\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t`;\n\n}\n\nfunction _getEncodings() {\n\n\treturn `\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t`;\n\n}\n\nexport { PMREMGenerator };\n"]},"metadata":{},"sourceType":"module"}