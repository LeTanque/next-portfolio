{"ast":null,"code":"/**\n * @author tschw\n */\nimport { Matrix3 } from '../../math/Matrix3.js';\nimport { Plane } from '../../math/Plane.js';\n\nfunction WebGLClipping() {\n  var scope = this,\n      globalState = null,\n      numGlobalPlanes = 0,\n      localClippingEnabled = false,\n      renderingShadows = false,\n      plane = new Plane(),\n      viewNormalMatrix = new Matrix3(),\n      uniform = {\n    value: null,\n    needsUpdate: false\n  };\n  this.uniform = uniform;\n  this.numPlanes = 0;\n  this.numIntersection = 0;\n\n  this.init = function (planes, enableLocalClipping, camera) {\n    var enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to\n    // run another frame in order to reset the state:\n    numGlobalPlanes !== 0 || localClippingEnabled;\n    localClippingEnabled = enableLocalClipping;\n    globalState = projectPlanes(planes, camera, 0);\n    numGlobalPlanes = planes.length;\n    return enabled;\n  };\n\n  this.beginShadows = function () {\n    renderingShadows = true;\n    projectPlanes(null);\n  };\n\n  this.endShadows = function () {\n    renderingShadows = false;\n    resetGlobalState();\n  };\n\n  this.setState = function (planes, clipIntersection, clipShadows, camera, cache, fromCache) {\n    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {\n      // there's no local clipping\n      if (renderingShadows) {\n        // there's no global clipping\n        projectPlanes(null);\n      } else {\n        resetGlobalState();\n      }\n    } else {\n      var nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n          lGlobal = nGlobal * 4,\n          dstArray = cache.clippingState || null;\n      uniform.value = dstArray; // ensure unique state\n\n      dstArray = projectPlanes(planes, camera, lGlobal, fromCache);\n\n      for (var i = 0; i !== lGlobal; ++i) {\n        dstArray[i] = globalState[i];\n      }\n\n      cache.clippingState = dstArray;\n      this.numIntersection = clipIntersection ? this.numPlanes : 0;\n      this.numPlanes += nGlobal;\n    }\n  };\n\n  function resetGlobalState() {\n    if (uniform.value !== globalState) {\n      uniform.value = globalState;\n      uniform.needsUpdate = numGlobalPlanes > 0;\n    }\n\n    scope.numPlanes = numGlobalPlanes;\n    scope.numIntersection = 0;\n  }\n\n  function projectPlanes(planes, camera, dstOffset, skipTransform) {\n    var nPlanes = planes !== null ? planes.length : 0,\n        dstArray = null;\n\n    if (nPlanes !== 0) {\n      dstArray = uniform.value;\n\n      if (skipTransform !== true || dstArray === null) {\n        var flatSize = dstOffset + nPlanes * 4,\n            viewMatrix = camera.matrixWorldInverse;\n        viewNormalMatrix.getNormalMatrix(viewMatrix);\n\n        if (dstArray === null || dstArray.length < flatSize) {\n          dstArray = new Float32Array(flatSize);\n        }\n\n        for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {\n          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);\n          plane.normal.toArray(dstArray, i4);\n          dstArray[i4 + 3] = plane.constant;\n        }\n      }\n\n      uniform.value = dstArray;\n      uniform.needsUpdate = true;\n    }\n\n    scope.numPlanes = nPlanes;\n    return dstArray;\n  }\n}\n\nexport { WebGLClipping };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/renderers/webgl/WebGLClipping.js"],"names":["Matrix3","Plane","WebGLClipping","scope","globalState","numGlobalPlanes","localClippingEnabled","renderingShadows","plane","viewNormalMatrix","uniform","value","needsUpdate","numPlanes","numIntersection","init","planes","enableLocalClipping","camera","enabled","length","projectPlanes","beginShadows","endShadows","resetGlobalState","setState","clipIntersection","clipShadows","cache","fromCache","nGlobal","lGlobal","dstArray","clippingState","i","dstOffset","skipTransform","nPlanes","flatSize","viewMatrix","matrixWorldInverse","getNormalMatrix","Float32Array","i4","copy","applyMatrix4","normal","toArray","constant"],"mappings":"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","sourcesContent":["/**\n * @author tschw\n */\n\nimport { Matrix3 } from '../../math/Matrix3.js';\nimport { Plane } from '../../math/Plane.js';\n\nfunction WebGLClipping() {\n\n\tvar scope = this,\n\n\t\tglobalState = null,\n\t\tnumGlobalPlanes = 0,\n\t\tlocalClippingEnabled = false,\n\t\trenderingShadows = false,\n\n\t\tplane = new Plane(),\n\t\tviewNormalMatrix = new Matrix3(),\n\n\t\tuniform = { value: null, needsUpdate: false };\n\n\tthis.uniform = uniform;\n\tthis.numPlanes = 0;\n\tthis.numIntersection = 0;\n\n\tthis.init = function ( planes, enableLocalClipping, camera ) {\n\n\t\tvar enabled =\n\t\t\tplanes.length !== 0 ||\n\t\t\tenableLocalClipping ||\n\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\tlocalClippingEnabled;\n\n\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\tnumGlobalPlanes = planes.length;\n\n\t\treturn enabled;\n\n\t};\n\n\tthis.beginShadows = function () {\n\n\t\trenderingShadows = true;\n\t\tprojectPlanes( null );\n\n\t};\n\n\tthis.endShadows = function () {\n\n\t\trenderingShadows = false;\n\t\tresetGlobalState();\n\n\t};\n\n\tthis.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\n\n\t\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\n\n\t\t\t// there's no local clipping\n\n\t\t\tif ( renderingShadows ) {\n\n\t\t\t\t// there's no global clipping\n\n\t\t\t\tprojectPlanes( null );\n\n\t\t\t} else {\n\n\t\t\t\tresetGlobalState();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\tlGlobal = nGlobal * 4,\n\n\t\t\t\tdstArray = cache.clippingState || null;\n\n\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\n\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t}\n\n\t\t\tcache.clippingState = dstArray;\n\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\tthis.numPlanes += nGlobal;\n\n\t\t}\n\n\n\t};\n\n\tfunction resetGlobalState() {\n\n\t\tif ( uniform.value !== globalState ) {\n\n\t\t\tuniform.value = globalState;\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t}\n\n\t\tscope.numPlanes = numGlobalPlanes;\n\t\tscope.numIntersection = 0;\n\n\t}\n\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\tdstArray = null;\n\n\t\tif ( nPlanes !== 0 ) {\n\n\t\t\tdstArray = uniform.value;\n\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tuniform.value = dstArray;\n\t\t\tuniform.needsUpdate = true;\n\n\t\t}\n\n\t\tscope.numPlanes = nPlanes;\n\n\t\treturn dstArray;\n\n\t}\n\n}\n\n\nexport { WebGLClipping };\n"]},"metadata":{},"sourceType":"module"}