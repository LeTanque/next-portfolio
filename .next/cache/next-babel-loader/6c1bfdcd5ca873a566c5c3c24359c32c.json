{"ast":null,"code":"import _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport { LinearFilter } from '../constants.js';\nimport { FileLoader } from './FileLoader.js';\nimport { CompressedTexture } from '../textures/CompressedTexture.js';\nimport { Loader } from './Loader.js';\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nfunction CompressedTextureLoader(manager) {\n  Loader.call(this, manager);\n}\n\nCompressedTextureLoader.prototype = _Object$assign(_Object$create(Loader.prototype), {\n  constructor: CompressedTextureLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var images = [];\n    var texture = new CompressedTexture();\n    texture.image = images;\n    var loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n\n    function loadTexture(i) {\n      loader.load(url[i], function (buffer) {\n        var texDatas = scope.parse(buffer, true);\n        images[i] = {\n          width: texDatas.width,\n          height: texDatas.height,\n          format: texDatas.format,\n          mipmaps: texDatas.mipmaps\n        };\n        loaded += 1;\n\n        if (loaded === 6) {\n          if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;\n          texture.format = texDatas.format;\n          texture.needsUpdate = true;\n          if (onLoad) onLoad(texture);\n        }\n      }, onProgress, onError);\n    }\n\n    if (_Array$isArray(url)) {\n      var loaded = 0;\n\n      for (var i = 0, il = url.length; i < il; ++i) {\n        loadTexture(i);\n      }\n    } else {\n      // compressed cubemap texture stored in a single DDS file\n      loader.load(url, function (buffer) {\n        var texDatas = scope.parse(buffer, true);\n\n        if (texDatas.isCubemap) {\n          var faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n          for (var f = 0; f < faces; f++) {\n            images[f] = {\n              mipmaps: []\n            };\n\n            for (var i = 0; i < texDatas.mipmapCount; i++) {\n              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);\n              images[f].format = texDatas.format;\n              images[f].width = texDatas.width;\n              images[f].height = texDatas.height;\n            }\n          }\n        } else {\n          texture.image.width = texDatas.width;\n          texture.image.height = texDatas.height;\n          texture.mipmaps = texDatas.mipmaps;\n        }\n\n        if (texDatas.mipmapCount === 1) {\n          texture.minFilter = LinearFilter;\n        }\n\n        texture.format = texDatas.format;\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }, onProgress, onError);\n    }\n\n    return texture;\n  }\n});\nexport { CompressedTextureLoader };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/loaders/CompressedTextureLoader.js"],"names":["LinearFilter","FileLoader","CompressedTexture","Loader","CompressedTextureLoader","manager","call","prototype","constructor","load","url","onLoad","onProgress","onError","scope","images","texture","image","loader","setPath","path","setResponseType","loadTexture","i","buffer","texDatas","parse","width","height","format","mipmaps","loaded","mipmapCount","minFilter","needsUpdate","il","length","isCubemap","faces","f","push"],"mappings":";;;AAAA,SAASA,YAAT,QAA6B,iBAA7B;AACA,SAASC,UAAT,QAA2B,iBAA3B;AACA,SAASC,iBAAT,QAAkC,kCAAlC;AACA,SAASC,MAAT,QAAuB,aAAvB;AAEA;;;;;;;;AAQA,SAASC,uBAAT,CAAkCC,OAAlC,EAA4C;AAE3CF,EAAAA,MAAM,CAACG,IAAP,CAAa,IAAb,EAAmBD,OAAnB;AAEA;;AAEDD,uBAAuB,CAACG,SAAxB,GAAoC,eAAe,eAAeJ,MAAM,CAACI,SAAtB,CAAf,EAAkD;AAErFC,EAAAA,WAAW,EAAEJ,uBAFwE;AAIrFK,EAAAA,IAAI,EAAE,cAAWC,GAAX,EAAgBC,MAAhB,EAAwBC,UAAxB,EAAoCC,OAApC,EAA8C;AAEnD,QAAIC,KAAK,GAAG,IAAZ;AAEA,QAAIC,MAAM,GAAG,EAAb;AAEA,QAAIC,OAAO,GAAG,IAAId,iBAAJ,EAAd;AACAc,IAAAA,OAAO,CAACC,KAAR,GAAgBF,MAAhB;AAEA,QAAIG,MAAM,GAAG,IAAIjB,UAAJ,CAAgB,KAAKI,OAArB,CAAb;AACAa,IAAAA,MAAM,CAACC,OAAP,CAAgB,KAAKC,IAArB;AACAF,IAAAA,MAAM,CAACG,eAAP,CAAwB,aAAxB;;AAEA,aAASC,WAAT,CAAsBC,CAAtB,EAA0B;AAEzBL,MAAAA,MAAM,CAACT,IAAP,CAAaC,GAAG,CAAEa,CAAF,CAAhB,EAAuB,UAAWC,MAAX,EAAoB;AAE1C,YAAIC,QAAQ,GAAGX,KAAK,CAACY,KAAN,CAAaF,MAAb,EAAqB,IAArB,CAAf;AAEAT,QAAAA,MAAM,CAAEQ,CAAF,CAAN,GAAc;AACbI,UAAAA,KAAK,EAAEF,QAAQ,CAACE,KADH;AAEbC,UAAAA,MAAM,EAAEH,QAAQ,CAACG,MAFJ;AAGbC,UAAAA,MAAM,EAAEJ,QAAQ,CAACI,MAHJ;AAIbC,UAAAA,OAAO,EAAEL,QAAQ,CAACK;AAJL,SAAd;AAOAC,QAAAA,MAAM,IAAI,CAAV;;AAEA,YAAKA,MAAM,KAAK,CAAhB,EAAoB;AAEnB,cAAKN,QAAQ,CAACO,WAAT,KAAyB,CAA9B,EACChB,OAAO,CAACiB,SAAR,GAAoBjC,YAApB;AAEDgB,UAAAA,OAAO,CAACa,MAAR,GAAiBJ,QAAQ,CAACI,MAA1B;AACAb,UAAAA,OAAO,CAACkB,WAAR,GAAsB,IAAtB;AAEA,cAAKvB,MAAL,EAAcA,MAAM,CAAEK,OAAF,CAAN;AAEd;AAED,OAzBD,EAyBGJ,UAzBH,EAyBeC,OAzBf;AA2BA;;AAED,QAAK,eAAeH,GAAf,CAAL,EAA4B;AAE3B,UAAIqB,MAAM,GAAG,CAAb;;AAEA,WAAM,IAAIR,CAAC,GAAG,CAAR,EAAWY,EAAE,GAAGzB,GAAG,CAAC0B,MAA1B,EAAkCb,CAAC,GAAGY,EAAtC,EAA0C,EAAGZ,CAA7C,EAAiD;AAEhDD,QAAAA,WAAW,CAAEC,CAAF,CAAX;AAEA;AAED,KAVD,MAUO;AAEN;AAEAL,MAAAA,MAAM,CAACT,IAAP,CAAaC,GAAb,EAAkB,UAAWc,MAAX,EAAoB;AAErC,YAAIC,QAAQ,GAAGX,KAAK,CAACY,KAAN,CAAaF,MAAb,EAAqB,IAArB,CAAf;;AAEA,YAAKC,QAAQ,CAACY,SAAd,EAA0B;AAEzB,cAAIC,KAAK,GAAGb,QAAQ,CAACK,OAAT,CAAiBM,MAAjB,GAA0BX,QAAQ,CAACO,WAA/C;;AAEA,eAAM,IAAIO,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGD,KAArB,EAA4BC,CAAC,EAA7B,EAAmC;AAElCxB,YAAAA,MAAM,CAAEwB,CAAF,CAAN,GAAc;AAAET,cAAAA,OAAO,EAAE;AAAX,aAAd;;AAEA,iBAAM,IAAIP,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGE,QAAQ,CAACO,WAA9B,EAA2CT,CAAC,EAA5C,EAAkD;AAEjDR,cAAAA,MAAM,CAAEwB,CAAF,CAAN,CAAYT,OAAZ,CAAoBU,IAApB,CAA0Bf,QAAQ,CAACK,OAAT,CAAkBS,CAAC,GAAGd,QAAQ,CAACO,WAAb,GAA2BT,CAA7C,CAA1B;AACAR,cAAAA,MAAM,CAAEwB,CAAF,CAAN,CAAYV,MAAZ,GAAqBJ,QAAQ,CAACI,MAA9B;AACAd,cAAAA,MAAM,CAAEwB,CAAF,CAAN,CAAYZ,KAAZ,GAAoBF,QAAQ,CAACE,KAA7B;AACAZ,cAAAA,MAAM,CAAEwB,CAAF,CAAN,CAAYX,MAAZ,GAAqBH,QAAQ,CAACG,MAA9B;AAEA;AAED;AAED,SAnBD,MAmBO;AAENZ,UAAAA,OAAO,CAACC,KAAR,CAAcU,KAAd,GAAsBF,QAAQ,CAACE,KAA/B;AACAX,UAAAA,OAAO,CAACC,KAAR,CAAcW,MAAd,GAAuBH,QAAQ,CAACG,MAAhC;AACAZ,UAAAA,OAAO,CAACc,OAAR,GAAkBL,QAAQ,CAACK,OAA3B;AAEA;;AAED,YAAKL,QAAQ,CAACO,WAAT,KAAyB,CAA9B,EAAkC;AAEjChB,UAAAA,OAAO,CAACiB,SAAR,GAAoBjC,YAApB;AAEA;;AAEDgB,QAAAA,OAAO,CAACa,MAAR,GAAiBJ,QAAQ,CAACI,MAA1B;AACAb,QAAAA,OAAO,CAACkB,WAAR,GAAsB,IAAtB;AAEA,YAAKvB,MAAL,EAAcA,MAAM,CAAEK,OAAF,CAAN;AAEd,OA1CD,EA0CGJ,UA1CH,EA0CeC,OA1Cf;AA4CA;;AAED,WAAOG,OAAP;AAEA;AA9GoF,CAAlD,CAApC;AAmHA,SAASZ,uBAAT","sourcesContent":["import { LinearFilter } from '../constants.js';\nimport { FileLoader } from './FileLoader.js';\nimport { CompressedTexture } from '../textures/CompressedTexture.js';\nimport { Loader } from './Loader.js';\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nfunction CompressedTextureLoader( manager ) {\n\n\tLoader.call( this, manager );\n\n}\n\nCompressedTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: CompressedTextureLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar images = [];\n\n\t\tvar texture = new CompressedTexture();\n\t\ttexture.image = images;\n\n\t\tvar loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tvar texDatas = scope.parse( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tvar loaded = 0;\n\n\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar texDatas = scope.parse( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps: [] };\n\n\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n} );\n\n\nexport { CompressedTextureLoader };\n"]},"metadata":{},"sourceType":"module"}