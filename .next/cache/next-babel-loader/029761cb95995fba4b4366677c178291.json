{"ast":null,"code":"import _Object$create from \"@babel/runtime-corejs2/core-js/object/create\";\nimport { BackSide, NoBlending } from '../constants.js';\nimport { Scene } from '../scenes/Scene.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { BoxBufferGeometry } from '../geometries/BoxGeometry.js';\nimport { ShaderMaterial } from '../materials/ShaderMaterial.js';\nimport { cloneUniforms } from './shaders/UniformsUtils.js';\nimport { WebGLRenderTarget } from './WebGLRenderTarget.js';\nimport { CubeCamera } from '../cameras/CubeCamera.js';\n/**\n * @author alteredq / http://alteredqualia.com\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction WebGLRenderTargetCube(width, height, options) {\n  WebGLRenderTarget.call(this, width, height, options);\n}\n\nWebGLRenderTargetCube.prototype = _Object$create(WebGLRenderTarget.prototype);\nWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\nWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\n\nWebGLRenderTargetCube.prototype.fromEquirectangularTexture = function (renderer, texture) {\n  this.texture.type = texture.type;\n  this.texture.format = texture.format;\n  this.texture.encoding = texture.encoding;\n  var scene = new Scene();\n  var shader = {\n    uniforms: {\n      tEquirect: {\n        value: null\n      }\n    },\n    vertexShader: [\"varying vec3 vWorldDirection;\", \"vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\", \"\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\", \"}\", \"void main() {\", \"\tvWorldDirection = transformDirection( position, modelMatrix );\", \"\t#include <begin_vertex>\", \"\t#include <project_vertex>\", \"}\"].join('\\n'),\n    fragmentShader: [\"uniform sampler2D tEquirect;\", \"varying vec3 vWorldDirection;\", \"#define RECIPROCAL_PI 0.31830988618\", \"#define RECIPROCAL_PI2 0.15915494\", \"void main() {\", \"\tvec3 direction = normalize( vWorldDirection );\", \"\tvec2 sampleUV;\", \"\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\", \"\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\", \"\tgl_FragColor = texture2D( tEquirect, sampleUV );\", \"}\"].join('\\n')\n  };\n  var material = new ShaderMaterial({\n    type: 'CubemapFromEquirect',\n    uniforms: cloneUniforms(shader.uniforms),\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader,\n    side: BackSide,\n    blending: NoBlending\n  });\n  material.uniforms.tEquirect.value = texture;\n  var mesh = new Mesh(new BoxBufferGeometry(5, 5, 5), material);\n  scene.add(mesh);\n  var camera = new CubeCamera(1, 10, 1);\n  camera.renderTarget = this;\n  camera.renderTarget.texture.name = 'CubeCameraTexture';\n  camera.update(renderer, scene);\n  mesh.geometry.dispose();\n  mesh.material.dispose();\n  return this;\n};\n\nexport { WebGLRenderTargetCube };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/renderers/WebGLRenderTargetCube.js"],"names":["BackSide","NoBlending","Scene","Mesh","BoxBufferGeometry","ShaderMaterial","cloneUniforms","WebGLRenderTarget","CubeCamera","WebGLRenderTargetCube","width","height","options","call","prototype","constructor","isWebGLRenderTargetCube","fromEquirectangularTexture","renderer","texture","type","format","encoding","scene","shader","uniforms","tEquirect","value","vertexShader","join","fragmentShader","material","side","blending","mesh","add","camera","renderTarget","name","update","geometry","dispose"],"mappings":"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","sourcesContent":["import { BackSide, NoBlending } from '../constants.js';\nimport { Scene } from '../scenes/Scene.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { BoxBufferGeometry } from '../geometries/BoxGeometry.js';\nimport { ShaderMaterial } from '../materials/ShaderMaterial.js';\nimport { cloneUniforms } from './shaders/UniformsUtils.js';\nimport { WebGLRenderTarget } from './WebGLRenderTarget.js';\nimport { CubeCamera } from '../cameras/CubeCamera.js';\n\n/**\n * @author alteredq / http://alteredqualia.com\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction WebGLRenderTargetCube( width, height, options ) {\n\n\tWebGLRenderTarget.call( this, width, height, options );\n\n}\n\nWebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\nWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\n\nWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\n\nWebGLRenderTargetCube.prototype.fromEquirectangularTexture = function ( renderer, texture ) {\n\n\tthis.texture.type = texture.type;\n\tthis.texture.format = texture.format;\n\tthis.texture.encoding = texture.encoding;\n\n\tvar scene = new Scene();\n\n\tvar shader = {\n\n\t\tuniforms: {\n\t\t\ttEquirect: { value: null },\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec3 vWorldDirection;\",\n\n\t\t\t\"vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\",\n\n\t\t\t\"\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvWorldDirection = transformDirection( position, modelMatrix );\",\n\n\t\t\t\"\t#include <begin_vertex>\",\n\t\t\t\"\t#include <project_vertex>\",\n\n\t\t\t\"}\"\n\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tEquirect;\",\n\n\t\t\t\"varying vec3 vWorldDirection;\",\n\n\t\t\t\"#define RECIPROCAL_PI 0.31830988618\",\n\t\t\t\"#define RECIPROCAL_PI2 0.15915494\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec3 direction = normalize( vWorldDirection );\",\n\n\t\t\t\"\tvec2 sampleUV;\",\n\n\t\t\t\"\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\",\n\n\t\t\t\"\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\",\n\n\t\t\t\"\tgl_FragColor = texture2D( tEquirect, sampleUV );\",\n\n\t\t\t\"}\"\n\n\t\t].join( '\\n' ),\n\t};\n\n\tvar material = new ShaderMaterial( {\n\n\t\ttype: 'CubemapFromEquirect',\n\n\t\tuniforms: cloneUniforms( shader.uniforms ),\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader,\n\t\tside: BackSide,\n\t\tblending: NoBlending\n\n\t} );\n\n\tmaterial.uniforms.tEquirect.value = texture;\n\n\tvar mesh = new Mesh( new BoxBufferGeometry( 5, 5, 5 ), material );\n\n\tscene.add( mesh );\n\n\tvar camera = new CubeCamera( 1, 10, 1 );\n\n\tcamera.renderTarget = this;\n\tcamera.renderTarget.texture.name = 'CubeCameraTexture';\n\n\tcamera.update( renderer, scene );\n\n\tmesh.geometry.dispose();\n\tmesh.material.dispose();\n\n\treturn this;\n\n};\n\nexport { WebGLRenderTargetCube };\n"]},"metadata":{},"sourceType":"module"}