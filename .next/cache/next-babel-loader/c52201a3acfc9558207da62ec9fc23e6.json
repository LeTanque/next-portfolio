{"ast":null,"code":"import _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport { Box3 } from './Box3.js';\nimport { Vector3 } from './Vector3.js';\n\nvar _box = new Box3();\n/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n */\n\n\nfunction Sphere(center, radius) {\n  this.center = center !== undefined ? center : new Vector3();\n  this.radius = radius !== undefined ? radius : 0;\n}\n\n_Object$assign(Sphere.prototype, {\n  set: function (center, radius) {\n    this.center.copy(center);\n    this.radius = radius;\n    return this;\n  },\n  setFromPoints: function (points, optionalCenter) {\n    var center = this.center;\n\n    if (optionalCenter !== undefined) {\n      center.copy(optionalCenter);\n    } else {\n      _box.setFromPoints(points).getCenter(center);\n    }\n\n    var maxRadiusSq = 0;\n\n    for (var i = 0, il = points.length; i < il; i++) {\n      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\n    }\n\n    this.radius = Math.sqrt(maxRadiusSq);\n    return this;\n  },\n  clone: function () {\n    return new this.constructor().copy(this);\n  },\n  copy: function (sphere) {\n    this.center.copy(sphere.center);\n    this.radius = sphere.radius;\n    return this;\n  },\n  empty: function () {\n    return this.radius <= 0;\n  },\n  containsPoint: function (point) {\n    return point.distanceToSquared(this.center) <= this.radius * this.radius;\n  },\n  distanceToPoint: function (point) {\n    return point.distanceTo(this.center) - this.radius;\n  },\n  intersectsSphere: function (sphere) {\n    var radiusSum = this.radius + sphere.radius;\n    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n  },\n  intersectsBox: function (box) {\n    return box.intersectsSphere(this);\n  },\n  intersectsPlane: function (plane) {\n    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n  },\n  clampPoint: function (point, target) {\n    var deltaLengthSq = this.center.distanceToSquared(point);\n\n    if (target === undefined) {\n      console.warn('THREE.Sphere: .clampPoint() target is now required');\n      target = new Vector3();\n    }\n\n    target.copy(point);\n\n    if (deltaLengthSq > this.radius * this.radius) {\n      target.sub(this.center).normalize();\n      target.multiplyScalar(this.radius).add(this.center);\n    }\n\n    return target;\n  },\n  getBoundingBox: function (target) {\n    if (target === undefined) {\n      console.warn('THREE.Sphere: .getBoundingBox() target is now required');\n      target = new Box3();\n    }\n\n    target.set(this.center, this.center);\n    target.expandByScalar(this.radius);\n    return target;\n  },\n  applyMatrix4: function (matrix) {\n    this.center.applyMatrix4(matrix);\n    this.radius = this.radius * matrix.getMaxScaleOnAxis();\n    return this;\n  },\n  translate: function (offset) {\n    this.center.add(offset);\n    return this;\n  },\n  equals: function (sphere) {\n    return sphere.center.equals(this.center) && sphere.radius === this.radius;\n  }\n});\n\nexport { Sphere };","map":{"version":3,"sources":["/Users/tank/git/Portfolio/next-portfolio/node_modules/three/src/math/Sphere.js"],"names":["Box3","Vector3","_box","Sphere","center","radius","undefined","prototype","set","copy","setFromPoints","points","optionalCenter","getCenter","maxRadiusSq","i","il","length","Math","max","distanceToSquared","sqrt","clone","constructor","sphere","empty","containsPoint","point","distanceToPoint","distanceTo","intersectsSphere","radiusSum","intersectsBox","box","intersectsPlane","plane","abs","clampPoint","target","deltaLengthSq","console","warn","sub","normalize","multiplyScalar","add","getBoundingBox","expandByScalar","applyMatrix4","matrix","getMaxScaleOnAxis","translate","offset","equals"],"mappings":"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","sourcesContent":["import { Box3 } from './Box3.js';\nimport { Vector3 } from './Vector3.js';\n\nvar _box = new Box3();\n\n/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction Sphere( center, radius ) {\n\n\tthis.center = ( center !== undefined ) ? center : new Vector3();\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\n}\n\nObject.assign( Sphere.prototype, {\n\n\tset: function ( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points, optionalCenter ) {\n\n\t\tvar center = this.center;\n\n\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\tcenter.copy( optionalCenter );\n\n\t\t} else {\n\n\t\t\t_box.setFromPoints( points ).getCenter( center );\n\n\t\t}\n\n\t\tvar maxRadiusSq = 0;\n\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t}\n\n\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t},\n\n\tempty: function () {\n\n\t\treturn ( this.radius <= 0 );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t},\n\n\tintersectsPlane: function ( plane ) {\n\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\n\n\t},\n\n\tclampPoint: function ( point, target ) {\n\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Sphere: .clampPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\ttarget.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\ttarget.sub( this.center ).normalize();\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn target;\n\n\t},\n\n\tgetBoundingBox: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );\n\t\t\ttarget = new Box3();\n\n\t\t}\n\n\t\ttarget.set( this.center, this.center );\n\t\ttarget.expandByScalar( this.radius );\n\n\t\treturn target;\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n} );\n\n\nexport { Sphere };\n"]},"metadata":{},"sourceType":"module"}